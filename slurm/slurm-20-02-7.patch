diff --git a/META b/META
index 14b0b61bb9..c66b905f52 100644
--- a/META
+++ b/META
@@ -7,8 +7,8 @@
   Name:		slurm
   Major:	20
   Minor:	02
-  Micro:	6
-  Version:	20.02.6
+  Micro:	7
+  Version:	20.02.7
   Release:	1
 
 ##
diff --git a/NEWS b/NEWS
index 70c02589e4..b1bc9dbe1c 100644
--- a/NEWS
+++ b/NEWS
@@ -1,6 +1,17 @@
 This file describes changes in recent versions of Slurm. It primarily
 documents those changes that are of interest to users and administrators.
 
+* Changes in Slurm 20.02.7
+==========================
+ -- cons_tres - Fix DefCpuPerGPU
+ -- select/cray_aries - Correctly remove jobs/steps from blades using NPC.
+ -- Fix false positive oom-kill events on extern step termination when
+    jobacct_gather/cgroup configured.
+ -- Ensure SPANK prolog and epilog run without an explicit PlugStackConfig.
+ -- Fix missing xstrdup which could result in slurmctld segfault on array jobs.
+ -- Fix security issue in PrologSlurmctld and EpilogSlurmctld by always
+    prepending SPANK_ to all user-set environment variables. CVE-2021-31215.
+
 * Changes in Slurm 20.02.6
 ==========================
  -- Fix sbcast --fanout option.
diff --git a/configure b/configure
index 17b63b1dce..5fe542b67c 100755
--- a/configure
+++ b/configure
@@ -25104,7 +25104,7 @@ $as_echo "${x_ac_deprecated=no}" >&6; }
 
 
 
-ac_config_files="$ac_config_files Makefile auxdir/Makefile contribs/Makefile contribs/cray/Makefile contribs/cray/csm/Makefile contribs/cray/slurmsmwd/Makefile contribs/lua/Makefile contribs/mic/Makefile contribs/nss_slurm/Makefile contribs/pam/Makefile contribs/pam_slurm_adopt/Makefile contribs/perlapi/Makefile contribs/perlapi/libslurm/Makefile contribs/perlapi/libslurm/perl/Makefile.PL contribs/perlapi/libslurmdb/Makefile contribs/perlapi/libslurmdb/perl/Makefile.PL contribs/seff/Makefile contribs/torque/Makefile contribs/openlava/Makefile contribs/sgather/Makefile contribs/sgi/Makefile contribs/sjobexit/Makefile contribs/pmi/Makefile contribs/pmi2/Makefile doc/Makefile doc/man/Makefile doc/man/man1/Makefile doc/man/man3/Makefile doc/man/man5/Makefile doc/man/man8/Makefile doc/html/Makefile doc/html/configurator.html doc/html/configurator.easy.html etc/Makefile src/Makefile src/api/Makefile src/bcast/Makefile src/common/Makefile src/database/Makefile src/layouts/Makefile src/layouts/power/Makefile src/layouts/unit/Makefile src/lua/Makefile src/sacct/Makefile src/sacctmgr/Makefile src/sreport/Makefile src/salloc/Makefile src/sbatch/Makefile src/sbcast/Makefile src/sattach/Makefile src/scancel/Makefile src/scontrol/Makefile src/sdiag/Makefile src/sinfo/Makefile src/slurmctld/Makefile src/slurmd/Makefile src/slurmd/common/Makefile src/slurmd/slurmd/Makefile src/slurmd/slurmstepd/Makefile src/slurmdbd/Makefile src/slurmrestd/Makefile src/slurmrestd/ops/Makefile src/sprio/Makefile src/squeue/Makefile src/srun/Makefile src/srun/libsrun/Makefile src/sshare/Makefile src/sstat/Makefile src/strigger/Makefile src/sview/Makefile src/plugins/Makefile src/plugins/accounting_storage/Makefile src/plugins/accounting_storage/common/Makefile src/plugins/accounting_storage/filetxt/Makefile src/plugins/accounting_storage/mysql/Makefile src/plugins/accounting_storage/none/Makefile src/plugins/accounting_storage/slurmdbd/Makefile src/plugins/acct_gather_energy/Makefile src/plugins/acct_gather_energy/cray_aries/Makefile src/plugins/acct_gather_energy/ibmaem/Makefile src/plugins/acct_gather_energy/ipmi/Makefile src/plugins/acct_gather_energy/none/Makefile src/plugins/acct_gather_energy/rapl/Makefile src/plugins/acct_gather_energy/rsmi/Makefile src/plugins/acct_gather_energy/xcc/Makefile src/plugins/acct_gather_interconnect/Makefile src/plugins/acct_gather_interconnect/ofed/Makefile src/plugins/acct_gather_interconnect/none/Makefile src/plugins/acct_gather_filesystem/Makefile src/plugins/acct_gather_filesystem/lustre/Makefile src/plugins/acct_gather_filesystem/none/Makefile src/plugins/acct_gather_profile/Makefile src/plugins/acct_gather_profile/hdf5/Makefile src/plugins/acct_gather_profile/hdf5/sh5util/Makefile src/plugins/acct_gather_profile/influxdb/Makefile src/plugins/acct_gather_profile/none/Makefile src/plugins/auth/Makefile src/plugins/auth/jwt/Makefile src/plugins/auth/munge/Makefile src/plugins/auth/none/Makefile src/plugins/burst_buffer/Makefile src/plugins/burst_buffer/common/Makefile src/plugins/burst_buffer/datawarp/Makefile src/plugins/burst_buffer/generic/Makefile src/plugins/cli_filter/Makefile src/plugins/cli_filter/common/Makefile src/plugins/cli_filter/lua/Makefile src/plugins/cli_filter/none/Makefile src/plugins/cli_filter/syslog/Makefile src/plugins/cli_filter/user_defaults/Makefile src/plugins/core_spec/Makefile src/plugins/core_spec/cray_aries/Makefile src/plugins/core_spec/none/Makefile src/plugins/cred/Makefile src/plugins/cred/munge/Makefile src/plugins/cred/none/Makefile src/plugins/ext_sensors/Makefile src/plugins/ext_sensors/rrd/Makefile src/plugins/ext_sensors/none/Makefile src/plugins/gpu/Makefile src/plugins/gpu/generic/Makefile src/plugins/gpu/nvml/Makefile src/plugins/gpu/rsmi/Makefile src/plugins/gres/Makefile src/plugins/gres/common/Makefile src/plugins/gres/gpu/Makefile src/plugins/gres/nic/Makefile src/plugins/gres/mic/Makefile src/plugins/gres/mps/Makefile src/plugins/jobacct_gather/Makefile src/plugins/jobacct_gather/common/Makefile src/plugins/jobacct_gather/linux/Makefile src/plugins/jobacct_gather/cgroup/Makefile src/plugins/jobacct_gather/none/Makefile src/plugins/jobcomp/Makefile src/plugins/jobcomp/elasticsearch/Makefile src/plugins/jobcomp/filetxt/Makefile src/plugins/jobcomp/lua/Makefile src/plugins/jobcomp/none/Makefile src/plugins/jobcomp/script/Makefile src/plugins/jobcomp/mysql/Makefile src/plugins/job_container/Makefile src/plugins/job_container/cncu/Makefile src/plugins/job_container/none/Makefile src/plugins/job_submit/Makefile src/plugins/job_submit/all_partitions/Makefile src/plugins/job_submit/cray_aries/Makefile src/plugins/job_submit/defaults/Makefile src/plugins/job_submit/logging/Makefile src/plugins/job_submit/lua/Makefile src/plugins/job_submit/partition/Makefile src/plugins/job_submit/pbs/Makefile src/plugins/job_submit/require_timelimit/Makefile src/plugins/job_submit/throttle/Makefile src/plugins/launch/Makefile src/plugins/launch/slurm/Makefile src/plugins/mcs/Makefile src/plugins/mcs/account/Makefile src/plugins/mcs/group/Makefile src/plugins/mcs/none/Makefile src/plugins/mcs/user/Makefile src/plugins/node_features/Makefile src/plugins/node_features/knl_cray/Makefile src/plugins/node_features/knl_generic/Makefile src/plugins/power/Makefile src/plugins/power/common/Makefile src/plugins/power/cray_aries/Makefile src/plugins/power/none/Makefile src/plugins/preempt/Makefile src/plugins/preempt/none/Makefile src/plugins/preempt/partition_prio/Makefile src/plugins/preempt/qos/Makefile src/plugins/priority/Makefile src/plugins/priority/basic/Makefile src/plugins/priority/multifactor/Makefile src/plugins/prep/Makefile src/plugins/prep/script/Makefile src/plugins/proctrack/Makefile src/plugins/proctrack/cray_aries/Makefile src/plugins/proctrack/cgroup/Makefile src/plugins/proctrack/pgid/Makefile src/plugins/proctrack/linuxproc/Makefile src/plugins/route/Makefile src/plugins/route/default/Makefile src/plugins/route/topology/Makefile src/plugins/sched/Makefile src/plugins/sched/backfill/Makefile src/plugins/sched/builtin/Makefile src/plugins/sched/hold/Makefile src/plugins/select/Makefile src/plugins/select/cons_common/Makefile src/plugins/select/cons_res/Makefile src/plugins/select/cons_tres/Makefile src/plugins/select/cray_aries/Makefile src/plugins/select/linear/Makefile src/plugins/select/other/Makefile src/plugins/site_factor/Makefile src/plugins/site_factor/none/Makefile src/plugins/slurmctld/Makefile src/plugins/slurmctld/nonstop/Makefile src/plugins/switch/Makefile src/plugins/switch/cray_aries/Makefile src/plugins/switch/generic/Makefile src/plugins/switch/none/Makefile src/plugins/mpi/Makefile src/plugins/mpi/cray_shasta/Makefile src/plugins/mpi/none/Makefile src/plugins/mpi/pmi2/Makefile src/plugins/mpi/pmix/Makefile src/plugins/task/Makefile src/plugins/task/affinity/Makefile src/plugins/task/cgroup/Makefile src/plugins/task/cray_aries/Makefile src/plugins/task/none/Makefile src/plugins/topology/Makefile src/plugins/topology/3d_torus/Makefile src/plugins/topology/hypercube/Makefile src/plugins/topology/node_rank/Makefile src/plugins/topology/none/Makefile src/plugins/topology/tree/Makefile testsuite/Makefile testsuite/expect/Makefile testsuite/slurm_unit/Makefile testsuite/slurm_unit/api/Makefile testsuite/slurm_unit/api/manual/Makefile testsuite/slurm_unit/common/Makefile testsuite/slurm_unit/common/slurm_protocol_pack/Makefile testsuite/slurm_unit/common/slurmdb_pack/Makefile testsuite/slurm_unit/common/bitstring/Makefile"
+ac_config_files="$ac_config_files Makefile auxdir/Makefile contribs/Makefile contribs/cray/Makefile contribs/cray/csm/Makefile contribs/cray/slurmsmwd/Makefile contribs/lua/Makefile contribs/mic/Makefile contribs/nss_slurm/Makefile contribs/pam/Makefile contribs/pam_slurm_adopt/Makefile contribs/perlapi/Makefile contribs/perlapi/libslurm/Makefile contribs/perlapi/libslurm/perl/Makefile.PL contribs/perlapi/libslurmdb/Makefile contribs/perlapi/libslurmdb/perl/Makefile.PL contribs/seff/Makefile contribs/torque/Makefile contribs/openlava/Makefile contribs/sgather/Makefile contribs/sgi/Makefile contribs/sjobexit/Makefile contribs/pmi/Makefile contribs/pmi2/Makefile doc/Makefile doc/man/Makefile doc/man/man1/Makefile doc/man/man3/Makefile doc/man/man5/Makefile doc/man/man8/Makefile doc/html/Makefile doc/html/configurator.html doc/html/configurator.easy.html etc/Makefile src/Makefile src/api/Makefile src/bcast/Makefile src/common/Makefile src/database/Makefile src/layouts/Makefile src/layouts/power/Makefile src/layouts/unit/Makefile src/lua/Makefile src/sacct/Makefile src/sacctmgr/Makefile src/sreport/Makefile src/salloc/Makefile src/sbatch/Makefile src/sbcast/Makefile src/sattach/Makefile src/scancel/Makefile src/scontrol/Makefile src/sdiag/Makefile src/sinfo/Makefile src/slurmctld/Makefile src/slurmd/Makefile src/slurmd/common/Makefile src/slurmd/slurmd/Makefile src/slurmd/slurmstepd/Makefile src/slurmdbd/Makefile src/slurmrestd/Makefile src/slurmrestd/ops/Makefile src/sprio/Makefile src/squeue/Makefile src/srun/Makefile src/srun/libsrun/Makefile src/sshare/Makefile src/sstat/Makefile src/strigger/Makefile src/sview/Makefile src/plugins/Makefile src/plugins/accounting_storage/Makefile src/plugins/accounting_storage/common/Makefile src/plugins/accounting_storage/filetxt/Makefile src/plugins/accounting_storage/mysql/Makefile src/plugins/accounting_storage/none/Makefile src/plugins/accounting_storage/slurmdbd/Makefile src/plugins/acct_gather_energy/Makefile src/plugins/acct_gather_energy/cray_aries/Makefile src/plugins/acct_gather_energy/ibmaem/Makefile src/plugins/acct_gather_energy/ipmi/Makefile src/plugins/acct_gather_energy/none/Makefile src/plugins/acct_gather_energy/rapl/Makefile src/plugins/acct_gather_energy/rsmi/Makefile src/plugins/acct_gather_energy/xcc/Makefile src/plugins/acct_gather_interconnect/Makefile src/plugins/acct_gather_interconnect/ofed/Makefile src/plugins/acct_gather_interconnect/none/Makefile src/plugins/acct_gather_filesystem/Makefile src/plugins/acct_gather_filesystem/lustre/Makefile src/plugins/acct_gather_filesystem/none/Makefile src/plugins/acct_gather_profile/Makefile src/plugins/acct_gather_profile/hdf5/Makefile src/plugins/acct_gather_profile/hdf5/sh5util/Makefile src/plugins/acct_gather_profile/influxdb/Makefile src/plugins/acct_gather_profile/none/Makefile src/plugins/auth/Makefile src/plugins/auth/jwt/Makefile src/plugins/auth/munge/Makefile src/plugins/auth/none/Makefile src/plugins/burst_buffer/Makefile src/plugins/burst_buffer/common/Makefile src/plugins/burst_buffer/datawarp/Makefile src/plugins/burst_buffer/generic/Makefile src/plugins/cli_filter/Makefile src/plugins/cli_filter/common/Makefile src/plugins/cli_filter/lua/Makefile src/plugins/cli_filter/none/Makefile src/plugins/cli_filter/syslog/Makefile src/plugins/cli_filter/user_defaults/Makefile src/plugins/core_spec/Makefile src/plugins/core_spec/cray_aries/Makefile src/plugins/core_spec/none/Makefile src/plugins/cred/Makefile src/plugins/cred/munge/Makefile src/plugins/cred/none/Makefile src/plugins/ext_sensors/Makefile src/plugins/ext_sensors/rrd/Makefile src/plugins/ext_sensors/none/Makefile src/plugins/gpu/Makefile src/plugins/gpu/generic/Makefile src/plugins/gpu/nvml/Makefile src/plugins/gpu/rsmi/Makefile src/plugins/gres/Makefile src/plugins/gres/common/Makefile src/plugins/gres/gpu/Makefile src/plugins/gres/nic/Makefile src/plugins/gres/mic/Makefile src/plugins/gres/mps/Makefile src/plugins/jobacct_gather/Makefile src/plugins/jobacct_gather/common/Makefile src/plugins/jobacct_gather/linux/Makefile src/plugins/jobacct_gather/cgroup/Makefile src/plugins/jobacct_gather/none/Makefile src/plugins/jobcomp/Makefile src/plugins/jobcomp/elasticsearch/Makefile src/plugins/jobcomp/filetxt/Makefile src/plugins/jobcomp/lua/Makefile src/plugins/jobcomp/none/Makefile src/plugins/jobcomp/script/Makefile src/plugins/jobcomp/mysql/Makefile src/plugins/job_container/Makefile src/plugins/job_container/cncu/Makefile src/plugins/job_container/none/Makefile src/plugins/job_submit/Makefile src/plugins/job_submit/all_partitions/Makefile src/plugins/job_submit/cray_aries/Makefile src/plugins/job_submit/defaults/Makefile src/plugins/job_submit/logging/Makefile src/plugins/job_submit/lua/Makefile src/plugins/job_submit/partition/Makefile src/plugins/job_submit/pbs/Makefile src/plugins/job_submit/require_timelimit/Makefile src/plugins/job_submit/throttle/Makefile src/plugins/launch/Makefile src/plugins/launch/slurm/Makefile src/plugins/mcs/Makefile src/plugins/mcs/account/Makefile src/plugins/mcs/group/Makefile src/plugins/mcs/none/Makefile src/plugins/mcs/user/Makefile src/plugins/node_features/Makefile src/plugins/node_features/knl_cray/Makefile src/plugins/node_features/knl_generic/Makefile src/plugins/power/Makefile src/plugins/power/common/Makefile src/plugins/power/cray_aries/Makefile src/plugins/power/none/Makefile src/plugins/preempt/Makefile src/plugins/preempt/none/Makefile src/plugins/preempt/partition_prio/Makefile src/plugins/preempt/qos/Makefile src/plugins/priority/Makefile src/plugins/priority/basic/Makefile src/plugins/priority/multifactor/Makefile src/plugins/prep/Makefile src/plugins/prep/script/Makefile src/plugins/proctrack/Makefile src/plugins/proctrack/cray_aries/Makefile src/plugins/proctrack/cgroup/Makefile src/plugins/proctrack/pgid/Makefile src/plugins/proctrack/linuxproc/Makefile src/plugins/route/Makefile src/plugins/route/default/Makefile src/plugins/route/topology/Makefile src/plugins/sched/Makefile src/plugins/sched/backfill/Makefile src/plugins/sched/builtin/Makefile src/plugins/sched/hold/Makefile src/plugins/select/Makefile src/plugins/select/cons_common/Makefile src/plugins/select/cons_res/Makefile src/plugins/select/cons_tres/Makefile src/plugins/select/cray_aries/Makefile src/plugins/select/linear/Makefile src/plugins/select/other/Makefile src/plugins/site_factor/Makefile src/plugins/site_factor/none/Makefile src/plugins/slurmctld/Makefile src/plugins/slurmctld/nonstop/Makefile src/plugins/switch/Makefile src/plugins/switch/cray_aries/Makefile src/plugins/switch/generic/Makefile src/plugins/switch/none/Makefile src/plugins/mpi/Makefile src/plugins/mpi/cray_shasta/Makefile src/plugins/mpi/none/Makefile src/plugins/mpi/pmi2/Makefile src/plugins/mpi/pmix/Makefile src/plugins/task/Makefile src/plugins/task/affinity/Makefile src/plugins/task/cgroup/Makefile src/plugins/task/cray_aries/Makefile src/plugins/task/none/Makefile src/plugins/topology/Makefile src/plugins/topology/3d_torus/Makefile src/plugins/topology/hypercube/Makefile src/plugins/topology/node_rank/Makefile src/plugins/topology/none/Makefile src/plugins/topology/tree/Makefile testsuite/Makefile testsuite/expect/Makefile testsuite/slurm_unit/Makefile testsuite/slurm_unit/api/Makefile testsuite/slurm_unit/api/manual/Makefile testsuite/slurm_unit/common/Makefile testsuite/slurm_unit/common/slurm_protocol_pack/Makefile testsuite/slurm_unit/common/slurmdb_pack/Makefile testsuite/slurm_unit/common/bitstring/Makefile testsuite/slurm_unit/slurmd/Makefile testsuite/slurm_unit/slurmd/common/Makefile"
 
 
 cat >confcache <<\_ACEOF
@@ -26604,6 +26604,8 @@ do
     "testsuite/slurm_unit/common/slurm_protocol_pack/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/slurm_unit/common/slurm_protocol_pack/Makefile" ;;
     "testsuite/slurm_unit/common/slurmdb_pack/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/slurm_unit/common/slurmdb_pack/Makefile" ;;
     "testsuite/slurm_unit/common/bitstring/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/slurm_unit/common/bitstring/Makefile" ;;
+    "testsuite/slurm_unit/slurmd/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/slurm_unit/slurmd/Makefile" ;;
+    "testsuite/slurm_unit/slurmd/common/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/slurm_unit/slurmd/common/Makefile" ;;
 
   *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
diff --git a/configure.ac b/configure.ac
index e1aff79c3d..bcc9d5cc1f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -605,6 +605,8 @@ AC_CONFIG_FILES([Makefile
 		 testsuite/slurm_unit/common/slurm_protocol_pack/Makefile
 		 testsuite/slurm_unit/common/slurmdb_pack/Makefile
 		 testsuite/slurm_unit/common/bitstring/Makefile
+		 testsuite/slurm_unit/slurmd/Makefile
+		 testsuite/slurm_unit/slurmd/common/Makefile
 		 ]
 )
 
diff --git a/doc/man/man1/sacctmgr.1 b/doc/man/man1/sacctmgr.1
index cf08a8dc32..4db9036b57 100644
--- a/doc/man/man1/sacctmgr.1
+++ b/doc/man/man1/sacctmgr.1
@@ -102,6 +102,7 @@ Identical to the \fBadd\fR command.
 .TP
 \fBdelete\fR <\fIENTITY\fR> \fBwhere\fR <\fISPECS\fR>
 Delete the specified entities.
+Identical to the \fBremove\fR command.
 
 .TP
 \fBdump\fR <\fIENTITY\fR> [\fBFile\fR=\fIFILENAME\fR]
@@ -133,6 +134,11 @@ Modify an entity.
 \fBreconfigure\fR
 Reconfigures the SlurmDBD if running with one.
 
+.TP
+\fBremove\fR <\fIENTITY\fR> \fBwhere\fR <\fISPECS\fR>
+Delete the specified entities.
+Identical to the \fBdelete\fR command.
+
 .TP
 \fBshow\fR <\fIENTITY\fR> [<\fISPECS\fR>]
 Display information about the specified entity.
@@ -1202,6 +1208,19 @@ If set, and the QOS also has a UsageThreshold,
 any jobs submitted with this QOS that fall below the UsageThreshold
 will be held until their Fairshare Usage goes above the Threshold.
 .TP
+\fINoDecay\fP
+If set, this QOS will not have its GrpTRESMins,
+GrpWall and UsageRaw decayed by the slurm.conf PriorityDecayHalfLife or
+PriorityUsageResetPeriod settings.  This allows a QOS to provide aggregate
+limits that, once consumed, will not be replenished automatically.  Such a
+QOS will act as a time-limited quota of resources for an association
+that has access to it.  Account/user usage will still be decayed for
+associations using the QOS.  The QOS GrpTRESMins and
+GrpWall limits can be increased or the QOS RawUsage value reset to 0
+(zero) to again allow jobs submitted with this QOS to be queued (if
+DenyOnLimit is set) or run (pending with QOSGrp{TRES}MinutesLimit
+or QOSGrpWallLimit reasons, where {TRES} is some type of trackable resource).
+.TP
 \fINoReserve\fP
 If this flag is set and backfill scheduling is used, jobs using this QOS will
 not reserve resources in the backfill schedule's map of resources allocated
@@ -1226,25 +1245,12 @@ override any limits used by the requested partition's QOS limits.
 If set jobs using this QOS will be able to
 override the requested partition's TimeLimit.
 .TP
-\fIRequiresReservaton\fP
+\fIRequiresReservation\fP
 If set jobs using this QOS must designate a reservation when submitting a job.
 This option can be useful in restricting usage of a QOS that may have greater
 preemptive capability or additional resources to be allowed only within a
 reservation.
 .TP
-\fINoDecay\fP
-If set, this QOS will not have its GrpTRESMins,
-GrpWall and UsageRaw decayed by the slurm.conf PriorityDecayHalfLife or
-PriorityUsageResetPeriod settings.  This allows a QOS to provide aggregate
-limits that, once consumed, will not be replenished automatically.  Such a
-QOS will act as a time-limited quota of resources for an association
-that has access to it.  Account/user usage will still be decayed for
-associations using the QOS.  The QOS GrpTRESMins and
-GrpWall limits can be increased or the QOS RawUsage value reset to 0
-(zero) to again allow jobs submitted with this QOS to be queued (if
-DenyOnLimit is set) or run (pending with QOSGrp{TRES}MinutesLimit
-or QOSGrpWallLimit reasons, where {TRES} is some type of trackable resource).
-.TP
 \fIUsageFactorSafe\fP
 If set, and \fIAccountingStorageEnforce\fR includes \fISafe\fR, jobs will only
 be able to run if the job can run to completion with the \fIUsageFactor\fR
@@ -1298,6 +1304,32 @@ running jobs will be killed.
 \fIID\fP
 The id of the QOS.
 
+.TP
+\fIMaxJobsAccruePerAccount\fP
+Maximum number of pending jobs an account (or subacct) can have accruing age
+priority at any given time.
+
+.TP
+\fIMaxJobsAccruePerUser\fP
+Maximum number of pending jobs a user can have accruing age priority at any
+given time.
+
+.TP
+\fIMaxJobsPerAccount\fP
+Maximum number of jobs each account is allowed to run at one time.
+
+.TP
+\fIMaxJobsPerUser\fP
+Maximum number of jobs each user is allowed to run at one time.
+
+.TP
+\fIMaxSubmitJobsPerAccount\fP
+Maximum number of jobs pending or running state at any time per account.
+
+.TP
+\fIMaxSubmitJobsPerUser\fP
+Maximum number of jobs pending or running state at any time per user.
+
 .TP
 \fIMaxTRESMinsPerJob\fP
 Maximum number of TRES minutes each job is able to use.
@@ -1323,22 +1355,10 @@ Maximum number of TRES each node in a job allocation can use.
 Maximum number of TRES each user is able to use.
 
 .TP
-\fIMaxJobsAccruePerAccount\fP
-Maximum number of pending jobs an account (or subacct) can have accruing age
-priority at any given time.
-
-.TP
-\fIMaxJobsAccruePerUser\fP
-Maximum number of pending jobs a user can have accruing age priority at any
-given time.
-
-.TP
-\fIMaxJobsPerAccount\fP
-Maximum number of jobs each account is allowed to run at one time.
+\fIMaxWallDurationPerJob\fP
+Maximum wall clock time each job is able to use.
 
-.TP
-\fIMaxJobsPerUser\fP
-Maximum number of jobs each user is allowed to run at one time.
+\fBNOTE\fR: This setting shows up in the sacctmgr output as \fBMaxWall\fR.
 
 .TP
 \fIMinPrioThreshold\fP
@@ -1351,20 +1371,6 @@ Otherwise the job will pend until modified.
 
 \fBNOTE\fR: This setting shows up in the sacctmgr output as \fBMinTRES\fR.
 
-.TP
-\fIMaxSubmitJobsPerAccount\fP
-Maximum number of jobs pending or running state at any time per account.
-
-.TP
-\fIMaxSubmitJobsPerUser\fP
-Maximum number of jobs pending or running state at any time per user.
-
-.TP
-\fIMaxWallDurationPerJob\fP
-Maximum wall clock time each job is able to use.
-
-\fBNOTE\fR: This setting shows up in the sacctmgr output as \fBMaxWall\fR.
-
 .TP
 \fIName\fP
 Name of the QOS.
@@ -1376,6 +1382,15 @@ Other QOS\' this QOS can preempt.
 \fBNOTE\fP: The \fIPriority\fP of a QOS is NOT related to QOS preemption, only
 \fIPreempt\fP is used to define which QOS can preempt others.
 
+.TP
+\fIPreemptExemptTime\fP
+Specifies a minimum run time for jobs of this QOS before they are considered for
+preemption. This QOS option takes precedence over the global
+\fIPreemptExemptTime\fP. Setting to -1 disables the option, allowing another
+QOS or the global option to take effect. Setting to 0 indicates no minimum run
+time and supersedes the lower priority QOS (see \fIOverPartQOS\fP) and/or the
+global option in slurm.conf.
+
 .TP
 \fIPreemptMode\fP
 Mechanism used to preempt jobs or enable gang scheduling for this QOS
@@ -1388,15 +1403,6 @@ by specifying "OFF", "" or "Cluster", makes it use the default cluster\-wide
 See the description of the cluster\-wide \fBPreemptMode\fR parameter
 for further details of the available modes.
 
-.TP
-\fIPreemptExemptTime\fP
-Specifies a minimum run time for jobs of this QOS before they are considered for
-preemption. This QOS option takes precedence over the global
-\fIPreemptExemptTime\fP. Setting to -1 disables the option, allowing another
-QOS or the global option to take effect. Setting to 0 indicates no minimum run
-time and supersedes the lower priority QOS (see \fIOverPartQOS\fP) and/or the
-global option in slurm.conf.
-
 .TP
 \fIPriority\fP
 What priority will be added to a job\'s priority when using this QOS.
@@ -1885,18 +1891,23 @@ Get information about which associations were affected by the transactions.
 
 .TP
 \fIAction\fP
+Displays the type of Action that took place.
 
 .TP
 \fIActor\fP
+Displays the Actor to generate a transaction.
 
 .TP
 \fIInfo\fP
+Displays details of the transaction.
 
 .TP
 \fITimeStamp\fP
+Displays when the transaction occurred.
 
 .TP
 \fIWhere\fP
+Displays details of the constraints for the transaction.
 .P
 NOTE: If using the WithAssoc option you can also view the information
 about the various associations the transaction affected.  The
diff --git a/doc/man/man1/sreport.1 b/doc/man/man1/sreport.1
index df1ecf4fc9..cb6826a133 100644
--- a/doc/man/man1/sreport.1
+++ b/doc/man/man1/sreport.1
@@ -189,6 +189,13 @@ UserUtilizationByWckey, Utilization, WCKeyUtilizationByUser
 .B user
 \- TopUsage
 
+.LP
+\fBNOTE\fR: If \fBOverSubscribe\fR is configured to \fBFORCE\fR or \fBYES\fR
+in your slurm.conf and the system is not configured to use preemption
+(\fBPreemptMode=OFF\fR) accounting can easily grow to values greater than
+the actual utilization. It may be common on such systems to get error messages
+in the slurmdbd log stating: "We have more allocated time than is possible."
+
 .SH "REPORT DESCRIPTION"
 
 .TP
@@ -229,16 +236,16 @@ responding (assuming TrackSlurmctldDown is set in slurmdbd.conf).
 .IP Idle
 Time where nodes had no active jobs or reservations.
 .IP Overcommited
-Time that the nodes were over allocated, either with the \fB-O,
---overcommit\fP flag at submission time or \fBOverSubscribe\fP set to
-FORCE in the slurm.conf. This time is not counted against the total
-reported time.
+Time of eligible jobs waiting in the queue over the Reserved time. Unlike
+Reserved, this has no limit. It is typically useful to determine whether your
+system is overloaded and by how much.
 .IP PlannedDown
 Time that nodes were in use by a reservation created with the MAINT flag
 but not the IGNORE_JOBS flag.
 .IP Reserved
 Time that a node spent idle with eligible jobs in the queue that were
-unable to start due to time or size constraints. If this value is
+unable to start due to time or size constraints. The maximum time is limited
+to the amount of time possible on the system. If this value is
 not of importance for you then the number can be grouped with idle time.
 .IP TresCount
 Configured number of TRES' on the reported nodes. See also the
diff --git a/doc/man/man5/slurm.conf.5 b/doc/man/man5/slurm.conf.5
index 49d402edd0..4b077e89cd 100644
--- a/doc/man/man5/slurm.conf.5
+++ b/doc/man/man5/slurm.conf.5
@@ -1,4 +1,4 @@
-.TH "slurm.conf" "5" "Slurm Configuration File" "October 2020" "Slurm Configuration File"
+.TH "slurm.conf" "5" "Slurm Configuration File" "November 2020" "Slurm Configuration File"
 
 .SH "NAME"
 slurm.conf \- Slurm configuration file
@@ -1922,7 +1922,7 @@ priority.
 .TP
 \fBNO_NORMAL_PART\fR
 If set, the partition factor is not normalized against the highest partition
-\fBPriorityTier\fR.
+\fBPriorityJobFactor\fR.
 .TP
 \fBNO_NORMAL_QOS\fR
 If set, the QOS factor is not normalized against the highest qos priority.
@@ -5210,6 +5210,13 @@ will prevent oversubscription from happening due to preemption as well.
 \fBFORCE\fR that is greater than 1. For example, \fBOverSubscribe=FORCE:2\fR
 will permit two jobs per resource normally, but a third job can be started
 only if done so through preemption based upon QOS.
+
+\fBNOTE\fR: If \fBOverSubscribe\fR is configured to \fBFORCE\fR or \fBYES\fR
+in your slurm.conf and the system is not configured to use preemption
+(\fBPreemptMode=OFF\fR) accounting can easily grow to values greater than
+the actual utilization. It may be common on such systems to get error messages
+in the slurmdbd log stating: "We have more allocated time than is possible."
+
 .TP
 \fBYES\fR
 Makes all resources in the partition available for sharing upon request by
diff --git a/slurm.spec b/slurm.spec
index 4be5399454..e6ea07e37e 100644
--- a/slurm.spec
+++ b/slurm.spec
@@ -1,5 +1,5 @@
 Name:		slurm
-Version:	20.02.6
+Version:	20.02.7
 %define rel	1
 Release:	%{rel}%{?dist}
 Summary:	Slurm Workload Manager
diff --git a/src/common/plugstack.c b/src/common/plugstack.c
index 79c28b4897..67d2860332 100644
--- a/src/common/plugstack.c
+++ b/src/common/plugstack.c
@@ -66,6 +66,9 @@
 #define OPTIONAL "optional"
 #define INCLUDE  "include"
 
+static bool has_prolog = false;
+static bool has_epilog = false;
+
 struct spank_plugin_operations {
 	spank_f *init;
 	spank_f *job_prolog;
@@ -446,6 +449,17 @@ spank_stack_plugin_valid_for_context (struct spank_stack *stack,
 			return (1);
 		break;
 	case S_TYPE_SLURMD:
+		/*
+		 * Set flags if prolog/epilog exist, but only return 1 if
+		 * slurmd_exit is defined so that spank_init is only called when
+		 * slurmd_exit exists. slurmd needs to know whether to create a
+		 * spank stepd to run spank prolog/epilog in job_script context.
+		 */
+		if (p->ops.job_prolog)
+			has_prolog = true;
+		if (p->ops.job_epilog)
+			has_epilog = true;
+
 		if (p->ops.slurmd_exit)
 			return (1);
 		break;
@@ -2632,3 +2646,13 @@ extern bool spank_option_get_next_set(char **plugin, char **name,
 
 	return false;
 }
+
+extern bool spank_has_prolog()
+{
+	return has_prolog;
+}
+
+extern bool spank_has_epilog()
+{
+	return has_epilog;
+}
diff --git a/src/common/plugstack.h b/src/common/plugstack.h
index eacc063d06..8a9153731e 100644
--- a/src/common/plugstack.h
+++ b/src/common/plugstack.h
@@ -87,6 +87,16 @@ int spank_slurmd_exit (void);
 
 int spank_fini (stepd_step_rec_t *job);
 
+/*
+ * Return true if a loaded spank plugin has a prolog function defined.
+ */
+extern bool spank_has_prolog(void);
+
+/*
+ * Return true if a loaded spank plugin has an epilog function defined.
+ */
+extern bool spank_has_epilog(void);
+
 /*
  *  Option processing
  */
diff --git a/src/plugins/prep/script/prep_script_slurmctld.c b/src/plugins/prep/script/prep_script_slurmctld.c
index de517f9369..1fe4bf8a40 100644
--- a/src/plugins/prep/script/prep_script_slurmctld.c
+++ b/src/plugins/prep/script/prep_script_slurmctld.c
@@ -173,6 +173,8 @@ static char **_build_env(job_record_t *job_ptr, bool is_epilog)
 	if (job_ptr->spank_job_env_size) {
 		env_array_merge(&my_env,
 				(const char **) job_ptr->spank_job_env);
+		valid_spank_job_env(my_env, job_ptr->spank_job_env_size,
+				    job_ptr->user_id);
 	}
 
 	setenvf(&my_env, "SLURM_JOB_ACCOUNT", "%s", job_ptr->account);
diff --git a/src/plugins/prep/script/prep_script_slurmd.c b/src/plugins/prep/script/prep_script_slurmd.c
index 3689e042a7..2a53b63491 100644
--- a/src/plugins/prep/script/prep_script_slurmd.c
+++ b/src/plugins/prep/script/prep_script_slurmd.c
@@ -74,7 +74,6 @@ extern int slurmd_script(job_env_t *job_env, slurm_cred_t *cred,
 	char *path = is_epilog ? slurmctld_conf.epilog :
 				 slurmctld_conf.prolog;
 	char **env = _build_env(job_env, cred, is_epilog);
-	struct stat stat_buf;
 	int status = 0, rc;
 	uint32_t jobid = job_env->jobid;
 	int timeout = slurmctld_conf.prolog_epilog_timeout;
@@ -93,7 +92,8 @@ extern int slurmd_script(job_env_t *job_env, slurm_cred_t *cred,
 	 *   If both "script" mechanisms fail, prefer to return the "real"
 	 *   prolog/epilog status.
 	 */
-	if (conf->plugstack && (stat(conf->plugstack, &stat_buf) == 0))
+	if ((is_epilog && spank_has_epilog()) ||
+	    (!is_epilog && spank_has_prolog()))
 		status = _run_spank_job_script(name, env, jobid);
 	if ((rc = run_script(name, path, jobid, timeout, env, job_env->uid)))
 		status = rc;
diff --git a/src/plugins/select/cons_common/job_test.c b/src/plugins/select/cons_common/job_test.c
index cbf311b1ce..69c81ebcbf 100644
--- a/src/plugins/select/cons_common/job_test.c
+++ b/src/plugins/select/cons_common/job_test.c
@@ -317,7 +317,6 @@ static avail_res_t **_get_res_avail(job_record_t *job_ptr,
 
 	xassert(*cons_common_callbacks.can_job_run_on_node);
 
-	_set_gpu_defaults(job_ptr);
 	avail_res_array = xcalloc(select_node_cnt, sizeof(avail_res_t *));
 	i_first = bit_ffs(node_map);
 	if (i_first != -1)
@@ -866,6 +865,7 @@ static int _job_test(job_record_t *job_ptr, bitstr_t *node_bitmap,
 		    details_ptr->mc_ptr->sockets_per_node)
 			sockets_per_node =
 				details_ptr->mc_ptr->sockets_per_node;
+		_set_gpu_defaults(job_ptr);
 		details_ptr->min_gres_cpu = gres_plugin_job_min_cpu_node(
 			sockets_per_node,
 			details_ptr->ntasks_per_node,
diff --git a/src/plugins/select/cray_aries/select_cray_aries.c b/src/plugins/select/cray_aries/select_cray_aries.c
index b93cb6dea8..41d660132e 100644
--- a/src/plugins/select/cray_aries/select_cray_aries.c
+++ b/src/plugins/select/cray_aries/select_cray_aries.c
@@ -705,6 +705,49 @@ static void _stop_aeld_thread(void)
 }
 #endif
 
+static void _remove_job_from_blades(select_jobinfo_t *jobinfo)
+{
+	int i;
+
+	slurm_mutex_lock(&blade_mutex);
+	for (i=0; i<blade_cnt; i++) {
+		if (!bit_test(jobinfo->blade_map, i))
+			continue;
+		blade_array[i].job_cnt--;
+		if ((int32_t)blade_array[i].job_cnt < 0) {
+			error("blade %d job_cnt underflow", i);
+			blade_array[i].job_cnt = 0;
+		}
+
+		if (jobinfo->npc == NPC_SYS) {
+			bit_nclear(blade_nodes_running_npc, 0,
+				   node_record_count-1);
+		} else if (jobinfo->npc) {
+			bit_not(blade_nodes_running_npc);
+			bit_or(blade_nodes_running_npc,
+			       blade_array[i].node_bitmap);
+			bit_not(blade_nodes_running_npc);
+		}
+	}
+
+	if (jobinfo->npc)
+		last_npc_update = time(NULL);
+
+	slurm_mutex_unlock(&blade_mutex);
+}
+
+static void _remove_step_from_blades(step_record_t *step_ptr)
+{
+	select_jobinfo_t *jobinfo = step_ptr->job_ptr->select_jobinfo->data;
+	select_jobinfo_t *step_jobinfo = step_ptr->select_jobinfo->data;
+
+	if (jobinfo->used_blades) {
+		bit_not(jobinfo->used_blades);
+		bit_or(jobinfo->used_blades, step_jobinfo->blade_map);
+		bit_not(jobinfo->used_blades);
+	}
+}
+
 static void _free_blade(blade_info_t *blade_info)
 {
 	FREE_NULL_BITMAP(blade_info->node_bitmap);
@@ -1559,6 +1602,9 @@ extern int select_p_job_fini(job_record_t *job_ptr)
 #endif
 
 	other_job_fini(job_ptr);
+
+	_remove_job_from_blades(job_ptr->select_jobinfo->data);
+
 	return SLURM_SUCCESS;
 }
 
@@ -1717,6 +1763,8 @@ extern int select_p_step_finish(step_record_t *step_ptr, bool killing_step)
 
 	other_step_finish(step_ptr, killing_step);
 
+	_remove_step_from_blades(step_ptr);
+
 	return SLURM_SUCCESS;
 }
 
diff --git a/src/slurmctld/job_mgr.c b/src/slurmctld/job_mgr.c
index 432add238e..b2d0fc987e 100644
--- a/src/slurmctld/job_mgr.c
+++ b/src/slurmctld/job_mgr.c
@@ -4599,6 +4599,7 @@ extern job_record_t *job_array_split(job_record_t *job_ptr)
 	job_ptr_pend->node_bitmap_cg = NULL;
 	job_ptr_pend->nodes = NULL;
 	job_ptr_pend->nodes_completing = NULL;
+	job_ptr_pend->origin_cluster = xstrdup(job_ptr->origin_cluster);
 	job_ptr_pend->partition = xstrdup(job_ptr->partition);
 	job_ptr_pend->part_ptr_list = part_list_copy(job_ptr->part_ptr_list);
 	/* On jobs that are held the priority_array isn't set up yet,
diff --git a/src/slurmd/common/reverse_tree_math.c b/src/slurmd/common/reverse_tree_math.c
index 7e8edc8401..b6b07f4283 100644
--- a/src/slurmd/common/reverse_tree_math.c
+++ b/src/slurmd/common/reverse_tree_math.c
@@ -203,66 +203,4 @@ int reverse_tree_direct_children(int rank, int num_nodes, int width,
 	}
 	return i;
 }
-
-#if 0
-
-// Dumb brute force function
-static int dumb_direct_children(int *children, int width, int id,
-				int max_node_id)
-{
-	int child;
-	int count = 0;
-	for(child = id+1; child < max_node_id; child++){
-		int parent_id, child_num, depth, max_depth;
-		reverse_tree_info(child, max_node_id, width,
-				  &parent_id, &child_num,
-				  &depth, &max_depth);
-		if( parent_id == id ){
-			children[count++] = child;
-		}
-	}
-	return count;
-}
-
-int
-main(int argc, char **argv)
-{
-	int i, j;
-	int n = 8192;
-	int w = 5;
-
-	int parent, children, depth, maxdepth;
-
-	for (i = 0; i < n; i++) {
-		int children1[w], children2[w];
-		int cnt1, cnt2;
-
-		reverse_tree_info(i, n, w, &parent,
-				  &children, &depth, &maxdepth);
-		printf("\
-%d : par: %d nchild: %d depth: %d, maxdepth: %d\n",
-		       i, parent, children, depth, maxdepth);
-		cnt1 = dumb_direct_children(children1, w, i, n);
-		cnt2 = reverce_tree_direct_children(i, n, w, depth, children2);
-		if (cnt1 != cnt2 ) {
-			printf("\
-Direct children sanity check error: cnt1 = %d, cnt2 = %d\n", cnt1, cnt2);
-			return -1;
-		}
-
-		for(j = 0; j < cnt1; j++){
-
-			if (children1[j] != children2[j]) {
-				printf("\
-Direct children sanity check error: cnt1 = %d, cnt2 = %d\n", cnt1, cnt2);
-				printf("\
-Failed on %d'th element: children1[%d] = %d, children2[%d] = %d\n",
-				       j, j, children1[j], j, children2[j]);
-				return -1;
-			}
-		}
-	}
-
-	return 0;
-}
-#endif
+/* Original commented test converted into a unit test */
diff --git a/src/slurmd/slurmd/req.c b/src/slurmd/slurmd/req.c
index dea43856a8..42d612f5ec 100644
--- a/src/slurmd/slurmd/req.c
+++ b/src/slurmd/slurmd/req.c
@@ -5227,7 +5227,6 @@ _rpc_complete_batch(slurm_msg_t *msg)
 static void
 _rpc_terminate_job(slurm_msg_t *msg)
 {
-	bool		have_spank = false;
 	int             rc     = SLURM_SUCCESS;
 	kill_job_msg_t *req    = msg->data;
 	uid_t uid = g_slurm_auth_get_uid(msg->auth_cred);
@@ -5367,11 +5366,6 @@ _rpc_terminate_job(slurm_msg_t *msg)
 						uid);
 	}
 
-	if ((nsteps == 0) && !conf->epilog) {
-		struct stat stat_buf;
-		if (conf->plugstack && (stat(conf->plugstack, &stat_buf) == 0))
-			have_spank = true;
-	}
 	/*
 	 *  If there are currently no active job steps and no
 	 *    configured epilog to run, bypass asynchronous reply and
@@ -5379,7 +5373,7 @@ _rpc_terminate_job(slurm_msg_t *msg)
 	 *    request. We need to send current switch state on AIX
 	 *    systems, so this bypass can not be used.
 	 */
-	if ((nsteps == 0) && !conf->epilog && !have_spank) {
+	if ((nsteps == 0) && !conf->epilog && !spank_has_epilog()) {
 		debug4("sent ALREADY_COMPLETE");
 		if (msg->conn_fd >= 0) {
 			slurm_send_rc_msg(msg,
diff --git a/src/slurmd/slurmstepd/mgr.c b/src/slurmd/slurmstepd/mgr.c
index 602c57b6f4..e10348f4a9 100644
--- a/src/slurmd/slurmstepd/mgr.c
+++ b/src/slurmd/slurmstepd/mgr.c
@@ -1145,6 +1145,24 @@ static int _spawn_job_container(stepd_step_rec_t *job)
 	step_terminate_monitor_start(job);
 	proctrack_g_signal(job->cont_id, SIGKILL);
 	proctrack_g_wait(job->cont_id);
+
+	/*
+	 * When an event is registered using the cgroups notification API and
+	 * memory is constrained using task/cgroup, the following check needs to
+	 * happen before any memory cgroup hierarchy removal.
+	 *
+	 * The eventfd will be woken up by control file implementation *or*
+	 * when the cgroup is removed. Thus, for the second case (cgroup
+	 * removal) we could be notified with false positive oom events.
+	 *
+	 * acct_gather_profile_fini() and task_g_post_step() can remove the
+	 * cgroup hierarchy if the cgroup implementation of these plugins are
+	 * configured.
+	 */
+	for (uint32_t i = 0; i < job->node_tasks; i++)
+		if (task_g_post_term(job, job->task[i]) == ENOMEM)
+			job->oom_error = true;
+
 	/*
 	 * This function below calls jobacct_gather_fini(). For the case of
 	 * jobacct_gather/cgroup, it ends up doing the cgroup hierarchy cleanup
@@ -1154,10 +1172,6 @@ static int _spawn_job_container(stepd_step_rec_t *job)
 	acct_gather_profile_fini();
 
 	step_terminate_monitor_stop();
-	for (uint32_t i = 0; i < job->node_tasks; i++)
-		if (task_g_post_term(job, job->task[i]) == ENOMEM)
-			job->oom_error = true;
-
 	task_g_post_step(job);
 
 fail1:
@@ -1346,6 +1360,10 @@ job_manager(stepd_step_rec_t *job)
 		debug ("Unable to set dumpable to 1");
 #endif /* PR_SET_DUMPABLE */
 
+	/*
+	 * task_g_post_term() needs to be called before
+	 * acct_gather_profile_fini() and task_g_post_step().
+	 */
 	_wait_for_all_tasks(job);
 	acct_gather_profile_endpoll();
 	acct_gather_profile_g_node_step_end();
diff --git a/testsuite/expect/Makefile.am b/testsuite/expect/Makefile.am
index 1e115213a4..e28f281799 100644
--- a/testsuite/expect/Makefile.am
+++ b/testsuite/expect/Makefile.am
@@ -284,8 +284,6 @@ EXTRA_DIST = \
 	test7.20			\
 	test7.21			\
 	test7.21.prog.c			\
-	test7.23			\
-	test7.23.prog.c			\
 	test8.12			\
 	test9.1				\
 	test9.2				\
diff --git a/testsuite/expect/Makefile.in b/testsuite/expect/Makefile.in
index 13551e072c..bc0ec02991 100644
--- a/testsuite/expect/Makefile.in
+++ b/testsuite/expect/Makefile.in
@@ -705,8 +705,6 @@ EXTRA_DIST = \
 	test7.20			\
 	test7.21			\
 	test7.21.prog.c			\
-	test7.23			\
-	test7.23.prog.c			\
 	test8.12			\
 	test9.1				\
 	test9.2				\
diff --git a/testsuite/expect/README b/testsuite/expect/README
index 91b13b5b10..5bc2ac0fc7 100644
--- a/testsuite/expect/README
+++ b/testsuite/expect/README
@@ -38,6 +38,13 @@ testsuite_log_level:          logging threshold [$LOG_LEVEL_DEBUG]
 testsuite_log_format:         specifies the tracing fields used in logging
 testsuite_colorize:           boolean that turns colorization on or off
 testsuite_subtest_fatal:      first failing subtest aborts the test [false]
+testsuite_subtest_details:    add details of subtest in the summary [fail]
+                              possible values: all, fail, fail_skip or none
+testsuite_testproc_details:   add details of testprocs in the summary [fail]
+                              possible values: all, fail, fail_skip or none
+testsuite_user:               a system username that is NOT on the Slurm DB
+                              that may be used to sudo commands as him
+                              instead of current user (see check_run_as_user)
 
 The testsuite needs at least one cluster-wide shared file system.
 By default, we assume that it's the testsuite/expect directory (i.e. ".").
@@ -67,6 +74,14 @@ test_dir:   a temporary subdirectory created within the testsuite_shared_dir *
   and testsuite_cleanup_on_failure was set to false. The test_dir will be
   (removed and) recreated the next time the test is run.
 
+A test can be run as normal executable (uses expect) and can read by default
+two main arguments:
+	-i : a comma-separated list of testproc ids to run
+	-e : a comma-separated list of testproc ids to skip
+These arguments will be removed and not available on argv on the tests.
+Test writers should use testproc to launch their testproc functions to
+take advantage of those arguments (see testproc function).
+
 The script "regression" will execute all of the tests and summarize the
 results. Standard output contains detailed logging of all events, which is
 quite verbose. Failure information is written to standard error. A good
@@ -386,7 +401,8 @@ test7.18   Test of slurm_hostlist_find().
 test7.19   Test sbatch/srun/salloc path resolving
 test7.20   Test lua JobSubmitPlugin
 test7.21   Test SPANK plugins that link against libslurm
-test7.23   Test time_str2secs parsing of different formats
+test7.22   Test basic functionality of backfill scheduler
+test7.23   Test min_mem_per_{cpu,node} in lua JobSubmitPlugin
 
 test8.#    Testing of advanced reservation functionality.
 =========================================================
@@ -597,6 +613,7 @@ test20.10  Test for the qrerun --help option
 test20.11  Test for the qrerun --man option
 test20.12  Test for qsub -V/-v arguments and their interaction with sbatch scripts
 test20.13  Test to test Grid Engine specific options
+test20.15  Test for seff
 
 test21.#   Testing of sacctmgr commands and options.
 ====================================================
@@ -636,7 +653,7 @@ test21.33  Validate that a resource can be added to a cluster after creation
 test21.34  Validate that partition and job QoS limits are enforced
 test21.35  Validate DenyOnLimit QoS flag is enforced on QoS and Associations.
 test21.36  Validate that sacctmgr lost jobs fixes lost jobs.
-test21.37  sacctmgr show stats
+test21.37  sacctmgr show and clear stats
 test21.38  sacctmgr modify limits for nested accounts with multiple users
 test21.39  sacctmgr create qos/account job and then delete account/qos
 test21.40  Test association plus partition/job QoS unique node limits enforced
@@ -841,3 +858,7 @@ test40.5   Increase size of job with allocated MPS
 test40.6   Decrease size of job with allocated MPS
 test40.7   DEFUNCT
 test40.8   Simple CUDA MPS test
+
+test41.#   Testing of slurmrestd
+=============================================================
+test41.1   Test slurmrestd plugins
diff --git a/testsuite/expect/globals b/testsuite/expect/globals
index 053cc297b2..29841d9976 100755
--- a/testsuite/expect/globals
+++ b/testsuite/expect/globals
@@ -51,11 +51,6 @@ if {[info procs exit] eq "exit"} {
 	return
 }
 
-#
-# Include private functions and variables
-#
-source ./globals_private
-
 global sacctmgr sacct salloc sattach sbatch sbcast scancel scontrol sinfo
 global smd squeue sreport srun sstat strigger
 
@@ -106,6 +101,8 @@ set LOG_LEVEL_FATAL   1
 set LOG_LEVEL_ERROR   2
 set LOG_LEVEL_WARNING 3
 set LOG_LEVEL_INFO    4
+set LOG_LEVEL_PASS    4
+set LOG_LEVEL_COMMAND 4
 set LOG_LEVEL_DEBUG   5
 set LOG_LEVEL_TRACE   6
 
@@ -147,6 +144,7 @@ cset sstat       "${slurm_dir}/bin/sstat"
 cset strigger    "${slurm_dir}/bin/strigger"
 
 cset slurmd      "${slurm_dir}/sbin/slurmd"
+cset slurmrestd  "${slurm_dir}/sbin/slurmrestd"
 
 cset pbsnodes    "${slurm_dir}/bin/pbsnodes"
 cset qdel        "${slurm_dir}/bin/qdel"
@@ -155,6 +153,8 @@ cset qsub        "${slurm_dir}/bin/qsub"
 cset qalter      "${slurm_dir}/bin/qalter"
 cset qrerun      "${slurm_dir}/bin/qrerun"
 
+cset seff        "${slurm_dir}/bin/seff"
+
 cset lsid      	 "${slurm_dir}/bin/lsid"
 cset bjobs     	 "${slurm_dir}/bin/bjobs"
 cset bkill     	 "${slurm_dir}/bin/bkill"
@@ -180,7 +180,7 @@ cset enable_memory_leak_debug 0
 # test_prompt: to be used as prompt for interactive shells
 set test_prompt  "TEST_PROMPT: "
 # reset_bash_prompt: to be used as command on scripts or interactive jobs
-set reset_bash_prompt "unset PROMPT_COMMAND; export PS1=\"$test_prompt\""
+set reset_bash_prompt "unset PROMPT_COMMAND; unset PS0; export PS1=\"$test_prompt\""
 
 #
 # Specify locations of other executable files used
@@ -221,6 +221,7 @@ cset bin_sed	"sed"
 cset bin_sleep  "sleep"
 cset bin_sort	"sort"
 cset bin_sum	"sum"
+cset bin_sudo	"sudo"
 cset bin_touch	"touch"
 cset bin_true	"true"
 cset bin_uname	"uname"
@@ -251,6 +252,9 @@ set ::env(LANG)          "en_US.UTF-8"
 # Testsuite level variables
 cset testsuite_shared_dir "[$bin_pwd]"
 
+# Testsuite non-privileged user (set it in globals.local)
+cset testsuite_user ""
+
 # Testsuite log variables
 cset testsuite_log_level $LOG_LEVEL_DEBUG
 cset testsuite_log_format "\[%{timestamp}s.%{msecs}03d] %{loglevel}-7s %{message}s \(%{backtrace}s)"
@@ -262,6 +266,8 @@ cset testsuite_color_fatal     $COLOR_RED
 cset testsuite_color_error     $COLOR_RED_NORMAL
 cset testsuite_color_warn      $COLOR_ORANGE
 cset testsuite_color_info      $COLOR_YELLOW
+cset testsuite_color_pass      $COLOR_GREEN
+cset testsuite_color_command   $COLOR_CYAN
 cset testsuite_color_debug     $COLOR_BLUE
 cset testsuite_color_trace     $COLOR_MAGENTA
 cset testsuite_color_header    $COLOR_NONE
@@ -270,7 +276,10 @@ cset testsuite_color_failure   $COLOR_RED
 cset testsuite_color_skipped   $COLOR_ORANGE
 
 # Set to true to cause the first subtest failure to immediately end the test
-cset testsuite_subtest_fatal false
+cset testsuite_subtest_fatal   false
+# Set to all, fail_skip, fail or none print datails of subtests and testprocs
+cset testsuite_subtest_details  fail
+cset testsuite_testproc_details fail
 
 # To automatically call cleanup or not when ending the test
 cset testsuite_cleanup_on_failure true
@@ -278,9 +287,24 @@ if {[info exists env(SLURM_TESTSUITE_CLEANUP_ON_FAILURE)]} {
 	set testsuite_cleanup_on_failure $env(SLURM_TESTSUITE_CLEANUP_ON_FAILURE)
 }
 
-set subtest_pass_count 0
-set subtest_skip_count 0
-set subtest_fail_count 0
+# To avoid potential infinite loops due calls to fail/pass/skip inside
+# custom cleanup procs (_test_fini should be called only once)
+set _test_fini_called false
+
+# Testproc internal variables
+set _testproc_included    [list]
+set _testproc_excluded    [list]
+set _testproc_pass_list   [list]
+set _testproc_skip_list   [list]
+set _testproc_fail_list   [list]
+set _testproc_messages    [dict create]
+set _testproc_skip_next   false
+set _testproc_skip_reason ""
+set _incomplete_reason    ""
+set _subtest_pass_count   0
+set _subtest_skip_count   0
+set _subtest_fail_count   0
+set _subtest_messages     [dict create]
 
 # Other common variables
 set re_word_str          "\\S+"
@@ -312,7 +336,7 @@ set gpu_sock_list {}
 #
 set RETURN_SUCCESS 0
 set RETURN_ERROR   1
-set RETURN_TIMEOUT 2
+set RETURN_TIMEOUT 110 ; # ETIMEDOUT
 
 
 ################################################################
@@ -340,6 +364,7 @@ set RETURN_TIMEOUT 2
 ################################################################
 
 proc fail { message } {
+	global _incomplete_reason
 
 	# Avoid recursive calls from within cleanup
 	if {[info level] > 1 && [lindex [info level -1] 0] eq "cleanup"} {
@@ -348,6 +373,7 @@ proc fail { message } {
 	}
 
 	log_fatal $message
+	set _incomplete_reason $message
 
 	# _test_fini will handle cleanup and print the failure message.
 	_test_fini 1
@@ -374,6 +400,7 @@ proc fail { message } {
 ################################################################
 
 proc skip { message } {
+	global _incomplete_reason
 
 	# Avoid recursive calls from within cleanup
 	if {[info level] > 1 && [lindex [info level -1] 0] eq "cleanup"} {
@@ -382,6 +409,7 @@ proc skip { message } {
 	}
 
 	log_warn $message
+	set _incomplete_reason $message
 
 	# _test_fini will handle cleanup and print the skipped message.
 	_test_fini -1
@@ -419,32 +447,6 @@ proc pass { } {
 }
 
 
-################################################################
-#
-# NAME
-#	fail_on_error - fails if exit_code is non-zero
-#
-# SYNOPSIS
-#	fail_on_error message
-#
-# DESCRIPTION
-#	If exit_code global variable is non-zero it calls fail with the
-#	message.
-#
-# NOTE
-#	DO NOT call this within your local cleanup procedure.
-#
-################################################################
-
-proc fail_on_error { message } {
-	global exit_code
-
-	if {$exit_code != 0} {
-		fail "$message"
-	}
-}
-
-
 ################################################################
 #
 # NAME
@@ -463,7 +465,8 @@ proc fail_on_error { message } {
 ################################################################
 
 proc subpass args {
-	global subtest_fail_count subtest_pass_count subtest_skip_count
+	global _subtest_fail_count _subtest_pass_count _subtest_skip_count
+	global _subtest_messages
 
 	set description ""
 	set argument_count [llength $args]
@@ -472,11 +475,12 @@ proc subpass args {
 		fail "Too many arguments ($argument_count): $args"
 	}
 
-	set subtest_count [expr $subtest_pass_count + $subtest_fail_count + $subtest_skip_count + 1]
-	incr subtest_pass_count
-	set message "Subtest $subtest_count passed"
-	if {$description ne ""} { append message ": $description" }
-	log_info $message
+	set subtest_count [expr $_subtest_pass_count + $_subtest_fail_count + $_subtest_skip_count + 1]
+	incr _subtest_pass_count
+	set message [format "Subtest %2d passed" $subtest_count]
+	if {$description ne ""} { append message "  : $description" }
+	log_pass $message
+	dict set _subtest_messages $subtest_count [list pass $message]
 }
 
 
@@ -508,8 +512,9 @@ proc subpass args {
 ################################################################
 
 proc subfail args {
-	global subtest_fail_count subtest_pass_count subtest_skip_count
+	global _subtest_fail_count _subtest_pass_count _subtest_skip_count
 	global testsuite_subtest_fatal
+	global _subtest_messages
 
 	set description ""
 	set fatal       false
@@ -523,16 +528,17 @@ proc subfail args {
 	set argument_count [llength $args]
 	if {$argument_count >= 1} { set args [lassign $args description] }
 
-	set subtest_count [expr $subtest_pass_count + $subtest_fail_count + $subtest_skip_count + 1]
-	incr subtest_fail_count
-	set message "Subtest $subtest_count failed"
-	if {$description ne ""} { append message ": $description" }
+	set subtest_count [expr $_subtest_pass_count + $_subtest_fail_count + $_subtest_skip_count + 1]
+	incr _subtest_fail_count
+	set message [format "Subtest %2d failed" $subtest_count]
+	if {$description ne ""} { append message "  : $description" }
 	if [llength $args] { append message " (" [join $args ", "] ")" }
 	if {$fatal || $testsuite_subtest_fatal} {
 		fail $message
 	} else {
 		log_error $message
 	}
+	dict set _subtest_messages $subtest_count [list fail $message]
 }
 
 
@@ -559,7 +565,8 @@ proc subfail args {
 ################################################################
 
 proc subskip args {
-	global subtest_fail_count subtest_pass_count subtest_skip_count
+	global _subtest_fail_count _subtest_pass_count _subtest_skip_count
+	global _subtest_messages
 
 	set description ""
 	set count       1
@@ -576,15 +583,16 @@ proc subskip args {
 		fail "Too many arguments ($argument_count): $args"
 	}
 
-	set subtest_count [expr $subtest_pass_count + $subtest_fail_count + $subtest_skip_count + 1]
-	incr subtest_skip_count $count
+	set subtest_count [expr $_subtest_pass_count + $_subtest_fail_count + $_subtest_skip_count + 1]
+	incr _subtest_skip_count $count
 	if {$count > 1} {
-		set message "$count subtests skipped"
+		set message "Subtest $subtest_count-[expr $subtest_count+$count-1] skipped"
 	} else {
-		set message "Subtest $subtest_count skipped"
+		set message [format "Subtest %2d skipped" $subtest_count]
 	}
-	if {$description ne ""} { append message ": $description" }
+	if {$description ne ""} { append message " : $description" }
 	log_warn $message
+	dict set _subtest_messages [expr $subtest_count] [list skip $message]
 }
 
 
@@ -683,6 +691,152 @@ proc _line_trace {} {
 }
 
 
+################################################################
+#
+# NAME
+#	tolerance - determines whether a value is within a specified tolerance
+#
+# SYNOPSIS
+#	tolerance expected observed tolerance_expression
+#
+# ARGUMENTS
+#	expected
+#		the expected (numeric) value
+#	observed
+#		the observed (numeric) value
+#	tolerance_expression
+#		a string of the form: [~][+|-]<tolerance>[%]
+#
+# DESCRIPTION
+#	tolerance
+#		A numeric tolerance
+#	symmetry
+#		By default the permitted range of values is symetric:
+#			[expected - tolerance, expected + tolerance]
+#		If the + sign is specified, the tolerance is limited to the
+#		the higher side only:
+#			[expected, expected + tolerance]
+#		If the - sign is specified, the tolerance is limited to the
+#		the lower side only:
+#			[expected - tolerance, expected]
+#	percent
+#		By default the permitted range is computed as absolute values:
+#			[expected - tolerance, expected + tolerance]
+#		If % is specified, the permitted range is computed as a
+#		percentage of the expected value:
+#			[expected*(1-tolerance/100), expected*(1+tolerance/100)]
+#	exclusivity
+#		By default the permitted range of values is inclusive, ie
+#		the min and max tolerated values are included in the range:
+#			[expected - tolerance, expected + tolerance]
+#		If ~ (exclusive) is specified, the tolerance limits are
+#		exclusive, ie the min and max tolerated values are excluded:
+#			(expected - tolerance, expected + tolerance)
+#	expression
+#		any combination of symetry, percent and exclusivity is allowed
+#
+# RETURN VALUE
+#	Returns true if the observed value is within the specified tolerance
+#	range of the expected value, otherwise false
+#
+# EXAMPLES
+#	The indicated tolerance_expression is true if:
+#	"5"     expected - 5  <= observed <= expected + 5
+#	"-5"    expected - 5  <= observed <= expected
+#	"+5"    expected      <= observed <= expected + 5
+#	"5%"    expected - 5% <= observed <= expected + 5%
+#	"~5"    expected - 5  <  observed <  expected + 5
+#	"~+5%"  expected      <= observed <  expected + 5%
+#
+################################################################
+
+proc tolerance { expected observed tolerance_expression } {
+	if {![regexp {^(~?)([-+]?)([0-9\.]+)(%?)$} $tolerance_expression {} exclusive sign tolerance percent]} {
+		fail "Invalid tolerance expression ($tolerance_expression)"
+	}
+
+	set lower_bound_expression $observed
+	if {$sign eq "+" || $exclusive ne "~"} {
+		append lower_bound_expression " >="
+	} else {
+		append lower_bound_expression " >"
+	}
+	append lower_bound_expression " $expected"
+	if {$sign eq "-" || $sign eq ""} {
+		if {$percent eq "%"} {
+			append lower_bound_expression " - $tolerance * $expected / 100"
+		} else {
+			append lower_bound_expression " - $tolerance"
+		}
+	}
+
+	set upper_bound_expression $observed
+	if {$sign eq "-" || $exclusive ne "~"} {
+		append upper_bound_expression " <="
+	} else {
+		append upper_bound_expression " <"
+	}
+	append upper_bound_expression " $expected"
+	if {$sign eq "+" || $sign eq ""} {
+		if {$percent eq "%"} {
+			append upper_bound_expression " + $tolerance * $expected / 100"
+		} else {
+			append upper_bound_expression " + $tolerance"
+		}
+	}
+
+	if {[expr $lower_bound_expression] && [expr $upper_bound_expression]} {
+		log_debug "$observed is within tolerance $tolerance_expression of $expected"
+		return true
+	} else {
+		log_warn "$observed is not within tolerance $tolerance_expression of $expected"
+		return false
+	}
+}
+
+
+################################################################
+#
+# NAME
+#	check_run_as_user - check if the caller may run_command as the supplied user
+#
+# SYNOPSIS
+#	check_run_as_user user
+#
+# DESCRIPTION
+#	Note that a proper sudo config needs to be set in orther to pass this
+#	check. Calling user should be permitted to run_commands as the
+#	supplied user using sudo without password.
+#	See the -user option of run_command.
+#	This proc also log_warn a message if user already exists in the DB
+#	because most probably this user is testsuite_user and that user is
+#	expected NOT to be in the DB and could potentially be removed from it by
+#	the test.
+#
+# RETURN VALUE
+#	Returns a boolean value indicating whether the calling user may
+#	run_command as user.
+#
+################################################################
+
+proc check_run_as_user user {
+	global bin_id
+
+	if {$user eq ""} {
+		return false
+	}
+	if {[run_command_status -none -user $user "$bin_id -un"]} {
+		return false
+	}
+
+	if {[get_admin_level $user] != ""} {
+		log_warn "User $user already exists in DB, but it's probable that it's going to be removed by the test cleanup"
+	}
+
+	return true
+}
+
+
 ################################################################
 #
 # NAME
@@ -693,32 +847,41 @@ proc _line_trace {} {
 #
 # DESCRIPTION
 #	Executes a command and returns a dictionary that includes the output,
-#	exit code, etc. An action can be taken (fail, warn, none)  if the
-#	command's exit code or timeout is unexpected. By default, the action
+#	exit code, etc. An action can be taken (fail, warn, subtest, none) if
+#	the command's exit code is unexpected. By default, the action
 #	will be applied if the command fails. If the -xfail option is
 #	specified, the behavior will be reversed to apply the action if the
 #	command ran successfully.
+#	A timeout is always treated as unexpected, so log_error will be shown
+#	by default, or fail/subfail will be called if -fail/-subtest are used.
 #
 # OPTIONS
 #	-fail
-#		If the exit code or timeout is unexpected, the action that will
+#		If the exit code is unexpected, the action that will
 #		be taken is to fail the test
+#	-subtest
+#		If the exit code is unexpected, the action that will
+#		be taken is to subfail, otherwise subpass will be called
 #	-warn
-#		If the exit code or timeout is unexpected, the action that will
+#		If the exit code is unexpected, the action that will
 #		be taken is to log a warning (this is the default)
 #	-none
-#		If the exit code or timeout is unexpected, no action will be
-#		taken
+#		If the exit code is unexpected, no action will be taken
 #	-xfail
-#		If the command exits with zero and does not time out, the
-#		action will be applied. Without this option, the action will
-#		be applied if the command exits with a non-zero exit code or
-#		times out.
+#		If the command exits with zero the action will be applied.
+#		Without this option, the action will be applied if the
+#		command exits with a non-zero exit code.
 #	-timeout <float_number>
 #		Time in seconds to wait for the command to complete before
 #		timing out (default is 60.0)
 #	-nolog
 #		Logging for this command will occur at trace threshold only
+#	-stdin
+#		Provide standard in to be piped into command
+#	-user <user>
+#		Attempt to execute command as <user>. Note that sudo must be
+#		properly configured to permit the caller to execute as <user>.
+#		See check_run_as_user.
 #
 # ARGUMENTS
 #	command
@@ -735,22 +898,28 @@ proc _line_trace {} {
 #
 ################################################################
 proc run_command args {
-	global bin_bash
+	global bin_bash bin_sudo
 
+	set alt_user ""
 	set exit_status 0
+	set timedout false
 	set output ""
 	set action "warn"
 	set timeout 60
 	set expect_failure false
 	set log_at_trace_level false
+	set stdin ""
 	while {[llength $args]} {
 		switch -glob -- [lindex $args 0] {
 			-fail    {set action "fail"; set args [lrange $args 1 end]}
+			-subtest {set action "subtest"; set args [lrange $args 1 end]}
 			-none    {set action "none"; set args [lrange $args 1 end]}
 			-timeout {set args [lassign $args - timeout]}
 			-warn    {set action "warn"; set args [lrange $args 1 end]}
 			-xfail   {set expect_failure true; set args [lrange $args 1 end]}
 			-nolog   {set log_at_trace_level true; set args [lrange $args 1 end]}
+			-stdin   {set stdin [lindex $args 1]; set args [lassign $args - stdin]}
+			-user    {set args [lassign $args - alt_user]}
 			-*       {fail "Unknown option: [lindex $args 0]"}
 			default  break
 		}
@@ -761,28 +930,50 @@ proc run_command args {
 		fail "Invalid number of arguments [llength $args]: $args"
 	}
 
+	if {$action eq "subtest"} {
+		if {$expect_failure} {
+			set test_description "Command \"$command\" should fail"
+		} else {
+			set test_description "Command \"$command\" should succeed"
+		}
+	}
+
 	if {$log_at_trace_level} {
-		interp alias {} log_alias {} log_trace
+		interp alias {} log_run     {} log_trace
+		interp alias {} log_details {} log_trace
 	} else {
-		interp alias {} log_alias {} log_debug
+		interp alias {} log_run     {} log_command
+		interp alias {} log_details {} log_debug
 	}
 
 	set orig_log_user [log_user -info]
 	log_user 0
 
-	log_alias "Invoking command \"$command\""
+	if {$alt_user ne ""} {
+		log_run "Run Command as user $alt_user: $command"
+	} else {
+		log_run "Run Command: $command"
+	}
 	set start_clock_ms [clock milliseconds]
 	set stty_init raw ; # Prevent the terminal from inserting \r
-	set expect_pid [spawn -noecho $bin_bash -c "$command"]
+	if {$alt_user ne ""} {
+		set expect_pid [spawn -noecho $bin_sudo -nu $alt_user $bin_bash -c "$command"]
+	} else {
+		set expect_pid [spawn -noecho $bin_bash -c "$command"]
+	}
+	if { $stdin != "" } {
+		exp_send "$stdin"
+		set command "$command <<< $stdin"
+	}
 	expect {
 		-re "(.+)" {
 			append output $expect_out(1,string)
 			exp_continue
 		}
 		timeout {
-			set message "Command \"$command\" timed out after $timeout seconds"
 			slow_kill $expect_pid
-			set exit_status 1
+			set exit_status $::RETURN_TIMEOUT
+			set timedout true
 		}
 		eof {
 			lassign [wait] pid spawnid os_error_flag errno
@@ -790,35 +981,48 @@ proc run_command args {
 		}
 	}
 	set start_time [format "%.3f" [expr $start_clock_ms / 1000.000]]
-	set start_hms [format "%s.%03d" [clock format [expr int($start_clock_ms / 1000.000)] -format %H:%M:%S] [expr int(fmod($start_clock_ms, 1000))]]
 	set end_time [format "%.3f" [expr [clock milliseconds] / 1000.000]]
 	set duration [format "%.3f" [expr $end_time - $start_time]]
 
-	log_alias "Command Results:"
-	log_alias "	Start Time: $start_hms"
-	log_alias "	Duration:   $duration"
-	log_alias "	Exit Code:  $exit_status"
+	log_details "Command Results:"
+	log_details "	Duration:   $duration"
+	log_details "	Exit Code:  $exit_status"
 	if {[info exists output]} {
-		log_alias "	Output: $output"
+		log_details "	Output: $output"
 	}
 
-	if {! $expect_failure && $exit_status != 0} {
-		cset message "Command \"$command\" failed with rc=$exit_status"
+	if {$timedout} {
+		set message "Command \"$command\" timed out after $timeout seconds"
+		if {$action eq "fail"} {
+			fail $message
+		} elseif {$action eq "subtest"} {
+			subfail $test_description $message
+		} else {
+			log_error $message
+		}
+	} elseif {! $expect_failure && $exit_status != 0} {
+		set message "Command \"$command\" failed with rc=$exit_status"
 		if {[info exists output] && $output != ""} {
 			append message ": [string trimright $output]"
 		}
 		if {$action eq "warn"} {
 			log_warn $message
+		} elseif {$action eq "subtest"} {
+			subfail $test_description $message
 		} elseif {$action eq "fail"} {
 			fail $message
 		}
 	} elseif {$expect_failure && $exit_status == 0} {
-		cset message "Command \"$command\" was expected to fail but succeeeded"
+		set message "Command \"$command\" was expected to fail but succeeeded"
 		if {$action eq "warn"} {
 			log_warn $message
+		} elseif {$action eq "subtest"} {
+			subfail $test_description $message
 		} elseif {$action eq "fail"} {
 			fail $message
 		}
+	} elseif {$action eq "subtest"} {
+		subpass $test_description
 	}
 	log_user $orig_log_user
 
@@ -866,6 +1070,8 @@ proc run_command args {
 #	-timeout <float_number>
 #		time in seconds to wait for the command to complete before
 #		timing out (default is 60.0)
+#	-stdin
+#		Provide standard in to be piped into command
 #
 # ARGUMENTS
 #	command
@@ -877,7 +1083,6 @@ proc run_command args {
 ################################################################
 
 proc run_command_output args {
-	global exit_code
 
 	set result [run_command {*}$args]
 
@@ -923,6 +1128,8 @@ proc run_command_output args {
 #	-timeout <float_number>
 #		time in seconds to wait for the command to complete before
 #		timing out (default is 60.0)
+#	-stdin
+#		Provide standard in to be piped into command
 #
 # ARGUMENTS
 #	command
@@ -934,7 +1141,6 @@ proc run_command_output args {
 ################################################################
 
 proc run_command_status args {
-	global exit_code
 
 	set result [run_command {*}$args]
 
@@ -957,6 +1163,9 @@ proc run_command_status args {
 #		1 if jobs are hetjobs and we want to confirm each
 #		component has completed
 #
+# DESCRIPTION
+#	Cancels one or more jobs. A job_id of 0 will be silently ignored.
+#
 # RETURN VALUE
 #	RETURN_SUCCESS if jobs are cancelled, or non-zero value otherwise.
 #
@@ -965,17 +1174,19 @@ proc run_command_status args {
 proc cancel_job { job_id_list {het_job 0}} {
 	global scancel
 
+	set job_list_clean [list]
 	foreach job_id $job_id_list {
-		if {$job_id == 0} {
-			log_warn "Invalid job_id argument value ($job_id)"
-			return $::RETURN_ERROR
+		if {$job_id != 0} {
+			lappend job_list_clean $job_id
 		}
+	}
 
-		log_debug "Cancelling $job_id"
-		if {[run_command_status "$scancel -Q $job_id"]} {
-			log_warn "scancel command returned error"
-			return $::RETURN_ERROR
-		}
+	log_debug "Cancelling $job_list_clean"
+	if {[run_command_status "$scancel -Q $job_list_clean"]} {
+		log_warn "scancel command returned error"
+		return $::RETURN_ERROR
+	}
+	foreach job_id $job_list_clean {
 		if {[wait_for_job $job_id "DONE" $het_job]} {
 			log_warn "Job $job_id not ended"
 			return $::RETURN_ERROR
@@ -1133,27 +1344,17 @@ proc get_my_user_name {  } {
 #	get_my_uid
 #
 # RETURN VALUE
-#	A non-zero return code indicates a failure.
+#	The uid of the current user, or fails.
 #
 ################################################################
 
 proc get_my_uid {  } {
 	global bin_id number
 
-	set uid -1
-
-	log_user 0
-	spawn $bin_id -u
-	expect {
-		-re "($number)" {
-			set uid $expect_out(1,string)
-			exp_continue
-		}
-		eof {
-			wait
-		}
+	set out [run_command_output -nolog -fail "$bin_id -u"]
+	if {![regexp "($number)" $out - uid]} {
+		fail "Unable to get UID with $bin_id ($out)"
 	}
-	log_user 1
 
 	return $uid
 }
@@ -1279,7 +1480,7 @@ proc kill_srun {  } {
 #	-fail
 #		abort the test with failure if the condition is not met
 #	-timeout <float_number>
-#		time in seconds to wait for the command to complete before
+#		time in seconds to wait for the condition to be met before
 #		timing out (default is 60.0)
 #	-pollinterval <float_number>
 #		time in seconds between each loop execution and condition check
@@ -1318,12 +1519,12 @@ proc wait_for args {
 
 	set start_time [format "%.3f" [expr [clock milliseconds] / 1000.000]]
 
-	log_debug "Waiting for $condition starting at [clock format [expr int($start_time)] -format %Y-%m-%dT%X].[lindex [split $start_time '.'] 1]"
+	log_debug "Waiting for $condition"
 
 	while {1} {
 		# Evaluate code block
 		log_trace "Evaluating code block ([string trim $body])"
-		set ret [catch {uplevel $body} result]
+		uplevel $body
 
 		# Check condition
 		if {[uplevel expr [format "{%s}" $condition]]} {
@@ -1357,120 +1558,149 @@ proc wait_for args {
 ################################################################
 #
 # NAME
-#	wait_for_command - waits for command output to match a pattern
+#	wait_for_command - repeat a command until it is successful or meets a specified condition
 #
 # SYNOPSIS
-#	wait_for_command ?options? command args regex ?matches_in? ?or_more? ?matches_out?
+#	wait_for_command ?options? command ?condition?
 #
 # DESCRIPTION
-#	Executes a command every poll interval until a regex
-#	pattern is matched in the output, or until timeout.
+#	A command is repeated until it meets a condition or a timeout is reached.
+#	If a condition is not specified, the command will be repeated until it
+#	is successful (the exit code is zero).
 #
 # OPTIONS
-#	-timeout <integer_number>
-#		time in seconds to wait for the command to complete before
-#		timing out (default is 120)
-#	-pollinterval <integer_number>
-#		time in seconds between each loop execution and condition check
-#		(default is 1)
+#	-fail
+#		abort the test with failure if the condition is not met by
+#		the timeout
+#	-timeout <float_number>
+#		time in seconds to wait for the condition to be met before
+#		timing out (default is 60.0)
+#	-pollinterval <float_number>
+#		time in seconds between each loop execution and condition
+#		check (default is 1.0)
 #
 # ARGUMENTS
 #	command
-#		The command to run via spawn.
-#	args
-#		The arguments to the command, as a single string.
-#	regex
-#		The regex pattern to search for in the command
-#		output. Can be a simple string.
-#	matches_in
-#		The number of times to match the regex. Defaults to 1.
-#	or_more
-#		If 1, allow for matching the regex pattern match_cnt *or more*
-#		times, instead of exactly match_cnt times. Defaults to 0.
-#	matches_out
-#		The upvar (a variable name to "pass by reference" in TCL)
-#		to set/return the number of matches found.
-#		Useful if or_more is 1 and the caller wants the	matches found.
+#		a string containing the command and arguments to execute
+#	condition
+#		The boolean expression to test. For each command invocation,
+#		the result variable will be set to the dictionary returned
+#		from run_command.
+#		The condition expression will normally involve a comparison
+#		with one or more values of this dictionary. If a condition is
+#		not specified, this condition will be used:
+#		{ [dict get $result exit_code] == 0 }
 #
 # RETURN VALUE
-#	RETURN_SUCCESS on success and RETURN_TIMEOUT on timeout.
-#	On failure, an error is logged to the output.
-#	If matches_out is specified, the number of matches will
-#	be returned via the reference/upvar matches_out.
+#	RETURN_SUCCESS if the condition is met before the timeout occurs,
+#	RETURN_TIMEOUT if the timeout occurs before the condition is met
 #
 ################################################################
 
 proc wait_for_command args {
-	global bin_sleep
-
-	set timeout       120
+	set fatal         false
+	set timeout       60
 	set poll_interval 1
-	set matches_in    1
-	set or_more       0
-	set matches_out   ""
 	while {[llength $args]} {
 		switch -glob -- [lindex $args 0] {
+			-fail   {set fatal true; set args [lrange $args 1 end]}
 			-time*  {set args [lassign $args - timeout]}
 			-poll*  {set args [lassign $args - poll_interval]}
 			-*      {fail "Unknown option: [lindex $args 0]"}
 			default break
 		}
 	}
+
 	set argument_count [llength $args]
-	if {$argument_count < 3} {
+	if {$argument_count < 1} {
 		fail "Too few arguments ($argument_count): $args"
-	} else {
-		lassign $args command arguments regex
-	}
-	if {$argument_count >= 4} { set matches_in [lindex $args 3] }
-	if {$argument_count >= 5} { set or_more [lindex $args 4] }
-	if {$argument_count == 6} { set matches_out [lindex $args 5] }
-	if {$argument_count > 6} {
+	} elseif {$argument_count > 2} {
 		fail "Too many arguments ($argument_count): $args"
 	}
-
-	if {$matches_out != ""} {
-		upvar $matches_out matches
+	lassign $args command
+	if {$argument_count == 2} {
+		set condition [lindex $args 1]
+	} else {
+		set condition { [dict get $result exit_code] == 0 }
 	}
 
-	set delay 0
-	while {$delay < $timeout} {
-		set matches 0
-		# `{*}` breaks apart a string into individual pieces
-		spawn $command {*}$arguments
-		expect {
-			-re $regex {
-				incr matches
-				exp_continue
-			}
-			timeout {
-				log_error "$command not responding after $delay seconds polling"
-				return $::RETURN_TIMEOUT
-			}
-			eof {
-				wait
-			}
-		}
+	set start_time [format "%.3f" [expr [clock milliseconds] / 1000.000]]
+
+	log_debug "Waiting for $condition"
 
-		if {($matches == $matches_in) || ($or_more == 1 &&
-		                                 $matches >= $matches_in)} {
+	while {1} {
+		# Run command
+		set result [run_command $command]
+
+		# Check condition
+		if {[eval expr [format "{%s}" $condition]]} {
+			set now [format "%.3f" [expr [clock milliseconds] / 1000.000]]
+			log_debug "Condition ($condition) was met"
 			return $::RETURN_SUCCESS
+		} else {
+			log_trace "Condition ($condition) was not met"
 		}
 
-		log_debug "Polled $matches matches of '$regex', but expecting $matches_in"
-		exec $bin_sleep $poll_interval
-		incr delay $poll_interval
+		# Sleep poll interval
+		log_trace "Sleeping for $poll_interval seconds"
+		after [expr {int($poll_interval * 1000)}]
 
+		# Check if we have surpassed our timeout
+		set now [format "%.3f" [expr [clock milliseconds] / 1000.000]]
+		log_trace "Checking whether the current time ([clock format [expr int($now)] -format %Y-%m-%dT%X].[lindex [split $now '.'] 1]) is greater than the start time plus the timeout ([clock format [expr int($start_time + $timeout)] -format %Y-%m-%dT%X].[lindex [split [expr $start_time + $timeout] '.'] 1])"
+		if {$now > $start_time + $timeout} {
+			set message "Condition ($condition) did not occur before timeout ($timeout) seconds"
+			if {$fatal} {
+				fail $message
+			} else {
+				log_warn $message
+				return $::RETURN_TIMEOUT
+			}
+		}
 	}
-	if {$or_more == 1} {
-		set match_str "$matches_in or more times"
-	} elseif {$matches_in == 1} {
-		set match_str "exactly $matches_in time"
-	} else {
-		set match_str "exactly $matches_in times"
-	}
-	log_error "Failed to match regex `$regex` $match_str after $timeout seconds for command `$command $arguments`."
-	return $::RETURN_TIMEOUT
+}
+
+
+################################################################
+#
+# NAME
+#	wait_for_command_match - repeat a command until its output matches the specified pattern
+#
+# SYNOPSIS
+#	wait_for_command_match ?options? command pattern
+#
+# DESCRIPTION
+#	A command is repeated until its output matches the specified pattern
+#
+# OPTIONS
+#	-fail
+#		abort the test with failure if output does not match the pattern
+#		by the timeout
+#	-timeout <float_number>
+#		time in seconds to wait for the pattern to be matched before
+#		timing out (default is 60.0)
+#	-pollinterval <float_number>
+#		time in seconds between each loop execution and match check
+#		(default is 1.0)
+#
+# ARGUMENTS
+#	command
+#		a string containing the command and arguments to execute
+#	pattern
+#		The regular expression to match against the command output
+#
+# RETURN VALUE
+#	RETURN_SUCCESS if the pattern is matched before the timeout occurs,
+#	RETURN_TIMEOUT if the timeout occurs before the pattern is matched
+#
+################################################################
+
+proc wait_for_command_match args {
+
+	set pattern [lindex $args end]
+	set args [lrange $args 0 end-1]
+
+	return [wait_for_command {*}$args "\[regexp {$pattern} \[dict get \$result output\]\] == 1"]
 }
 
 
@@ -1483,6 +1713,9 @@ proc wait_for_command args {
 #	wait_for_file ?options? file_name
 #
 # OPTIONS
+#	-fail
+#		If an error occurs or the file does not become present
+#		by the timeout, fail the test rather than returning an error
 #	-timeout <integer_number>
 #		time in seconds to wait for the file to exist before
 #		timing out (default is 90)
@@ -1495,18 +1728,21 @@ proc wait_for_command args {
 #	be purged then be re-created.
 #
 # RETURN VALUE
-#	RETURN_SUCCESS if job reaches the desired state, or non-zero value
-#	otherwise.
+#	RETURN_SUCCESS if the file becomes present within the timeout, or
+#	non-zero value otherwise.
 #
 ################################################################
 
 proc wait_for_file args {
 	global bin_sleep
 
+	set fatal         false
 	set timeout       90
 	set poll_interval 1
 	while {[llength $args]} {
 		switch -glob -- [lindex $args 0] {
+			-fatal  -
+			-fail   {set fatal true; set args [lrange $args 1 end]}
 			-time*  {set args [lassign $args - timeout]}
 			-poll*  {set args [lassign $args - poll_interval]}
 			-*      {fail "Unknown option: [lindex $args 0]"}
@@ -1540,7 +1776,12 @@ proc wait_for_file args {
 		}
 		exec /bin/ls $dir_name
 	}
-	log_error "Timeout waiting for file $file_name"
+	set message "Timeout waiting for file $file_name"
+	if {$fatal} {
+		fail $message
+	}
+
+	log_error $message
 	return $::RETURN_TIMEOUT
 }
 
@@ -1548,18 +1789,21 @@ proc wait_for_file args {
 ################################################################
 #
 # NAME
-#	wait_for_job - waits for job to be in desired state
+#	_wait_for_single_job - waits for a job to reach the desired state
 #
 # SYNOPSIS
-#	wait_for_job ?options? job_id desired_state ?het_job?
+#	_wait_for_single_job ?options? job_id desired_state
 #
 # DESCRIPTION
-#	Wait for job to be in desired state. Can handle het job components.
+#	Wait for a previously submitted Slurm job to reach the desired state.
 #
 # OPTIONS
+#	-fail
+#		If an error occurs or the job does not reach the desired state
+#		by the timeout, fail the test rather than returning an error
 #	-timeout <integer_number>
 #		time in seconds to wait for the job to be in the desired state
-#		before timing out (default is 90)
+#		before timing out (default is 360)
 #	-pollinterval <integer_number>
 #		time in seconds between each job state check (default is 1)
 #
@@ -1567,52 +1811,233 @@ proc wait_for_file args {
 #	job_id
 #		The Slurm job id of a job we want to wait for.
 #	desired_state
-#		The state you want the job to attain before returning.
-#		Currently supports:
+#		The state you want the job to attain before
+#		returning.  Currently supports:
 #			DONE any terminated state
 #			PENDING job is pending
 #			RUNNING job is running
 #			SPECIAL_EXIT
 #			SUSPENDED job is suspended
-#	het_job
-#		If set, checks the state of each component job if the job
-#		is a het one.
 #
 # RETURN VALUE
-#	RETURN_SUCCESS if job reaches the desired state, or non-zero value
-#	otherwise.
+#	RETURN_SUCCESS, or non-zero on error.
 #
-# SEE ALSO
-#	_wait_for_single_job
+# NOTE: We sleep for two seconds before replying that a job is
+# done to give time for I/O completion (stdout/stderr files)
 #
 ################################################################
 
-proc wait_for_job args {
-
-	set options  [list]
-	set het_job  0
+proc _wait_for_single_job args {
+	global scontrol
 
+	set fatal         false
+	set timeout       360
+	set poll_interval 1
 	while {[llength $args]} {
 		switch -glob -- [lindex $args 0] {
-			-* {
-				lappend options {*}[lrange $args 0 1]
-				set args [lrange $args 2 end]
-			}
+			-fatal  -
+			-fail   {set fatal true; set args [lrange $args 1 end]}
+			-time*  {set args [lassign $args - timeout]}
+			-poll*  {set args [lassign $args - poll_interval]}
+			-*      {fail "Unknown option: [lindex $args 0]"}
 			default break
 		}
 	}
 	set argument_count [llength $args]
-	if {$argument_count < 2} {
-		fail "Too few arguments ($argument_count): $args"
-	} elseif {$argument_count > 3}  {
-		fail "Too many arguments ($argument_count): $args"
+	if {$argument_count != 2} {
+		fail "Invalid number of arguments ($argument_count): $args"
 	} else {
 		lassign $args job_id desired_state
 	}
-	if {$argument_count == 3} { set hetjob [lindex $args 2] }
 
-	if { $het_job } {
-		# get component job ids
+	# First verify that desired_state is supported
+	switch $desired_state {
+		"DONE" {}
+		"PENDING" {}
+		"RUNNING" {}
+		"SPECIAL_EXIT" {}
+		"SUSPENDED" {}
+		default {
+			set message "Invalid desired state: $desired_state"
+			if {$fatal} {
+				fail $message
+			}
+			log_warn $message
+			return $::RETURN_ERROR
+		}
+	}
+
+	if {$job_id == 0} {
+		set message "Invalid job ID: $job_id"
+		if {$fatal} {
+			fail $message
+		}
+		log_warn $message
+		return $::RETURN_ERROR
+	}
+
+	set my_delay    0
+	while 1 {
+		set fd [open "|$scontrol -o show job $job_id"]
+		gets $fd line
+		catch {close $fd}
+		if {[regexp {JobState\s*=\s*(\w+)} $line foo state] != 1} {
+			set state "NOT_FOUND"
+		}
+
+		switch $state {
+			"NOT_FOUND" -
+			"BOOT_FAIL" -
+			"CANCELLED" -
+			"COMPLETED" -
+			"DEADLINE" -
+			"FAILED" -
+			"NODE_FAIL" -
+			"OUT_OF_MEMORY" -
+			"PREEMPTED" -
+			"TIMEOUT" {
+				if {[string compare $desired_state "DONE"] == 0} {
+					log_debug "Job $job_id is DONE ($state)"
+					sleep 2
+					return $::RETURN_SUCCESS
+				}
+				if {[string compare $desired_state "RUNNING"] == 0} {
+					set message "Job $job_id is $state, but we wanted RUNNING"
+				}
+				if {[string compare $desired_state "SUSPENDED"] == 0} {
+					set message "Job $job_id is $state, but we wanted SUSPENDED"
+				}
+				if {$fatal} {
+					fail $message
+				}
+				log_debug $message
+				return $::RETURN_ERROR
+			}
+			"PENDING" {
+				if {[string compare $desired_state "PENDING"] == 0} {
+					log_debug "Job $job_id is PENDING"
+					return $::RETURN_SUCCESS
+				}
+				log_debug "Job $job_id is in state $state, desire $desired_state"
+			}
+			"RUNNING" {
+				if {[string compare $desired_state "RUNNING"] == 0} {
+					log_debug "Job $job_id is RUNNING"
+					return $::RETURN_SUCCESS
+				}
+				log_debug "Job $job_id is in state $state, desire $desired_state"
+			}
+			"SPECIAL_EXIT" {
+				if {[string compare $desired_state "SPECIAL_EXIT"] == 0} {
+					log_debug "Job $job_id is SPECIAL_EXIT"
+					return $::RETURN_SUCCESS
+				}
+				log_debug "Job $job_id is in state $state, desire $desired_state"
+			}
+			"SUSPENDED" {
+				if {[string compare $desired_state "SUSPENDED"] == 0} {
+					log_debug "Job $job_id is SUSPENDED"
+					return $::RETURN_SUCCESS
+				}
+				log_debug "Job $job_id is in state $state, desire $desired_state"
+			}
+			default {
+				log_debug "Job $job_id is in state $state, desire $desired_state"
+			}
+		}
+
+		if { $my_delay > $timeout } {
+			set message "Timeout waiting for job state $desired_state"
+			if {$fatal} {
+				fail $message
+			}
+			log_warn "Timeout waiting for job state $desired_state"
+			return $::RETURN_TIMEOUT
+		}
+
+		exec sleep $poll_interval
+		set my_delay [expr $my_delay + $poll_interval]
+	}
+}
+
+
+################################################################
+#
+# NAME
+#	wait_for_job - waits for job to be in desired state
+#
+# SYNOPSIS
+#	wait_for_job ?options? job_id desired_state ?het_job?
+#
+# DESCRIPTION
+#	Wait for job to be in desired state. Can handle het job components.
+#
+# OPTIONS
+#	-fail
+#		If an error occurs or the job does not reach the desired state
+#		by the timeout, fail the test rather than returning an error
+#	-timeout <integer_number>
+#		time in seconds to wait for the job to be in the desired state
+#		before timing out (default is 90)
+#	-pollinterval <integer_number>
+#		time in seconds between each job state check (default is 1)
+#
+# ARGUMENTS
+#	job_id
+#		The Slurm job id of a job we want to wait for.
+#	desired_state
+#		The state you want the job to attain before returning.
+#		Currently supports:
+#			DONE any terminated state
+#			PENDING job is pending
+#			RUNNING job is running
+#			SPECIAL_EXIT
+#			SUSPENDED job is suspended
+#	het_job
+#		If set, checks the state of each component job if the job
+#		is a het one.
+#
+# RETURN VALUE
+#	RETURN_SUCCESS if job reaches the desired state, or non-zero value
+#	otherwise.
+#
+# SEE ALSO
+#	_wait_for_single_job
+#
+################################################################
+
+proc wait_for_job args {
+
+	set options  [list]
+	set het_job  0
+
+	while {[llength $args]} {
+		switch -glob -- [lindex $args 0] {
+			-fatal  -
+			-fail   {
+				lappend options [lindex $args 0]
+				set args [lrange $args 1 end]
+			}
+			-time*  -
+			-poll*  {
+				lappend options {*}[lrange $args 0 1]
+				set args [lrange $args 2 end]
+			}
+			default break
+		}
+	}
+	set argument_count [llength $args]
+	if {$argument_count < 2} {
+		fail "Too few arguments ($argument_count): $args"
+	} elseif {$argument_count > 3}  {
+		fail "Too many arguments ($argument_count): $args"
+	} else {
+		lassign $args job_id desired_state
+	}
+	if {$argument_count == 3} { set hetjob [lindex $args 2] }
+
+	if { $het_job } {
+		# get component job ids
 		set jid_list [get_het_job_ids $job_id 1]
 	}
 
@@ -2131,21 +2556,41 @@ proc wait_job_reason args {
 #	get_config - returns a dictionary of slurm configuration parameters
 #
 # SYNOPSIS
-#	get_config
+#	get_config ?options?
 #
-# DESCRIPTION
-#	Uses `scontrol show config` to return the slurm configuration as
-#	a dictionary of parameter values.
+# OPTIONS
+#	-dbd
+#		uses `sacctmgr show config` to return slurmdbd configuration
+#		parameters
+#	-slurm
+#		uses `scontrol show config` to return slurm configuration
+#		parameters (this is the default)
+#
+# RETURN VALUE
+#	Returns a dictionary of parameter values
 #
 ################################################################
 
-proc get_config { } {
-	global scontrol
+proc get_config args {
+	global sacctmgr scontrol
+
+	set command "$scontrol"
+	while {[llength $args]} {
+		switch -glob -- [lindex $args 0] {
+			-slurm  {set command "$scontrol"; set args [lrange $args 1 end]}
+			-dbd    {set command "$sacctmgr"; set args [lrange $args 1 end]}
+			-*      {fail "Unknown option: [lindex $args 0]"}
+			default break
+		}
+	}
+	if {[llength $args] > 0} {
+		fail "[lindex [info level 0] 0]: No arguments allowed: $args"
+	}
 
-	set output [run_command_output -fail -nolog "$scontrol show config"]
+	set output [run_command_output -fail -nolog "$command show config"]
 
 	foreach line [split $output "\n"] {
-		if {[regexp {^(\w+) += (.*)$} $line {} param_name param_value] == 1} {
+		if {[regexp {^(\S+) += (.*)$} $line {} param_name param_value] == 1} {
 			dict set config_dict $param_name $param_value
 		}
 	}
@@ -2157,10 +2602,22 @@ proc get_config { } {
 ################################################################
 #
 # NAME
-#	get_config_param - returns a slurm configuration parameter
+#	get_config_param - returns a slurm configuration parameter value
 #
 # SYNOPSIS
-#	get_config_param parameter_name
+#	get_config_param ?options? parameter_name
+#
+# OPTIONS
+#	-dbd
+#		uses `sacctmgr show config` to return the specified slurmdbd
+#		configuration parameter value
+#	-slurm
+#		uses `scontrol show config` to return the specified slurm
+#		configuration parameter value (this is the default)
+#
+# ARGUMENTS
+#	parameter_name
+#		the parameter to return the value for
 #
 # DESCRIPTION
 #	Returns a specific configuration parameter value.
@@ -2171,9 +2628,25 @@ proc get_config { } {
 #
 ################################################################
 
-proc get_config_param { parameter_name } {
+proc get_config_param args {
+
+	set options [list]
+	while {[llength $args]} {
+		switch -glob -- [lindex $args 0] {
+			-* {
+				lappend options [lindex $args 0]
+				set args [lrange $args 1 end]
+			}
+			default break
+		}
+	}
+	if {[llength $args] == 1} {
+		lassign $args parameter_name
+	} else {
+		fail "[lindex [info level 0] 0]: Invalid number of arguments ([llength $args]): $args"
+	}
 
-	set config_dict [get_config]
+	set config_dict [get_config {*}$options]
 
 	if [dict exists $config_dict $parameter_name] {
 		return [dict get $config_dict $parameter_name]
@@ -2210,6 +2683,40 @@ proc param_contains { haystack needle } {
 }
 
 
+################################################################
+#
+# NAME
+#	param_value - returns the value of a parameter in a comma-separated-list
+#
+# SYNOPSIS
+#	param_value params_list param ?default?
+#
+# DESCRIPTION
+#	Searches for the specified param in the comma-separated-list
+#	string (params_list) and returns its value.
+#
+# RETURN VALUE
+#	Returns the value found or the optional default value if not found.
+#	If the param is found without a value, returns true (ie like
+#	param_contains).
+#
+################################################################
+
+proc param_value {params_list param {default false}} {
+	global re_word_str
+	foreach pair [split $params_list ","] {
+		if {[regexp "$param" $pair] == 1} {
+			if {[regexp "$param=($re_word_str)" $pair - value] == 1} {
+				return $value
+			} else {
+				return true
+			}
+		}
+	}
+	return $default
+}
+
+
 ################################################################
 #
 # NAME
@@ -2287,79 +2794,107 @@ proc get_mps_count_by_index { index hostname } {
 ################################################################
 #
 # NAME
-#	get_bb_types - gets the burst buffer plugins running with task/ stripped
+#	check_bb_emulate - determines if Cray burst buffers API is emulated
 #
 # SYNOPSIS
-#	get_bb_types
+#	check_bb_emulate
 #
 # RETURN VALUE
-#	Returns comma separated list of task plugins running without the task/
+#	Returns true if Cray burst buffers API is emulated, false otherwise
 #
 ################################################################
 
-proc get_bb_types { } {
-	global scontrol re_word_str
+proc check_bb_emulate { } {
+	global scontrol
 
 	log_user 0
-	set bb_types ""
-	spawn $scontrol show config
+	set bb_emulate false
+	spawn $scontrol show burst
 	expect {
-		-re "BurstBufferType *= ($re_word_str)" {
-			set parts [split $expect_out(1,string) ",/"]
-			while 1 {
-				set task_found [lsearch $parts "burst_buffer"]
-				if { $task_found == -1 } break
-				set parts [lreplace $parts $task_found $task_found]
-			}
-			set bb_types [join $parts ","]
+		-re "EmulateCray" {
+			set bb_emulate true
 			exp_continue
 		}
 		eof {
 			wait
 		}
 	}
-
 	log_user 1
-	return $bb_types
+	return $bb_emulate
 }
 
 
 ################################################################
 #
 # NAME
-#	priority_type - gets the priority plugin type
+#	check_bb_persistent - determines if persistent burst buffers can be created by users
 #
 # SYNOPSIS
-#	priority_type
-#
-# DESCRIPTION
-#	Use scontrol to determine the priority plugin
+#	check_bb_persistent
 #
 # RETURN VALUE
-#	Name of priority type
+#	Returns true if Cray burst buffers can be created by users,
+#	false otherwise
 #
 ################################################################
 
-proc priority_type {} {
+proc check_bb_persistent { } {
 	global scontrol
 
 	log_user 0
-	set name ""
-	set fd [open "|$scontrol show config"]
-	while {[gets $fd line] != -1} {
-		if {[regexp {^PriorityType *= priority/(\w+)} $line frag name]
-				== 1} {
-			break
+	set bb_persistent false
+	spawn $scontrol show burst
+	expect {
+		-re "EnablePersistent" {
+			set bb_persistent true
+			exp_continue
+		}
+		eof {
+			wait
 		}
 	}
-	catch {close $fd}
 	log_user 1
+	return $bb_persistent
+}
 
-	if {[string length $name] == 0} {
-		log_error "Could not identify the Priority Type"
+
+################################################################
+#
+# NAME
+#	get_bb_types - gets the burst buffer plugins running with task/ stripped
+#
+# SYNOPSIS
+#	get_bb_types
+#
+# RETURN VALUE
+#	Returns comma separated list of task plugins running without the task/
+#
+################################################################
+
+proc get_bb_types { } {
+	global scontrol re_word_str
+
+	log_user 0
+	set bb_types ""
+	spawn $scontrol show config
+	expect {
+		-re "BurstBufferType *= ($re_word_str)" {
+			set parts [split $expect_out(1,string) ",/"]
+			while 1 {
+				set task_found [lsearch $parts "burst_buffer"]
+				if { $task_found == -1 } break
+				set parts [lreplace $parts $task_found $task_found]
+			}
+			set bb_types [join $parts ","]
+			exp_continue
+		}
+		eof {
+			wait
+		}
 	}
 
-	return $name
+	log_user 1
+	return $bb_types
 }
 
 
@@ -2555,39 +3090,32 @@ proc check_config_select { type } {
 ################################################################
 
 proc get_total_cpus {} {
-	global sinfo scontrol re_word_str exit_code
+	global sinfo scontrol re_word_str
 
 	set partition [default_partition]
 	set cpu_cnt 0
+	set nodes_matched [list]
 
-	set re_with_cs    "CPUTot=(\\d+).*CoreSpecCount=(\\d+).*ThreadsPerCore=(\\d+)"
-	set re_without_cs "CPUTot=(\\d+)"
+	set re_with_cs    "NodeName=($re_word_str).*CPUTot=(\\d+).*CoreSpecCount=(\\d+).*ThreadsPerCore=(\\d+)"
+	set re_without_cs "NodeName=($re_word_str).*CPUTot=(\\d+)"
 
-	spawn $sinfo -h -o "%P %N" -p $partition --state=idle
-	expect {
-		-re "$partition\\* ($re_word_str)" {
-			set def_hostlist $expect_out(1,string)
-			exp_continue
-		}
-		timeout {
-			log_error "sinfo not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
+	set out [run_command_output -fail "$sinfo -h -o \"%P %N\" -p $partition --state=idle"]
+	if {[regexp "$partition\\* ($re_word_str)" $out - def_hostlist] != 1} {
+		fail "Not able to get the hostlist from sinfo"
 	}
-	set fd [open "|$scontrol --oneliner show node $def_hostlist"]
-	while {[gets $fd line] != -1} {
-		if {[regexp $re_with_cs $line frag tmp_cpu_cnt core_spec_cnt threads_per_core] == 1} {
-			set cpu_cnt [expr $cpu_cnt + $tmp_cpu_cnt - $core_spec_cnt * $threads_per_core]
-			continue
-		}
-		if {[regexp $re_without_cs $line frag tmp_cpu_cnt] == 1} {
+
+	set out [run_command_output "$scontrol --oneliner show node $def_hostlist"]
+	foreach {re node_name tmp_cpu_cnt core_spec_cnt threads_per_core} [regexp -all -inline -linestop $re_with_cs $out] {
+		set cpu_cnt [expr $cpu_cnt + $tmp_cpu_cnt - $core_spec_cnt * $threads_per_core]
+		lappend nodes_matched $node_name
+	}
+	foreach {re node_name tmp_cpu_cnt} [regexp -all -inline -linestop $re_without_cs $out] {
+		# Not count nodes already counted
+		if {[lsearch $nodes_matched $node_name] == -1} {
 			set cpu_cnt [expr $cpu_cnt + $tmp_cpu_cnt]
-			continue
 		}
 	}
+
 	return $cpu_cnt
 }
 
@@ -2598,7 +3126,7 @@ proc get_total_cpus {} {
 #	is_super_user - determines if user is root or SlurmUser
 #
 # SYNOPSIS
-#	is_super_user
+#	is_super_user ?user?
 #
 # DESCRIPTION
 #	Determine if user is a Slurm super user (i.e. user
@@ -2609,10 +3137,12 @@ proc get_total_cpus {} {
 #
 ################################################################
 
-proc is_super_user { } {
+proc is_super_user {{user ""}} {
 	global number
 
-	set user [get_my_user_name]
+	if {$user == ""} {
+		set user [get_my_user_name]
+	}
 
 	# Check if user is root
 	if {[string compare $user "root"] == 0} {
@@ -2704,69 +3234,21 @@ proc uint2hex {value} {
 ################################################################
 #
 # NAME
-#	available_nodes - returns number of available nodes
+#	partition_oversubscribe - determines the oversubscribe configuration of the specified partition
 #
 # SYNOPSIS
-#	available_nodes ?state? ?partition?
+#	partition_oversubscribe ?partition?
 #
 # DESCRIPTION
-#	Check to see if a given partition has a at least "num_nodes" number
-#	of nodes in the alloc, idle, or comp state.  This can be used to
-#	avoid launching a job that will never run because nodes are in the
-#	"drained" state or otherwise unavailable.
+#	Determine the oversubscribe configuration of the specified partition.
 #	If the partition is not specified, the default partition will be used.
 #
 # RETURN VALUE
-#	Returns the number of available nodes in the partition, or
-#	-1 on failure.
+#	Return the oversubscribe configuration of the specified partition.
 #
 ################################################################
 
-proc available_nodes { {state ""} {partition ""} } {
-	global sinfo
-
-	if {[string length $partition] == 0} {
-		set partition [default_partition]
-	}
-
-	if {[string length $state] == 0} {
-		set state "idle,alloc,comp"
-	}
-
-	set available -1
-	set fd [open "|$sinfo --noheader --partition $partition --state $state --format %D"]
-	gets $fd line
-	catch {close $fd}
-	regexp {\d+} $line available
-	if {[string match *K $line]} {
-		set available [expr $available * 1024]
-	} elseif {[string match *M $line]} {
-		set available [expr $available * 1048576]
-	}
-
-
-	return $available
-}
-
-
-################################################################
-#
-# NAME
-#	partition_oversubscribe - determines the oversubscribe configuration of the specified partition
-#
-# SYNOPSIS
-#	partition_oversubscribe ?partition?
-#
-# DESCRIPTION
-#	Determine the oversubscribe configuration of the specified partition.
-#	If the partition is not specified, the default partition will be used.
-#
-# RETURN VALUE
-#	Return the oversubscribe configuration of the specified partition.
-#
-################################################################
-
-proc partition_oversubscribe { {partition ""} } {
+proc partition_oversubscribe { {partition ""} } {
 	global sinfo
 
 	if {[string length $partition] == 0} {
@@ -2848,43 +3330,6 @@ proc default_part_exclusive {} {
 }
 
 
-################################################################
-#
-# NAME
-#	switch_type - determines the switch type
-#
-# SYNOPSIS
-#	switch_type
-#
-# DESCRIPTION
-#	Use scontrol to determine the switch type
-#
-# RETURN VALUE
-#	Name of SwitchType
-#
-################################################################
-
-proc switch_type {} {
-	global scontrol
-
-	set name ""
-	set fd [open "|$scontrol show config"]
-	while {[gets $fd line] != -1} {
-		if {[regexp {^SwitchType *= switch/(\w+)} $line frag name]
-				== 1} {
-			break
-		}
-	}
-	catch {close $fd}
-
-	if {[string length $name] == 0} {
-		log_error "Could not identify the switch type"
-	}
-
-	return $name
-}
-
-
 ################################################################
 #
 # NAME
@@ -2989,7 +3434,7 @@ proc get_suffix { hostname } {
 ################################################################
 
 proc check_acct_associations { } {
-	global sacctmgr number re_word_str exit_code
+	global sacctmgr number re_word_str
 
 	set rc true
 	log_user 0
@@ -3035,9 +3480,8 @@ proc check_acct_associations { } {
 		      exp_continue
 	       }
 	       timeout {
-			log_error "sacctmgr add not responding"
 			slow_kill $s_pid
-			set exit_code 1
+			fail "sacctmgr add not responding"
 	       }
 	       eof {
 		      wait
@@ -3104,30 +3548,31 @@ proc get_job_acct_freq { } {
 ################################################################
 #
 # NAME
-#	get_admin_level - gets the AdminLevel for the current user
+#	get_admin_level - gets the AdminLevel of the user
 #
 # SYNOPSIS
-#	get_admin_level
+#	get_admin_level ?user?
 #
 # RETURN VALUE
 #	AdminLevel for the current user
 #
 ################################################################
 
-proc get_admin_level { } {
-	global sacctmgr re_word_str re_word_str bin_id exit_code
+proc get_admin_level {{user_name ""}} {
+	global sacctmgr re_word_str re_word_str bin_id
 
 	set admin_level ""
-	set user_name ""
 
-	if {[is_super_user]} {
-		return "Administrator"
+	if {$user_name == ""} {
+		set user_name [get_my_user_name]
+		if { ![string length $user_name] } {
+			log_error "No name returned from id"
+			return ""
+		}
 	}
 
-	set user_name [get_my_user_name]
-	if { ![string length $user_name] } {
-		log_error "No name returned from id"
-		return ""
+	if {[is_super_user $user_name]} {
+		return "Administrator"
 	}
 
 	#
@@ -3154,163 +3599,6 @@ proc get_admin_level { } {
 }
 
 
-################################################################
-#
-# NAME
-#	get_control_machine - gets the ControlMachine parameter
-#
-# SYNOPSIS
-#	get_control_machine
-#
-# RETURN VALUE
-#	ControlMachine value
-#
-################################################################
-
-proc get_control_machine { } {
-	global scontrol re_word_str exit_code
-	#
-	# Use scontrol to find the ControlMachine
-	#
-	log_user 0
-	set control_machine ""
-	set scon_pid [spawn -noecho $scontrol show config]
-	expect {
-		# We need to handle two possible outputs of SlurmctldHost[0]:
-		# a) hostname
-		# b) hostname(IP)
-		-re "SlurmctldHost.0. *= ($re_word_str)" {
-			set par_idx [expr [string last "(" $expect_out(1,string)] -1]
-			if { $par_idx == -2 } {
-				set control_machine $expect_out(1,string)
-			} else {
-				set control_machine [string range $expect_out(1,string) 0 $par_idx]
-			}
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol not responding"
-			slow_kill $scon_pid
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-
-	log_user 1
-	return $control_machine
-}
-
-
-################################################################
-#
-# NAME
-#	get_node_cnt_in_part - determines how many nodes are in a given partition
-#
-# SYNOPSIS
-#	get_node_cnt_in_part ?partition?
-#
-# DESCRIPTION
-#	Determine how many nodes are in a given partition.
-#	If the partition is not specified, the default partition will be used.
-#
-# RETURN VALUE
-#	Returns count of nodes in a partition or 0 if unknown.
-#
-################################################################
-
-proc get_node_cnt_in_part { {partition ""} } {
-	global scontrol number
-
-	if {[string length $partition] == 0} {
-		set partition [default_partition]
-	}
-
-	log_user 0
-	set node_cnt 0
-	set scon_pid [spawn -noecho $scontrol show partition $partition]
-	expect {
-		-re "not found" {
-			log_error "Partition $partition doesn't exist"
-		}
-		-re "TotalNodes=($number)" {
-			set node_cnt $expect_out(1,string)
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol not responding"
-		}
-		eof {
-		}
-	}
-	log_user 1
-
-	return $node_cnt
-}
-
-
-################################################################
-#
-# NAME
-#	get_idle_node_in_part - gets an idle node in a given partition
-#
-# SYNOPSIS
-#	get_idle_node_in_part ?partition?
-#
-# DESCRIPTION
-#	Get an idle node in a given partition.
-#	If the partition is not specified, the default partition will be used.
-#
-# RETURN VALUE
-#	Returns name of node in a partition or "" if unknown.
-#
-################################################################
-
-proc get_idle_node_in_part { {partition ""} } {
-	global scontrol sinfo re_word_str
-
-	if {[string length $partition] == 0} {
-		set partition [default_partition]
-	}
-
-	log_user 0
-	set host_list ""
-	spawn $sinfo -oNAME=%N -h -p$partition --state=idle
-	expect {
-		-re "not found" {
-			log_error "Partition $partition doesn't exist"
-		}
-		-re "NAME=($re_word_str)" {
-			set host_list $expect_out(1,string)
-		}
-		timeout {
-			log_error "sinfo not responding"
-		}
-		eof {
-			wait
-		}
-	}
-
-	set node_name ""
-	spawn $scontrol show hostname $host_list
-	expect {
-		-re "($re_word_str)" {
-			set node_name $expect_out(1,string)
-		}
-		timeout {
-			log_error "scontrol not responding"
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
-
-	return $node_name
-}
-
-
 ###############################################################
 #
 # NAME
@@ -3487,93 +3775,6 @@ proc check_config_node_mem { } {
 }
 
 
-################################################################
-#
-# NAME
-#	slurmctld_plug_stack_nonstop - verifies that the SlurmctldPlugstack is set to nonstop
-#
-# SYNOPSIS
-#	slurmctld_plug_stack_nonstop
-#
-# DESCRIPTION
-#	Use scontrol to determine that the SlurmctldPlugstack is set to nonstop.
-#
-# RETURN VALUE
-#	1 if the value is set to nonstop.
-#
-################################################################
-
-proc slurmctld_plug_stack_nonstop { } {
-	global scontrol re_word_str exit_code
-
-	log_user 0
-	set nonstop_enforce 0
-	set scon_pid [spawn -noecho $scontrol show config]
-	expect {
-		-re "SlurmctldPlugstack *= ($re_word_str)" {
-			if {[string first $expect_out(1,string) "nonstop"] != -1} {
-				set nonstop_enforce 1
-			}
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol not responding"
-			slow_kill $scon_pid
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
-	return $nonstop_enforce
-}
-
-
-################################################################
-#
-# NAME
-#	job_submit_all_partitions - determines if the JobSubmitPlugins includes "all_partitions"
-#
-# SYNOPSIS
-#	job_submit_all_partitions
-#
-# DESCRIPTION
-#	Use scontrol to determine if the JobSubmitPlugins
-#	includes "all_partitions".
-#
-# RETURN VALUE
-#	1 if the value is set to nonstop.
-#
-################################################################
-
-proc job_submit_all_partitions { } {
-	global scontrol re_word_str exit_code
-
-	log_user 0
-	set all_partitions 0
-	set scon_pid [spawn -noecho $scontrol show config]
-	expect {
-		-re "JobSubmitPlugins *= ($re_word_str)" {
-			if {[string first $expect_out(1,string) "all_partitions"] != -1} {
-				set all_partitions 1
-			}
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol not responding"
-			slow_kill $scon_pid
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
-	return $all_partitions
-}
-
-
 ################################################################
 #
 # NAME
@@ -3680,67 +3881,37 @@ proc wait_for_node args {
 #####################################################################
 #
 # NAME
-#	available_nodes_hostnames - gets all available nodes in the system
+#	list2hostlist - converts a TCL list into a Slurm hostlist using scontrol
 #
 # SYNOPSIS
-#	available_nodes_hostnames partition ?also_power_save?
+#	list2hostlist nodes_list
 #
 # ARGUMENTS
 #
-#	partition
-#		to only return nodes of an specific partition
-#	also_power_save
-#		to include POWERING_DOWN and POWER_DOWN nodes
+#	nodes_list
+#		a TCL list of node names
 #
 # RETURN VALUE
-#	idle nodes, and also_power_save nodes if specified
+#	the hostlist form returned by scrontrol show hostlist
 #
 #####################################################################
 
-proc available_nodes_hostnames { partition {also_power_save false} } {
-
-	global sinfo re_word_str exit_code
+proc list2hostlist {nodes_list} {
+	global scontrol
 
-	log_user 0
-	set idle_nodelist ""
-	set sep ""
-	if {$also_power_save} {
-		set avail_states "idle,power_down,powering_down"
-	} else {
-		set avail_states "idle"
-	}
-	if {[string compare $partition ""] == 0} {
-		spawn $sinfo -t$avail_states -h -o%N
-	} else {
-		spawn $sinfo -t$avail_states -h -o%N -p$partition
-	}
-	expect {
-		-re "($re_word_str)" {
-			append idle_nodelist $sep
-			append idle_nodelist $expect_out(1,string)
-			set sep ","
-			exp_continue
-		}
-		timeout {
-			log_error "sinfo is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
-	return $idle_nodelist
+	set comalist [join $nodes_list ,]
+	set hostlist [run_command_output -fail "$scontrol show hostlist $comalist"]
+	set hostlist [string trimright $hostlist "\r\n"]
 }
 
 
 #####################################################################
 #
 # NAME
-#	get_partition_nodes - gets the list of node names in a given partition/states
+#	get_nodes_by_state - gets the list of node names in a given partition/states
 #
 # SYNOPSIS
-#	get_partition_nodes partition states
+#	get_nodes_by_state partition states
 #
 # DESCRIPTION
 #	Get the list of node names in a given partition/states
@@ -3756,7 +3927,7 @@ proc available_nodes_hostnames { partition {also_power_save false} } {
 #
 #####################################################################
 
-proc get_partition_nodes {partition states} {
+proc get_nodes_by_state {{states ""} {partition ""}} {
 
 	global sinfo re_word_str
 	log_user 0
@@ -3767,20 +3938,18 @@ proc get_partition_nodes {partition states} {
 	}
 
 	if {[string length $states] == 0} {
-		set sinfo_pid [spawn -noecho $sinfo -h -N -p $partition -o %N -e]
-	} else {
-		set sinfo_pid [spawn -noecho $sinfo -h -N -p $partition -o %N -t $states -e]
+		set states "Idle"
 	}
 
+	set sinfo_pid [spawn -noecho $sinfo -h -N -p $partition -o %N -t $states -e]
 	expect {
 		-re "($re_word_str)" {
 			lappend node_list $expect_out(1,string)
 			exp_continue
 		}
 		timeout {
-			log_error "sinfo not responding"
 			slow_kill $sinfo_pid
-			set exit_code 1
+			fail "sinfo not responding"
 		}
 		eof {
 			wait
@@ -3806,7 +3975,7 @@ proc get_partition_nodes {partition states} {
 #####################################################################
 
 proc set_partition_maximum_time_limit {partition limit} {
-	global scontrol exit_code
+	global scontrol
 
 	if {[string length $partition] == 0} {
 		set partition [default_partition]
@@ -3841,10 +4010,6 @@ proc set_partition_maximum_time_limit {partition limit} {
 		log_error "Unable to update partition MaxTime, got $maxtime, wanted $limit"
 		return $::RETURN_ERROR
 	}
-	if { $exit_code != 0 } {
-		log_error "set_partition_maximum_time_limit: Unexpected error."
-		return $::RETURN_ERROR
-	}
 
 	return $::RETURN_SUCCESS
 }
@@ -3867,8 +4032,7 @@ proc set_partition_maximum_time_limit {partition limit} {
 #####################################################################
 
 proc get_partition_maximum_time_limit {partition} {
-
-	global sinfo number exit_code
+	global sinfo number
 
 	if {[string length $partition] == 0} {
 		set partition [default_partition]
@@ -3909,9 +4073,8 @@ proc get_partition_maximum_time_limit {partition} {
 			exp_continue
 		}
 		timeout {
-			log_error "sinfo not responding"
 			slow_kill $sinfo_pid
-			set exit_code 1
+			fail "sinfo not responding"
 		}
 		eof {
 			wait
@@ -3941,7 +4104,7 @@ proc get_partition_maximum_time_limit {partition} {
 ################################################################
 
 proc get_partition_default_time_limit { {partition ""} } {
-	global sinfo number exit_code
+	global sinfo number
 
 	if {[string length $partition] == 0} {
 		set partition [default_partition]
@@ -3982,9 +4145,8 @@ proc get_partition_default_time_limit { {partition ""} } {
 			exp_continue
 		}
 		timeout {
-			log_error "sinfo not responding"
 			slow_kill $sinfo_pid
-			set exit_code 1
+			fail "sinfo not responding"
 		}
 		eof {
 			wait
@@ -4037,9 +4199,8 @@ proc get_node_cores {node} {
 			exp_continue
 		}
 		timeout {
-			log_error "sinfo not responding"
 			slow_kill $sinfo_pid
-			set exit_code 1
+			fail "sinfo not responding"
 		}
 		eof {
 			wait
@@ -4074,8 +4235,8 @@ proc get_node_cores {node} {
 #####################################################################
 
 proc get_node_cpus {node} {
-
 	global scontrol number
+
 	set nthreads -1
 	set nsockets 0
 	set ncores 0
@@ -4086,7 +4247,7 @@ proc get_node_cpus {node} {
 	}
 
 	# Get the number of CPUs on a node
-	set my_pid [spawn $scontrol show node $node]
+	set scontrol_pid [spawn $scontrol show node $node]
 	expect {
 		-re "CoresPerSocket=($number)" {
 			set ncores $expect_out(1,string)
@@ -4105,9 +4266,8 @@ proc get_node_cpus {node} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
 			slow_kill $scontrol_pid
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -4177,9 +4337,8 @@ proc get_part_total_cores {part states} {
 			exp_continue
 		}
 		timeout {
-			log_error "sinfo not responding"
 			slow_kill $sinfo_pid
-			set exit_code 1
+			fail "sinfo not responding"
 		}
 		eof {
 			wait
@@ -4260,63 +4419,6 @@ proc check_hosts_contiguous { check_hosts_list {partition ""} } {
 }
 
 
-#####################################################################
-#
-# NAME
-#	stop_root_user - detect, warn, and stop root user
-#
-# SYNOPSIS
-#	stop_root_user
-#
-# DESCRIPTION
-#	Detect, warn, and stop root user
-#
-# RETURN VALUE
-#	uid if not root user, exits otherwise
-#
-#####################################################################
-
-proc stop_root_user {} {
-
-	global bin_id number
-
-	set uid [get_my_uid]
-	if {$uid == -1} {
-		fail "Can't get my uid"
-	} elseif {$uid == 0} {
-		skip "Can't run this test as user root"
-	}
-
-	return $uid
-}
-
-
-proc expect_extern_step { } {
-	global scontrol
-	# If PrologFlags=contain is in slurm.conf, then an "extern" step will be
-	# launched on each node, so we need to check for 3 steps per
-	# job instead of 2.
-
-	log_user 0
-	set extern_step 0
-	set scon_pid [spawn -noecho $scontrol show config]
-	expect {
-		-re "PrologFlags\\s*=\\s*\[A-z/,\]*Contain" {
-			set extern_step 1
-		}
-		timeout {
-			fail "scontrol show config not responding"
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
-
-	return $extern_step
-}
-
-
 ################################################################
 #
 # NAME
@@ -4377,60 +4479,59 @@ proc get_het_job_ids { jobid {use_offset 0}} {
 #	reconfigure - calls scontrol reconfigure
 #
 # SYNOPSIS
-#	reconfigure ?cluster?
+#	reconfigure ?options? ?cluster?
 #
 # DESCRIPTION
-#	Calls scontrol reconfigure.
+#	Calls scontrol reconfigure. This routine takes the same options as
+#	run_command, passing them to the underlying run_command invocation.
+#	This command waits an additional 5 seconds before returning.
+#
+# OPTIONS
+#	See OPTIONS of run_command proc.
 #
 # ARGUMENTS
 #	cluster
 #		The cluster to reconfigure
 #
 # RETURN VALUE
-#	void
-#
-# ENVIRONMENT
-#	Sets exit_code to 1 on failure.
+#	RETURN_SUCCESS on success, otherwise RETURN_ERROR
 #
 ################################################################
 
-proc reconfigure { {cluster ""} } {
-	global exit_code scontrol timeout
+proc reconfigure args {
+	global scontrol
 
-	#
-	# Increase timeout just in case we're running under valgrind
-	#
-	set save_timeout $timeout
-	set timeout 20
-	if { $cluster == "" } {
-		spawn $scontrol reconfigure
-	} else {
-		spawn $scontrol -M$cluster reconfigure
-	}
-	expect {
-		-re "slurm_reconfigure error: Invalid user id" {
-			log_error "Invalid user id"
-			set exit_code 1
-			exp_continue
-		}
-		-re "Error|error" {
-			log_error "scontrol reconfigure error"
-			set exit_code 1
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
+	set options [list]
+	set cluster ""
+
+	while {[llength $args]} {
+		switch -glob -- [lindex $args 0] {
+			-* {
+				lappend options {*}[lrange $args 0 1]
+				set args [lrange $args 2 end]
+			}
+			default break
 		}
 	}
+	set argument_count [llength $args]
+	if {$argument_count > 1}  {
+		fail "Too many arguments ($argument_count): $args"
+	} elseif {$argument_count == 1} {
+		lassign $args cluster
+	}
+
+	set command $scontrol
+	if {$cluster ne ""} {
+		append command " -M$cluster"
+	}
+	append command " reconfigure"
+	set rc [run_command_status {*}$options "$command"]
+
 	#
-	# Wait for reconfigure to complete, then reset timeout and return.
+	# Wait 5 seconds for reconfigure to complete, then return.
 	#
 	sleep 5
-	set timeout $save_timeout
+	return $rc
 }
 
 
@@ -4481,21 +4582,65 @@ proc log_error {message} {
 #####################################################################
 #
 # NAME
-#	log_warn - prints a warning message
+#	log_warn - prints a warning message
+#
+# SYNOPSIS
+#	log_warn message
+#
+# SEE ALSO
+#	_log_format for options governing the message format and colorization
+#
+#####################################################################
+
+proc log_warn {message} {
+	global testsuite_log_level LOG_LEVEL_WARNING
+
+	if {$testsuite_log_level >= $LOG_LEVEL_WARNING} {
+		_log_format "warning" "$message"
+	}
+}
+
+
+#####################################################################
+#
+# NAME
+#	log_info - prints an information message
+#
+# SYNOPSIS
+#	log_info message
+#
+# SEE ALSO
+#	_log_format for options governing the message format and colorization
+#
+#####################################################################
+
+proc log_info {message} {
+	global testsuite_log_level LOG_LEVEL_INFO
+
+	if {$testsuite_log_level >= $LOG_LEVEL_INFO} {
+		_log_format "info" "$message"
+	}
+}
+
+
+#####################################################################
+#
+# NAME
+#	log_pass - prints a pass level message
 #
 # SYNOPSIS
-#	log_warn message
+#	log_pass message
 #
 # SEE ALSO
 #	_log_format for options governing the message format and colorization
 #
 #####################################################################
 
-proc log_warn {message} {
-	global testsuite_log_level LOG_LEVEL_WARNING
+proc log_pass {message} {
+	global testsuite_log_level LOG_LEVEL_PASS
 
-	if {$testsuite_log_level >= $LOG_LEVEL_WARNING} {
-		_log_format "warning" "$message"
+	if {$testsuite_log_level >= $LOG_LEVEL_PASS} {
+		_log_format "pass" "$message"
 	}
 }
 
@@ -4503,21 +4648,21 @@ proc log_warn {message} {
 #####################################################################
 #
 # NAME
-#	log_info - prints an information message
+#	log_command - prints a command level message
 #
 # SYNOPSIS
-#	log_info message
+#	log_command message
 #
 # SEE ALSO
 #	_log_format for options governing the message format and colorization
 #
 #####################################################################
 
-proc log_info {message} {
-	global testsuite_log_level LOG_LEVEL_INFO
+proc log_command {message} {
+	global testsuite_log_level LOG_LEVEL_COMMAND
 
-	if {$testsuite_log_level >= $LOG_LEVEL_INFO} {
-		_log_format "info" "$message"
+	if {$testsuite_log_level >= $LOG_LEVEL_COMMAND} {
+		_log_format "command" "$message"
 	}
 }
 
@@ -4623,13 +4768,10 @@ proc in_fed {} {
 #	on that state if it's a hetjob and het_job option enabled, false
 #	otherwise.
 #
-# ENVIRONMENT
-#	Also sets exit_code to 1 if there are some error in the called commands.
-#
 ################################################################
 
 proc check_job_state { job state {het_job 0}} {
-	global scontrol exit_code
+	global scontrol
 
 	set jid_list ""
 	if { $het_job } {
@@ -4649,9 +4791,7 @@ proc check_job_state { job state {het_job 0}} {
 				incr state_match
 			}
 			timeout {
-				log_error "scontrol not responding"
-				set exit_code 1
-				return false
+				fail "scontrol not responding"
 			}
 			eof {
 				wait
@@ -4765,7 +4905,7 @@ proc count_gres { gres_param } {
 
 proc get_highest_gres_count { node_count gres_name } {
 
-	set available_nodes [available_nodes_hostnames [default_partition]]
+	set available_nodes [list2hostlist [get_nodes_by_state]]
 	set gres_dict [get_gres_count $gres_name $available_nodes]
 	set gres_count [list]
 
@@ -4948,7 +5088,7 @@ proc get_highest_mps_count { node_count } {
 	# We cannot use get_highest_gres_count because we need "per gpu",
 	# so we get all the mps per node and all gpus per node, to create
 	# a mps_per_gpu list to sort and get the count.
-	set available_nodes [available_nodes_hostnames [default_partition]]
+	set available_nodes [list2hostlist [get_nodes_by_state]]
 	set mps_dict [get_gres_count "mps" $available_nodes]
 	set gpu_dict [get_gres_count "gpu" $available_nodes]
 	set mps_per_gpu [list]
@@ -5085,7 +5225,7 @@ proc cuda_count { cuda_string } {
 ################################################################
 
 proc get_conf_path { } {
-	global scontrol re_word_str eol exit_code
+	global scontrol re_word_str eol
 
 	if [regexp {(.*)/slurm.conf} [get_config_param "SLURM_CONF"] {} config_dir] {
 		return $config_dir
@@ -5095,43 +5235,6 @@ proc get_conf_path { } {
 }
 
 
-################################################################
-#
-# NAME
-#	copy_conf - backs up the slurm.conf file
-#
-# SYNOPSIS
-#	copy_conf config_path cwd
-#
-# DESCRIPTION
-#	Copy the slurm.conf file to the a new file called
-#	slurm.conf.orig in the current working directory
-#
-# ARGUMENTS
-#	config_path
-#		The path to slurm.conf
-#	cwd
-#		The full path of the current working directory
-#
-################################################################
-
-proc copy_conf { config_path cwd } {
-	global bin_cp bin_rm exit_code
-
-	exec $bin_rm -fr $cwd/slurm.conf.orig
-	spawn $bin_cp -v $config_path/slurm.conf $cwd/slurm.conf.orig
-	expect {
-		timeout {
-			log_error "slurm.conf was not copied"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-}
-
-
 ################################################################
 #
 # NAME
@@ -5255,33 +5358,9 @@ proc restore_conf { file_name } {
 ################################################################
 
 proc have_nvml { } {
-	global bin_grep number exit_code config_h
-
-	set grep_fail 0
-	set have_nvml false
-	log_user 0
-	spawn $bin_grep "HAVE_NVML" $config_h
-	expect {
-		-re "HAVE_NVML 1" {
-			set have_nvml true
-			exp_continue
-		}
-		timeout {
-			set grep_fail 1
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
-
-	if {$grep_fail == 1} {
-		log_warn "Could not grep $config_h for HAVE_NVML"
-		set have_nvml false
-	}
+	global bin_grep number config_h
 
-	return $have_nvml
+	return [expr [run_command_status -none -nolog "$bin_grep \"HAVE_NVML 1\" $config_h"] == 0]
 }
 
 
@@ -5302,8 +5381,7 @@ proc delete_part { part_name } {
 	spawn $scontrol delete partition=$part_name
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -5326,33 +5404,9 @@ proc delete_part { part_name } {
 ################################################################
 
 proc have_lua { } {
-	global bin_grep number exit_code config_h
-
-	set grep_fail 0
-	set have_lua false
-	log_user 0
-	spawn $bin_grep "HAVE_LUA" $config_h
-	expect {
-		-re "HAVE_LUA 1" {
-			set have_lua true
-			exp_continue
-		}
-		timeout {
-			set grep_fail 1
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
-
-	if {$grep_fail == 1} {
-		log_error "Could not grep $config_h for HAVE_LUA"
-		set have_lua false
-	}
+	global bin_grep config_h
 
-	return $have_lua
+	return [expr [run_command_status -none -nolog "$bin_grep HAVE_LUA $config_h"] == 0]
 }
 
 
@@ -5408,19 +5462,19 @@ proc get_reservations { {resv_name ""} } {
 ################################################################
 #
 # NAME
-#	get_resvation_param - returns a specific parameter value for a specific reservation
+#	get_reservation_param - returns a specific parameter value for a specific reservation
 #
 # SYNOPSIS
-#	get_resvation_param resv_name parameter_name
+#	get_reservation_param resv_name parameter_name
 #
 # DESCRIPTION
-#	Returns a specific parameter value for a specified resvation if the
-#	parameter exists for the resvation, or MISSING if it does not exist.
-#	Specifying an invalid resvation name will result in a failure.
+#	Returns a specific parameter value for a specified reservation if the
+#	parameter exists for the reservation, or MISSING if it does not exist.
+#	Specifying an invalid reservation name will result in a failure.
 #
 ################################################################
 
-proc get_resvation_param { resv_name parameter_name } {
+proc get_reservation_param { resv_name parameter_name } {
 
 	set resvs_dict [get_reservations $resv_name]
 
@@ -5551,8 +5605,7 @@ proc create_part { part_name num_nodes_in } {
 			exp_continue
 		}
 		timeout {
-			log_err "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -5572,7 +5625,7 @@ proc create_part { part_name num_nodes_in } {
 	if { $num_nodes_in } {
 		set num_nodes $num_nodes_in
 	} else {
-		set num_nodes [available_nodes idle]
+		set num_nodes [llength [get_nodes_by_state]]
 	}
 
 	log_user 0
@@ -5623,8 +5676,7 @@ proc create_part { part_name num_nodes_in } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -5792,6 +5844,90 @@ proc get_nodes_by_request args {
 }
 
 
+################################################################
+#
+# NAME
+#	get_partitions - returns a dictionary of dictionaries of partition parameters
+#
+# SYNOPSIS
+#	get_partitions ?partition_name?
+#
+# DESCRIPTION
+#	Uses `scontrol show partitions` to query partition parameters,
+#	returning a dictionary of dictionaries with the partition names
+#	as keys of the first level dictionary and with the parameters as
+#	keys of the second level dictionary. Specifying an invalid partition
+#	name will result in a failure.
+#
+# RETURN VALUE
+#	If the optional partition_name argument is specified, the result will
+#	contain only the one patition. Otherwise, the results for all
+#	partitions will be returned.
+#
+################################################################
+
+proc get_partitions { {partition_name ""} } {
+	global scontrol
+
+	set command "$scontrol show partition -o"
+	if {$partition_name ne ""} {
+		append command " $partition_name"
+	}
+	set output [run_command_output -fail -nolog "$command"]
+
+	# Iterate over each partition parameter line
+	foreach line [split $output "\n"] {
+		if {$line eq ""} { continue }
+
+		# Peel off the partition parameters one at a time
+		# The first quantifier sets the greediness for the whole RE
+		while {[regexp {^ *?([^ =]+)=(.*)(?= +[^ =]+=| *$)} $line {} param_name param_value]} {
+			# Remove the consumed parameter from the line
+			set line [regsub {^ *?[^ =]+=.*(?= +[^ =]+=| *$)} $line {}]
+			# Add it to the temporary node dictionary
+			dict set part_dict $param_name $param_value
+		}
+
+		set part_name [dict get $part_dict "PartitionName"]
+
+		# Add the node dictionary to nodes dictionary
+		dict set parts_dict $part_name $part_dict
+
+		# Clear the node dictionary for use by the next node
+		set part_dict {}
+	}
+
+	return $parts_dict
+}
+
+
+################################################################
+#
+# NAME
+#	get_partition_param - returns a specific parameter value for a specific partition
+#
+# SYNOPSIS
+#	get_partition_param partitoin_name parameter_name
+#
+# DESCRIPTION
+#	Returns a specific parameter value for a specified partition if the
+#	parameter exists for the partition, or MISSING if it does not exist.
+#	Specifying an invalid partition name will result in a failure.
+#
+################################################################
+
+proc get_partition_param { partition_name parameter_name } {
+
+	set partitions_dict [get_partitions $partition_name]
+
+	if [dict exists $partitions_dict $partition_name $parameter_name] {
+		return [dict get $partitions_dict $partition_name $parameter_name]
+	} else {
+		return "MISSING"
+	}
+}
+
+
 ################################################################
 #
 # NAME
@@ -5905,7 +6041,10 @@ proc check_reason { job_id reason } {
 #	It accepts all the options of run_command.
 #
 # OPTIONS
-#	It accpets and passes all the options of/to run_command.
+#	It accepts and passes all the options of/to run_command and also:
+#	-env env
+#		Prepend $env to the actual sbatch command to set environment
+#		variables. For example "-env 'SLURM_NTASKS_PER_GPU=2'".
 #
 # ARGUMENTS
 #	job_args
@@ -5919,8 +6058,15 @@ proc check_reason { job_id reason } {
 proc submit_job args {
 	global sbatch
 
+	set env    ""
 	set job_id 0
 
+	set idx [lsearch $args -env]
+	if {$idx >= 0} {
+		set env  [lindex   $args [expr $idx+1]]
+		set args [lreplace $args $idx [expr $idx+1]]
+	}
+
 	if {[llength $args] < 1} {
 		fail "Wrong number of parameters, should be >=1"
 	}
@@ -5930,7 +6076,7 @@ proc submit_job args {
 		set run_options [lrange $args 0 [expr [llength $args] - 2 ]]
 	}
 
-	set output [run_command_output {*}$run_options "$sbatch $job_options"]
+	set output [run_command_output {*}$run_options "$env $sbatch $job_options"]
 	regexp {Submitted \S+ job (\d+)} $output - job_id
 
 	return $job_id
@@ -5943,16 +6089,21 @@ proc submit_job args {
 #	compile_against_libslurm - compiles a test program against either libslurm.so or libslurmfull.so
 #
 # SYNOPSIS
-#	compile_against_libslurm test_prog ?use_full? ?build_args?
+#	compile_against_libslurm ?options? test_prog ?build_args?
 #
 # DESCRIPTION
 #	Compile a test program against either libslurm.so or libslurmfull.so.
 #
+# OPTIONS
+#	-full
+#		use libslurmfull.so instead of libslurm.so
+#	-shared
+#		produces a shared library (adds the -shared compiler option
+#		and adds a .so suffix to the output file name)
+#
 # ARGUMENTS
 #	test_prog
 #		The name of the test program (and .c file)
-#	use_full
-#		If 1, use libslurmfull.so instead of libslurm.so. Defaults to 0.
 #	build_args
 #		Additional string to be appended to the build command.
 #		E.g. "-DUSING_VALGRIND -lm ${build_dir}/src/slurmctld/locks.o"
@@ -5960,8 +6111,30 @@ proc submit_job args {
 #
 ################################################################################
 
-proc compile_against_libslurm { test_prog {use_full 0} {build_args ""} } {
-	global slurm_dir bin_cc src_dir build_dir exit_code bin_chmod
+proc compile_against_libslurm args {
+	global slurm_dir bin_cc src_dir build_dir bin_chmod
+
+	set use_full   false
+	set shared     false
+	set build_args ""
+	while {[llength $args]} {
+		switch -glob -- [lindex $args 0] {
+			-full    {set use_full true; set args [lrange $args 1 end]}
+			-shared  {set shared true; set args [lrange $args 1 end]}
+			-*       {fail "Unknown option: [lindex $args 0]"}
+			default  break
+		}
+	}
+	set argument_count [llength $args]
+	if {$argument_count < 1} {
+		fail "Too few arguments ($argument_count): $args"
+	} else {
+		lassign $args test_prog
+	}
+	if {$argument_count == 2} { set build_args [lindex $args 1] }
+	if {$argument_count > 2} {
+		fail "Too many arguments ($argument_count): $args"
+	}
 
 	if {$use_full} {
 		set libfile "libslurmfull.so"
@@ -5983,22 +6156,32 @@ proc compile_against_libslurm { test_prog {use_full 0} {build_args ""} } {
 		set libfile "slurm"
 	}
 
-	set build_cmd "$bin_cc ${test_prog}.c -g -pthread -o $test_prog -I$src_dir -I$build_dir -I$slurm_dir/include -Wl,-rpath=$libline -L$libline -l$libfile -lresolv"
+	set build_cmd "$bin_cc ${test_prog}.c -g -pthread"
+
+	if {$shared} {
+		set out "${test_prog}.so"
+		append build_cmd " -fPIC -shared"
+	} else {
+		set out "${test_prog}"
+	}
+	append build_cmd " -o $out"
+
+	append build_cmd " -I$src_dir -I$build_dir -I$slurm_dir/include -Wl,-rpath=$libline -L$libline -l$libfile -lresolv"
 
 	# Add additional arguments to the build command
 	if {$build_args != ""} {
-		set build_cmd "$build_cmd $build_args"
+		append build_cmd " $build_args"
 	}
 
 	log_debug "Build command: $build_cmd"
 	catch {exec {*}$build_cmd} out_str out_dict
 	if {[dict get $out_dict -code]} {
 		log_error $out_str
-		set exit_code 1
-		return
+		return $::RETURN_ERROR
 	}
 
-	exec $bin_chmod 700 $test_prog
+	exec $bin_chmod 700 $out
+	return $::RETURN_SUCCESS
 }
 
 
@@ -6029,6 +6212,9 @@ proc compile_against_libslurm { test_prog {use_full 0} {build_args ""} } {
 #		A string providing additional diagnostic information that is
 #		only included in the log message on failure
 #
+# RETURN VALUE
+#	the boolean condition evaluated
+#
 # ENVIRONMENT
 #	testsuite_subtest_fatal
 #		Specifies whether first failing subtest aborts the test
@@ -6058,9 +6244,198 @@ proc subtest args {
 
 	if [uplevel 1 expr [format "{%s}" $condition]] {
 		subpass $description
+		return true
 	} else {
 		subfail {*}$options $description {*}$args
+		return false
+	}
+}
+
+
+################################################################
+#
+# NAME
+#	_is_testproc_included - returns if testproc_num was included or not excluded in argv
+#
+# SYNOPSIS
+#	_is_testproc_included testproc_num
+#
+# DESCRIPTION
+#	From command line the test runner can use -i and -e to include or
+#	exclude some test functions by their number. This function must be
+#	used to check if the test runner included or excluded the given
+#	testproc_num.
+#
+# RETURN VALUE
+#	true is testproc_num was included with -i or not excluded -e,
+#	false otherwise
+#
+################################################################
+
+proc _is_testproc_included {testproc_num} {
+	global _testproc_included _testproc_excluded
+
+	if {[llength $_testproc_included]} {
+		if {[lsearch $_testproc_included $testproc_num] >= 0} {
+			return true
+		}
+		return false
+	}
+
+	if {[llength $_testproc_excluded]} {
+		if {[lsearch $_testproc_excluded $testproc_num] >= 0} {
+			return false
+		}
+	}
+
+	return true
+}
+
+
+################################################################
+#
+# NAME
+#	skip_following_testprocs - the following testproc calls will be skipped
+#
+# SYNOPSIS
+#	skip_following_testprocs reason
+#
+# ARGUMENTS
+#	reason
+#		The string with the reason message to add on the skip message
+#		on each skipped testproc.
+#
+# DESCRIPTION
+#	This function disables normal execution of testproc calls.
+#	It is meant to be used when some testprocs cannot be run due config
+#	limitations, but still call testproc to register what testprocs
+#	are skipped for a given reason.
+#	Use run_following_testprocs to reenable the norma execution of testprocs.
+
+################################################################
+
+proc skip_following_testprocs {reason} {
+	global _testproc_skip_next _testproc_skip_reason
+
+	set _testproc_skip_next   true
+	set _testproc_skip_reason $reason
+}
+
+
+################################################################
+#
+# NAME
+#	run_following_testprocs - the following testproc call will be run (if not excluded from command line)
+#
+# SYNOPSIS
+#	run_following_testprocs
+#
+# DESCRIPTION
+#	This function reenables the normal execution of testproc calls.
+#	It is meant to be used when skip_following_testprocs was called to skip
+#	previous testproc calls, and we want to normally run the following ones.
+#	Note that it does NOT overwrite what -i and -e included are passed
+#	from command line.
+#
+################################################################
+
+proc run_following_testprocs {} {
+	global _testproc_skip_next _testproc_skip_reason
+
+	set _testproc_skip_next   false
+	set _testproc_skip_reason ""
+}
+
+
+################################################################
+#
+# NAME
+#	testproc - launcher to run or skip a testproc_call
+#
+# SYNOPSIS
+#	testproc testproc_call
+#
+# ARGUMENTS
+#	A testproc_call is any normal call to a proc with any arguments that
+#	could be done normally without the testproc launcher.
+#	For example, we could normally do:
+#
+#	test_my_feature $some_args $expected_out
+#
+#	Or use the launcher like:
+#
+#	testproc test_my_feature $some_args $expected_out
+#
+# DESCRIPTION
+#	Using the testproc launcher has the following main benefits:
+#	a) Handles the -i and -e terminal options to include or exclude some
+#	   testprocs numbers.
+#	b) Runs or skips based on the last call of testproc_{skip,run}_following.
+#	c) Creates extra sections in the status summary
+#	   (see testsuite_testproc_details).
+#
+# RETURN VALUE
+#	The rc of the testproc_call if it has been run, or $::RETURN_SUCCESS
+#	otherwise. Using it is not recommended, though.
+#
+################################################################
+
+proc testproc args {
+	global _testproc_pass_list _testproc_skip_list _testproc_fail_list
+	global _testproc_skip_next _testproc_skip_reason
+	global _testproc_messages
+	global _subtest_pass_count
+	global _subtest_skip_count
+	global _subtest_fail_count
+
+	# Save previous subtest counts and next subtest num
+	set prev_pass $_subtest_pass_count
+	set prev_skip $_subtest_skip_count
+	set prev_fail $_subtest_fail_count
+	set prev_subtest [expr $_subtest_pass_count + \
+	                       $_subtest_skip_count + \
+	                       $_subtest_fail_count + 1]
+
+	# Get the testproc number
+	set testproc_num [expr [llength $_testproc_pass_list] + \
+	                       [llength $_testproc_skip_list] + \
+	                       [llength $_testproc_fail_list] + 1]
+
+	# Run or skip the testproc
+	set rc $::RETURN_SUCCESS
+	set reason ""
+	if {![_is_testproc_included $testproc_num]} {
+		set reason "(Excluded from command line)"
+		subskip "Skipping testproc $testproc_num: {$args} $reason"
+	} else {
+		if {$_testproc_skip_next} {
+			set reason "($_testproc_skip_reason)"
+			subskip  "Skipping testproc $testproc_num: {$args} $reason"
+		} else {
+			log_info "Running testproc $testproc_num: $args"
+			set rc [{*}$args]
+		}
+	}
+
+	# Get current subtest counts
+	set curr_subtest [expr $_subtest_pass_count + \
+	                       $_subtest_skip_count + \
+	                       $_subtest_fail_count]
+
+	# Register the testproc as fail, skip or pass (based on subtests)
+	if {$_subtest_fail_count > $prev_fail} {
+		set reason "(Subtests: $prev_subtest to $curr_subtest)"
+		lappend  _testproc_fail_list $testproc_num
+		dict set _testproc_messages  $testproc_num [list failed "{$args} $reason"]
+	} elseif {$_subtest_skip_count > $prev_skip} {
+		lappend  _testproc_skip_list $testproc_num
+		dict set _testproc_messages  $testproc_num [list skipped "{$args} $reason"]
+	} else {
+		lappend  _testproc_pass_list $testproc_num
+		dict set _testproc_messages  $testproc_num [list passed "{$args}"]
 	}
+
+	return $rc
 }
 
 
@@ -6122,7 +6497,8 @@ proc _log_format { log_level message } {
 	global testsuite_colorize testsuite_log_format testsuite_time_format
 	global COLOR_NONE
 	global testsuite_color_fatal testsuite_color_error testsuite_color_warn
-	global testsuite_color_info testsuite_color_debug testsuite_color_trace
+	global testsuite_color_info testsuite_color_pass testsuite_color_command
+	global testsuite_color_debug testsuite_color_trace
 
 	set format_string $testsuite_log_format
 	set milliseconds_since_epoch [clock milliseconds]
@@ -6162,6 +6538,8 @@ proc _log_format { log_level message } {
 			error   { append output $testsuite_color_error }
 			warning { append output $testsuite_color_warn }
 			info    { append output $testsuite_color_info }
+			pass    { append output $testsuite_color_pass }
+			command { append output $testsuite_color_command }
 			debug   { append output $testsuite_color_debug }
 			trace   { append output $testsuite_color_trace }
 		}
@@ -6237,7 +6615,11 @@ proc _print_summary {status completed} {
 	global test_name testsuite_colorize COLOR_NONE
 	global testsuite_color_success testsuite_color_skipped
 	global testsuite_color_failure
-	global subtest_fail_count subtest_pass_count subtest_skip_count
+	global _subtest_fail_count _subtest_pass_count _subtest_skip_count
+	global _testproc_pass_list _testproc_skip_list _testproc_fail_list
+	global _incomplete_reason
+	global _subtest_messages _testproc_messages
+	global testsuite_subtest_details testsuite_testproc_details
 
 	if {$status == 0} {
 		set color $testsuite_color_success
@@ -6255,21 +6637,96 @@ proc _print_summary {status completed} {
 	}
 
 	append output [string repeat = 78]\n
-	append output [format "%s            : %s\n" $header  $test_name]
-	set subtest_count [expr $subtest_fail_count + $subtest_pass_count + $subtest_skip_count]
+
+	# Get subtest and testproc counts
+	set testproc_fail  [llength $_testproc_fail_list]
+	set testproc_skip  [llength $_testproc_skip_list]
+	set testproc_pass  [llength $_testproc_pass_list]
+	set testproc_count [expr $testproc_pass + \
+	                         $testproc_skip + \
+	                         $testproc_fail]
+	set subtest_count  [expr $_subtest_fail_count + \
+	                         $_subtest_pass_count + \
+	                         $_subtest_skip_count]
+
+	# Initial summary
+	append output [format "%s             : %s\n" $header  $test_name]
+	if {$testproc_count > 0} {
+		append output [format "  Testprocs failed  : %3d (%3d%%)%s\n" $testproc_fail [expr $testproc_fail * 100 / $testproc_count] \
+		                                                             [expr {$testproc_fail ? " List: [join $_testproc_fail_list ,]" : ""}]]
+		append output [format "  Testprocs skipped : %3d (%3d%%)%s\n" $testproc_skip [expr $testproc_skip * 100 / $testproc_count] \
+		                                                             [expr {$testproc_skip ? " List: [join $_testproc_skip_list ,]" : ""}]]
+		append output [format "  Testprocs passed  : %3d (%3d%%)\n"   $testproc_pass [expr $testproc_pass * 100 / $testproc_count]]
+		append output [format "  Testprocs total   : %3d %s\n"        $testproc_count [expr {$completed ? "COMPLETE" : "INCOMPLETE: $_incomplete_reason"}]]
+	}
 	if {$subtest_count > 0} {
-		append output [format "  Subtests failed  : %d (%3d%%)\n" $subtest_fail_count [expr $subtest_fail_count * 100 / $subtest_count]]
-		append output [format "  Subtests skipped : %d (%3d%%)\n" $subtest_skip_count [expr $subtest_skip_count * 100 / $subtest_count]]
-		append output [format "  Subtests passed  : %d (%3d%%)\n" $subtest_pass_count [expr $subtest_pass_count * 100 / $subtest_count]]
-		append output [format "  Subtests total   : %d (%s)\n" $subtest_count [expr {$completed ? "COMPLETED" : "INCOMPLETE"}]]
+		if {$testproc_count > 0} {
+			append output \n
+		}
+		append output [format "  Subtests failed   : %3d (%3d%%)\n" $_subtest_fail_count [expr $_subtest_fail_count * 100 / $subtest_count]]
+		append output [format "  Subtests skipped  : %3d (%3d%%)\n" $_subtest_skip_count [expr $_subtest_skip_count * 100 / $subtest_count]]
+		append output [format "  Subtests passed   : %3d (%3d%%)\n" $_subtest_pass_count [expr $_subtest_pass_count * 100 / $subtest_count]]
+		append output [format "  Subtests total    : %3d %s\n"      $subtest_count [expr {$completed ? "COMPLETE" : "INCOMPLETE: $_incomplete_reason"}]]
+	}
+	append output [string repeat = 78]\n
+
+	# Detailed information
+	if {$testsuite_subtest_details ne "none"} {
+		set show_details false
+		if {$testsuite_subtest_details eq "all" && $subtest_count > 0} {
+			set show_details true
+		} elseif {$testsuite_subtest_details eq "fail_skip" && $_subtest_skip_count > 0} {
+			set show_details true
+		} elseif {$_subtest_fail_count > 0} {
+			set show_details true
+		}
+
+		if {$show_details} {
+			append output [format "SUBTESTS DETAILS     : %s\n" $test_name]
+			dict for {id result_msg} $_subtest_messages {
+				set result [lindex $result_msg 0]
+				if {$testsuite_subtest_details eq "all"} {
+					append output [format "  %s\n" [lindex $result_msg 1]]
+				} elseif {$testsuite_subtest_details eq "fail_skip" && $result eq "skip"} {
+					append output [format "  %s\n" [lindex $result_msg 1]]
+				} elseif {$result eq "fail"} {
+					append output [format "  %s\n" [lindex $result_msg 1]]
+				}
+			}
+			append output [string repeat = 78]\n
+		}
+	}
+	if {$testsuite_testproc_details ne "none"} {
+		set show_details false
+		if {$testsuite_testproc_details eq "all" && $testproc_count > 0} {
+			set show_details true
+		} elseif {$testsuite_testproc_details eq "fail_skip" && $testproc_skip > 0} {
+			set show_details true
+		} elseif {$testproc_fail > 0} {
+			set show_details true
+		}
+
+		if {$show_details} {
+			append output [format "TESTPROCS DETAILS     : %s\n" $test_name]
+			dict for {num result_msg} $_testproc_messages {
+				set result [lindex $result_msg 0]
+				if {$testsuite_testproc_details eq "all"} {
+					append output [format "  Testproc %2d %-7s : %s\n" $num [lindex $result_msg 0] [lindex $result_msg 1]]
+				} elseif {$testsuite_testproc_details eq "fail_skip" && $result eq "skipped"} {
+					append output [format "  Testproc %2d %-7s : %s\n" $num [lindex $result_msg 0] [lindex $result_msg 1]]
+				} elseif {$result eq "failed"} {
+					append output [format "  Testproc %2d %-7s : %s\n" $num [lindex $result_msg 0] [lindex $result_msg 1]]
+				}
+			}
+			append output [string repeat = 78]\n
+		}
 	}
-	append output [string repeat = 78]
 
 	if ($testsuite_colorize) {
 		append output $COLOR_NONE
 	}
 
-	puts $output
+	puts -nonewline $output
 }
 
 
@@ -6315,7 +6772,7 @@ proc _get_test_name { } {
 #	test-defined cleanup procedure.
 #
 # NOTES
-#	This function should be called only from _test_init and _exit.
+#	This function should be called only from _test_init and _test_fini.
 #
 ################################################################
 
@@ -6355,6 +6812,19 @@ proc _test_cleanup {} {
 
 proc _test_init {} {
 	global test_dir test_id test_name testsuite_shared_dir
+	global _testproc_included _testproc_excluded argv
+
+	# parse argv to get and remove _testproc_included and _testproc_excluded params
+	set idx [expr {[info exists argv] ? [lsearch $argv -i] : -1}]
+	if {$idx >= 0} {
+		set _testproc_included [split [lindex $argv [expr $idx + 1]] ,]
+		set argv [lreplace $argv $idx [expr $idx + 1]]
+	}
+	set idx [expr {[info exists argv] ? [lsearch $argv -e] : -1}]
+	if {$idx >= 0} {
+		set _testproc_excluded [split [lindex $argv [expr $idx + 1]] ,]
+		set argv [lreplace $argv $idx [expr $idx + 1]]
+	}
 
 	# Set test name to name of originally invoked test script, e.g. test1.1
 	set test_name [_get_test_name]
@@ -6401,17 +6871,27 @@ proc _test_init {} {
 ################################################################
 
 proc _test_fini { status } {
-	global testsuite_cleanup_on_failure
-	global subtest_fail_count subtest_skip_count
+	global testsuite_cleanup_on_failure _test_fini_called
+	global _subtest_fail_count _subtest_skip_count
+
+	# Avoid potential infinite recursive calls.
+	# _test_fini should be called only once, but custom cleanup procs
+	# called from _test_cleanup can potentially call it (eg fail)
+	if {$_test_fini_called} {
+		log_debug "Recursive _test_fini call detected, most probably a fail on a cleanup function"
+		return
+	}
+	set _test_fini_called true
+
 
 	# Determine if test completed or was aborted
 	set completed [expr $status == 0 ? true : false]
 
 	# Override status with subtest status if available and necessary
 	if {$status < 1} {
-		if {$subtest_fail_count > 0} {
+		if {$_subtest_fail_count > 0} {
 			set status 1
-		} elseif {$subtest_skip_count > 0} {
+		} elseif {$_subtest_skip_count > 0} {
 			set status -1
 		}
 	}
@@ -6441,13 +6921,18 @@ rename exit __exit
 proc exit { {status 0} } {
 	global test_name
 
+	# To avoid failures when using "expect -c 'source globals'"
+	if {$test_name eq "globals"} {
+		pass
+	}
+
 	#
 	# Minor sanity check to detect if exit was explicitly called (not
 	# allowed) or automatically executed when the test ends
 	#
 	if {[info level] > 1} {
 		# exit was called from a function, and it shouldn't
-		log_error "Exit should not be directly called, use pass, skip or fail instead"
+		fail "Exit should not be directly called, use pass, skip or fail instead"
 	} else {
 		set frame_level 1
 		while { $frame_level <= [info frame] } {
@@ -6455,7 +6940,7 @@ proc exit { {status 0} } {
 				if { [file tail [dict get [info frame $frame_level] file]] eq $test_name } {
 					# exit was called explicitly from the
 					# test, and it shouldn't
-					log_error "Exit should not be directly called, use pass, skip or fail instead"
+					fail "Exit should not be directly called, use pass, skip or fail instead"
 				}
 				break
 			}
@@ -6463,9 +6948,13 @@ proc exit { {status 0} } {
 		}
 	}
 
+	if {$status != 0} {
+		fail "Some Expect/TCL exception happen"
+	}
+
 	# The exit was called implicitly when the test ends, allowed but
 	# _test_fini call enforced
-	_test_fini $status
+	pass
 }
 
 
diff --git a/testsuite/expect/globals_accounting b/testsuite/expect/globals_accounting
index 6bf8bf4549..61a4bb1106 100644
--- a/testsuite/expect/globals_accounting
+++ b/testsuite/expect/globals_accounting
@@ -1530,13 +1530,14 @@ proc remove_clus_res {name} {
 #	check_assoc_limit assoc type name assoc_val
 #
 # RETURN VALUE
-#	1 if association limits are correct, 0 otherwise
+#	true if association limits are correct, false otherwise
 #
 ################################################################
 
 proc check_assoc_limit { assoc type name assoc_val } {
-	global sacctmgr number exit_code
+	global sacctmgr number
 	array set assoc_arr $assoc_val
+	set return_value true
 	set format_str ""
 	set exp "$name"
 	set first 0
@@ -1570,9 +1571,8 @@ proc check_assoc_limit { assoc type name assoc_val } {
 				exp_continue
 			}
 			timeout {
-				log_error "sacctmgr is not responding"
 				slow_kill $my_pid
-				set exit_code 1
+				fail "sacctmgr is not responding"
 			}
 			eof {
 				wait
@@ -1581,7 +1581,7 @@ proc check_assoc_limit { assoc type name assoc_val } {
 		}
 		if {$check_val != 1} {
 			log_error "$name was not set correctly"
-			set exit_code 1
+			set return_value false
 		}
 
 	} elseif {$assoc == 2} {
@@ -1592,9 +1592,8 @@ proc check_assoc_limit { assoc type name assoc_val } {
 				exp_continue
 			}
 			timeout {
-				log_error "sacctmgr is not responding"
 				slow_kill $my_pid
-				set exit_code 1
+				fail "sacctmgr is not responding"
 			}
 			eof {
 				wait
@@ -1603,7 +1602,7 @@ proc check_assoc_limit { assoc type name assoc_val } {
 		}
 		if {$check_val != 1} {
 			log_error "$name was not set correctly $check_val"
-			set exit_code 1
+			set return_value false
 		}
 	} elseif {$assoc == 3} {
 		set my_pid [eval spawn $sacctmgr list assoc $type=$name -p -n format=user,$format_str]
@@ -1613,9 +1612,8 @@ proc check_assoc_limit { assoc type name assoc_val } {
 				exp_continue
 			}
 			timeout {
-				log_error "sacctmgr is not responding"
 				slow_kill $my_pid
-				set exit_code 1
+				fail "sacctmgr is not responding"
 			}
 			eof {
 				wait
@@ -1623,10 +1621,11 @@ proc check_assoc_limit { assoc type name assoc_val } {
 		}
 		if {$check_val != 1} {
 			log_error "$name was not set correctly $check_val"
-			set exit_code 1
+			set return_value false
 		}
 	}
 	log_user 1
+	return $return_value
 }
 
 
@@ -1644,8 +1643,9 @@ proc check_assoc_limit { assoc type name assoc_val } {
 ################################################################
 
 proc reset_account_usage { cluster acct } {
-	global sacctmgr exit_code
+	global sacctmgr
 
+	set exit_code $::RETURN_SUCCESS
 	if { ![string compare $cluster ""] } {
 		set cluster [get_config_param "ClusterName"]
 	}
@@ -1666,6 +1666,7 @@ proc reset_account_usage { cluster acct } {
 			wait
 		}
 	}
+	return $exit_code
 }
 
 
@@ -1683,8 +1684,9 @@ proc reset_account_usage { cluster acct } {
 ################################################################
 
 proc reset_qos_usage { cluster qos } {
-	global sacctmgr exit_code
+	global sacctmgr
 
+	set exit_code $::RETURN_SUCCESS
 	if { ![string compare $cluster ""] } {
 		set cluster [get_config_param "ClusterName"]
 	}
@@ -1705,6 +1707,7 @@ proc reset_qos_usage { cluster qos } {
 			wait
 		}
 	}
+	return $exit_code
 }
 
 
@@ -1773,7 +1776,7 @@ proc check_qos_limits { name qos_req } {
 
 	set command "format="
 	set values ""
-	set exit_code 0
+	set exit_code $::RETURN_SUCCESS
 	array set qos_limits $qos_req
 
 	if { ![string length $name] } {
@@ -1805,7 +1808,7 @@ proc check_qos_limits { name qos_req } {
 		timeout {
 			log_error "sacctmgr is not responding"
 			slow_kill $my_pid
-			set exit_code 1
+			set exit_code $::RETURN_TIMEOUT
 		}
 		eof {
 			wait
@@ -1815,7 +1818,7 @@ proc check_qos_limits { name qos_req } {
 
 	if {$match == 0} {
 		log_error "Limits do not match"
-		set exit_code 1
+		set exit_code $::RETURN_ERROR
 	}
 
 	return $exit_code
@@ -1840,12 +1843,12 @@ proc check_resource_limits { name res_limits } {
 
 	set command "format=name"
 	set values "$name"
-	set exit_code 0
+	set exit_code $::RETURN_SUCCESS
 	array set res_req $res_limits
 
 	if { ![string length $name] } {
 		log_error "We need a name to check"
-		return 1
+		return $::RETURN_ERROR
 	}
 
 	foreach option [array names res_req] {
@@ -1867,7 +1870,7 @@ proc check_resource_limits { name res_limits } {
 		timeout {
 			log_error "sacctmgr is not responding"
 			slow_kill $my_pid
-			set exit_code 1
+			set exit_code $::RETURN_TIMEOUT
 		}
 		eof {
 			wait
@@ -1877,11 +1880,10 @@ proc check_resource_limits { name res_limits } {
 	log_user 1
 
 	if {$match == 0} {
-		set exit_code 1
+		set exit_code $::RETURN_ERROR
 	}
 
 	return $exit_code
-
 }
 
 
@@ -1960,8 +1962,6 @@ proc mod_resource {name mod_limits} {
 proc get_assoc_id {user acct cluster} {
 	global sacctmgr number
 
-	set exit_code 0
-
 	if { ![string length $user] } {
 		log_error "We need a user to check"
 		return -1
@@ -1994,7 +1994,6 @@ proc get_assoc_id {user acct cluster} {
 		timeout {
 			log_error "sacctmgr is not responding"
 			slow_kill $my_pid
-			set exit_code 1
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/globals_private b/testsuite/expect/globals_private
deleted file mode 100644
index c6e7888543..0000000000
--- a/testsuite/expect/globals_private
+++ /dev/null
@@ -1,179 +0,0 @@
-#!/usr/bin/env expect
-############################################################################
-# Purpose: Functions and variables to eb used from the main globals files,
-#          not directly from tests.
-############################################################################
-# Copyright (C) 2016 SchedMD LLC.
-# Written by Albert Gil <albert.gil@schedmd.com>
-
-# This file is part of SLURM, a resource management program.
-# For details, see <https://slurm.schedmd.com/>.
-# Please also read the supplied file: DISCLAIMER.
-#
-# Slurm is free software; you can redistribute it and/or modify it under
-# the terms of the GNU General Public License as published by the Free
-# Software Foundation; either version 2 of the License, or (at your option)
-# any later version.
-#
-# Slurm is distributed in the hope that it will be useful, but WITHOUT ANY
-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
-# details.
-#
-# You should have received a copy of the GNU General Public License along
-# with SLURM; if not, write to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
-############################################################################
-
-
-################################################################
-#
-# NAME
-#	_wait_for_single_job - waits for a job to reach the desired state
-#
-# SYNOPSIS
-#	_wait_for_single_job ?options? job_id desired_state
-#
-# DESCRIPTION
-#	Wait for a previously submitted Slurm job to reach the desired state.
-#
-# OPTIONS
-#	-timeout <integer_number>
-#		time in seconds to wait for the job to be in the desired state
-#		before timing out (default is 360)
-#	-pollinterval <integer_number>
-#		time in seconds between each job state check (default is 1)
-#
-# ARGUMENTS
-#	job_id
-#		The Slurm job id of a job we want to wait for.
-#	desired_state
-#		The state you want the job to attain before
-#		returning.  Currently supports:
-#			DONE any terminated state
-#			PENDING job is pending
-#			RUNNING job is running
-#			SPECIAL_EXIT
-#			SUSPENDED job is suspended
-#
-# RETURN VALUE
-#	RETURN_SUCCESS, or non-zero on error.
-#
-# NOTE: We sleep for two seconds before replying that a job is
-# done to give time for I/O completion (stdout/stderr files)
-#
-################################################################
-
-proc _wait_for_single_job args {
-	global scontrol
-
-	set timeout       360
-	set poll_interval 1
-	while {[llength $args]} {
-		switch -glob -- [lindex $args 0] {
-			-time*  {set args [lassign $args - timeout]}
-			-poll*  {set args [lassign $args - poll_interval]}
-			-*      {fail "Unknown option: [lindex $args 0]"}
-			default break
-		}
-	}
-	set argument_count [llength $args]
-	if {$argument_count != 2} {
-		fail "Invalid number of arguments ($argument_count): $args"
-	} else {
-		lassign $args job_id desired_state
-	}
-
-	# First verify that desired_state is supported
-	switch $desired_state {
-		"DONE" {}
-		"PENDING" {}
-		"RUNNING" {}
-		"SPECIAL_EXIT" {}
-		"SUSPENDED" {}
-		default {
-			log_warn "Invalid desired state: $desired_state"
-			return $::RETURN_ERROR
-		}
-	}
-
-	if {$job_id == 0} {
-		log_warn "Invalid job ID: $job_id"
-		return $::RETURN_ERROR
-	}
-
-	set my_delay    0
-	while 1 {
-		set fd [open "|$scontrol -o show job $job_id"]
-		gets $fd line
-		catch {close $fd}
-		if {[regexp {JobState\s*=\s*(\w+)} $line foo state] != 1} {
-			set state "NOT_FOUND"
-		}
-
-		switch $state {
-			"NOT_FOUND" -
-			"BOOT_FAIL" -
-			"CANCELLED" -
-			"COMPLETED" -
-			"DEADLINE" -
-			"FAILED" -
-			"NODE_FAIL" -
-			"OUT_OF_MEMORY" -
-			"PREEMPTED" -
-			"TIMEOUT" {
-				if {[string compare $desired_state "DONE"] == 0} {
-					log_debug "Job $job_id is DONE ($state)"
-					sleep 2
-					return $::RETURN_SUCCESS
-				}
-				if {[string compare $desired_state "RUNNING"] == 0} {
-					log_debug "Job $job_id is $state, but we wanted RUNNING"
-				}
-				if {[string compare $desired_state "SUSPENDED"] == 0} {
-					log_debug "Job $job_id is $state, but we wanted SUSPENDED"
-				}
-				return $::RETURN_ERROR
-			}
-			"PENDING" {
-				if {[string compare $desired_state "PENDING"] == 0} {
-					log_debug "Job $job_id is PENDING"
-					return $::RETURN_SUCCESS
-				}
-				log_debug "Job $job_id is in state $state, desire $desired_state"
-			}
-			"RUNNING" {
-				if {[string compare $desired_state "RUNNING"] == 0} {
-					log_debug "Job $job_id is RUNNING"
-					return $::RETURN_SUCCESS
-				}
-				log_debug "Job $job_id is in state $state, desire $desired_state"
-			}
-			"SPECIAL_EXIT" {
-				if {[string compare $desired_state "SPECIAL_EXIT"] == 0} {
-					log_debug "Job $job_id is SPECIAL_EXIT"
-					return $::RETURN_SUCCESS
-				}
-				log_debug "Job $job_id is in state $state, desire $desired_state"
-			}
-			"SUSPENDED" {
-				if {[string compare $desired_state "SUSPENDED"] == 0} {
-					log_debug "Job $job_id is SUSPENDED"
-					return $::RETURN_SUCCESS
-				}
-				log_debug "Job $job_id is in state $state, desire $desired_state"
-			}
-			default {
-				log_debug "Job $job_id is in state $state, desire $desired_state"
-			}
-		}
-
-		if { $my_delay > $timeout } {
-			log_warn "Timeout waiting for job state $desired_state"
-			return $::RETURN_TIMEOUT
-		}
-
-		exec sleep $poll_interval
-		set my_delay [expr $my_delay + $poll_interval]
-	}
-}
diff --git a/testsuite/expect/inc12.3.1 b/testsuite/expect/inc12.3.1
index a4a915c9d1..e38c702ce4 100644
--- a/testsuite/expect/inc12.3.1
+++ b/testsuite/expect/inc12.3.1
@@ -26,60 +26,17 @@
 source ./globals
 source ./globals_accounting
 
+# Added verbose flag to sacct queries to troubleshoot bug 9681
 proc inc12_3_1 {job_id_1 job_id_2 job_name_1 job_name_2 test_acct} {
-
 	global sacct
-	global exit_code
-
-	set idmatch 0
-	log_info "Search for job ID $job_id_1 having name $job_name_1 (Within: inc12.3.1)"
-	log_debug "Job id1 number: $job_id_1"
-	spawn $sacct -A '$test_acct' --name=$job_name_1 -X -p -o jobid
-	expect {
-		-re "$job_id_1" {
-			incr idmatch
-			exp_continue
-		}
-		-re "$job_id_2" {
-			incr idmatch
-			exp_continue
-		}
-		timeout {
-			log_error "sacct not responding (Within: inc12.3.1)"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
 
-	}
-	if {$idmatch != 1} {
-		log_error "sacct could not match job id to job name ($idmatch != 1, Within: inc12.3.1)"
-		set exit_code 1
-	}
+	log_info "Search for job ID $job_id_1 having name $job_name_1"
+	set output [run_command_output -fail "$sacct -A '$test_acct' --name=$job_name_1 -X -P -o jobid -v -v"]
+	subtest [regexp -line "^$job_id_1$" $output] "sacct should show job $job_id_1 as having name $job_name_1"
+	subtest {![regexp -line "^$job_id_2$" $output]} "sacct should not show job $job_id_2 as having name $job_name_1"
 
-	set idmatch 0
-	log_info "Search for job ID $job_id_2 having name $job_name_2 (Within: inc12.3.1)"
-	spawn $sacct -A '$test_acct' --name=$job_name_2 -X -p -o jobid
-	expect {
-		-re "$job_id_1" {
-			incr idmatch
-			exp_continue
-		}
-		-re "$job_id_2" {
-			incr idmatch
-			exp_continue
-		}
-		timeout {
-			log_error "sacct not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	if {$idmatch != 1} {
-		log_error "sacct could not match job id to job name ($idmatch != 1, Within: 12.3.1)"
-		set exit_code 1
-	}
+	log_info "Search for job ID $job_id_2 having name $job_name_2"
+	set output [run_command_output -fail "$sacct -A '$test_acct' --name=$job_name_2 -X -P -o jobid -v -v"]
+	subtest {![regexp -line "^$job_id_1$" $output]} "sacct should not show job $job_id_1 as having name $job_name_2"
+	subtest [regexp -line "^$job_id_2$" $output] "sacct should show job $job_id_2 as having name $job_name_2"
 }
diff --git a/testsuite/expect/inc12.3.2 b/testsuite/expect/inc12.3.2
index 119ed947ca..6a2d372e41 100755
--- a/testsuite/expect/inc12.3.2
+++ b/testsuite/expect/inc12.3.2
@@ -27,116 +27,21 @@
 source ./globals
 source ./globals_accounting
 
-proc inc12_3_2 {job_id_1 job_id_2 job_id_3 job_name_1 job_name_2 test_acct job_1_node_0 job_1_node_2 job_2_node_0 job_2_node_1} {
+proc inc12_3_2 {job_id_1 job_id_2 job_name_1 job_name_2 test_acct node_1 node_2 node_3} {
+	global sacct
 
-	global re_word_str sacct
-	global exit_code
+	log_info "Search for job $job_id_1 on node $node_1"
+	set output [run_command_output -fail "$sacct -A '$test_acct' -N$node_1 -X -P -o jobid,jobname"]
+	subtest [regexp -line "^$job_id_1\\|" $output] "sacct should show job $job_id_1 as having run on node $node_1"
+	subtest {![regexp -line "^$job_id_2\\|" $output]} "sacct should not show job $job_id_2 as having run on node $node_1"
 
-	log_info "Search for jobs $job_id_1 and $job_id_3 on node: $job_1_node_0 (Within: inc12.3.2)"
-	set job_1_match 0
-	set job_2_match 0
-	spawn $sacct -A '$test_acct' -N$job_1_node_0 -X -p -o jobid,jobname
-	expect {
-		-re "$job_id_1" {
-			incr job_1_match
-			exp_continue
-		}
-		-re "$job_id_2" {
-			incr job_2_match
-			exp_continue
-		}
-		timeout {
-			log_error "sacct did not respond (Within: inc12.3.2)"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	if {$job_1_match != 1} {
-		log_error "sacct was unable to find the job $job_id_1 on node $job_1_node_0 ($job_1_match != 1) (Within: inc12.3.2)"
-		set exit_code 1
-	}
-	if {$job_2_match != 0} {
-		log_error "sacct was found job $job_id_2 on node $job_1_node_0 ($job_2_match != 0) (Within: inc12.3.2)"
-		set exit_code 1
-	}
+	log_info "Search for jobs $job_id_1 and $job_id_2 on node $node_2"
+	set output [run_command_output -fail "$sacct -A '$test_acct' -N$node_2 -X -P -o jobid,jobname"]
+	subtest [regexp -line "^$job_id_1\\|" $output] "sacct should show job $job_id_1 as having run on node $node_2"
+	subtest [regexp -line "^$job_id_2\\|" $output] "sacct should show job $job_id_2 as having run on node $node_2"
 
-	log_info "Search for jobs $job_id_1 and $job_id_2 on node: $job_1_node_2 (Within: inc12.3.2))"
-	set job_1_match 0
-	set job_2_match 0
-	spawn $sacct -A '$test_acct' -N$job_1_node_2 -X -p -o jobid,jobname
-	expect {
-		-re "$job_id_1" {
-			incr job_1_match
-			exp_continue
-		}
-		-re "$job_id_2" {
-			incr job_2_match
-			exp_continue
-		}
-		timeout {
-			log_error "sacct did not respond (Within: inc12.3.2)"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	if {$job_1_match != 1} {
-		log_error "sacct was unable to find the job $job_id_1 on node $job_1_node_2 ($job_1_match != 1) (Within: inc12.3.2)"
-		set exit_code 1
-	}
-
-	log_info "Search for jobs $job_id_1 and $job_id_2 on node: $job_2_node_0 (Within: inc12.3.2)"
-	set job_1_match 0
-	set job_2_match 0
-	spawn $sacct -A '$test_acct' -N$job_2_node_0 -X -p -o jobid,jobname
-	expect {
-		-re "$job_id_1" {
-			incr job_1_match
-		 	exp_continue
-		}
-		-re "$job_id_2" {
-			incr job_2_match
-			exp_continue
-		}
-		timeout {
-			log_error "sacct did not respond (Within: inc12.3.2)"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	if {$job_2_match != 1} {
-		log_error "sacct was unable to find the job $job_id_2 on node $job_2_node_0 ($job_2_match != 1, Within: inc12.3.2)"
-		set exit_code 1
-	}
-
-	log_info "Search for jobs $job_id_2 and $job_id_3 on node: $job_2_node_1 (Within: inc12.3.2)"
-	set job_1_match 0
-	set job_2_match 0
-	spawn $sacct -A '$test_acct' -N$job_2_node_1 -X -p -o jobid,jobname
-	expect {
-		-re "$job_id_1" {
-			incr job_1_match
-		 	exp_continue
-		}
-		-re "$job_id_2" {
-			incr job_2_match
-			exp_continue
-		}
-		timeout {
-			log_error "sacct did not respond (Within: inc12.3.2)"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	if {$job_2_match != 1} {
-		log_error "sacct was unable to find the job $job_id_2 on node $job_2_node_1 ($job_2_match != 1, Within: inc12.3.2)"
-		set exit_code 1
-	}
+	log_info "Search for job $job_id_2 on node $node_3"
+	set output [run_command_output -fail "$sacct -A '$test_acct' -N$node_3 -X -P -o jobid,jobname"]
+	subtest {![regexp -line "$job_id_1\\|" $output]} "sacct should not show job $job_id_1 as having run on node $node_3"
+	subtest [regexp -line "$job_id_2\\|" $output] "sacct should show job $job_id_2 as having run on node $node_3"
 }
diff --git a/testsuite/expect/inc21.21_tests b/testsuite/expect/inc21.21_tests
index 0625f6f8ad..d0ca1c70ac 100644
--- a/testsuite/expect/inc21.21_tests
+++ b/testsuite/expect/inc21.21_tests
@@ -185,27 +185,15 @@ sleep 10"
 	# since it will be past the association limit
 	#
 	set matches 0
+	set time 1
 	for {set inx 0} {$inx <= $val} {incr inx} {
-		spawn $sbatch [lindex $limit 0]1 --account=$ta \
-		    --output=/dev/null --error=/dev/null \
-		    -t1 $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set job_id $expect_out(1,string)
-				incr matches
-				exp_continue
-			}
-			timeout {
-				fail "sbatch not responding [test_info $test_type \"inc21_21_grp_test\"]"
-			}
-			eof {
-				wait
-			}
+		if { $inx == $val } {
+			# the n+1'th job gets a longer time limit to avoid
+			# having it prematurely start after _decay_thread() runs
+			# and decays the values of the other running jobs
+			set time $val
 		}
-	}
-
-	if {$matches != [expr $val + 1]} {
-		fail "Only $matches out of [expr $val + 1] jobs were submitted"
+		set job_id [submit_job -fail "[lindex $limit 0]1 --account=$ta --output=/dev/null --error=/dev/null -t$time $file_in"]
 	}
 
 	#
@@ -282,10 +270,11 @@ proc inc21_21_submit_test { limit } {
 	    [lindex $acct_mod_assoc_vals($limit) 0]
 	set acct_mod_assoc_test_vals($limit_sub) \
 	    [lindex $acct_mod_assoc_vals($limit) 1]
-	set exit_code  [mod_acct $ta [array get acct_mod_desc] \
+	if [mod_acct $ta [array get acct_mod_desc] \
 				 [array get acct_mod_assoc_test_vals] \
-				 [array get acct_mod_acct_vals]]
-	fail_on_error "Unable to modify account $ta"
+				 [array get acct_mod_acct_vals]] {
+		fail "Unable to modify account $ta"
+	}
 
 	make_bash_script $file_in "
 	$bin_sleep 10
@@ -298,27 +287,7 @@ proc inc21_21_submit_test { limit } {
 	# Submit jobs to test the limit set in the association
 	for {set inx 0} {$inx < $acct_mod_assoc_test_vals($limit_sub)} \
 	    {incr inx} {
-		    set job_id($inx) 0
-		    set mypid [spawn $sbatch -N1 -n1 --account=$ta \
-				   --output=/dev/null \
-				   --error=/dev/null -t5 $file_in]
-		    expect {
-			    -re "Submitted batch job ($number)" {
-				    set job_id($inx) $expect_out(1,string)
-				    exp_continue
-			    }
-			    -re "Unable to contact" {
-				    fail "Slurm appears to be down [test_info $limit \"inc21_21_submit_test\"]"
-			    }
-			    timeout {
-				    slow_kill $mypid
-				    fail "sbatch not responding [test_info $limit \"inc21_21_submit_test\"]"
-			    }
-			    eof {
-				    wait
-			    }
-		    }
-
+		    set job_id($inx) [submit_job -fail "-N1 -n1 --account=$ta --output=/dev/null --error=/dev/null -t5 $file_in"]
 		    if { !$job_id($inx) } {
 			    fail "sbatch didn't return jobid [test_info $limit \"inc21_21_submit_test\"]"
 		    }
@@ -400,27 +369,7 @@ proc inc21_21_submit_test { limit } {
 	# Submit jobs to test the limit set in the association
 	for {set inx 0} {$inx < $acct_mod_assoc_test_vals($limit_sub)} \
 	    {incr inx} {
-		    set job_id($inx) 0
-		    set mypid [spawn $sbatch -N1 -a0 --account=$ta \
-				   --output=/dev/null \
-				   --error=/dev/null -t5 $file_in]
-		    expect {
-			    -re "Submitted batch job ($number)" {
-				    set job_id($inx) $expect_out(1,string)
-				    exp_continue
-			    }
-			    -re "Unable to contact" {
-				    fail "Slurm appears to be down [test_info $limit \"inc21_21_submit_test\"]"
-			    }
-			    timeout {
-				    slow_kill $mypid
-				    fail "sbatch not responding [test_info $limit \"inc21_21_submit_test\"]"
-			    }
-			    eof {
-				    wait
-			    }
-		    }
-
+		    set job_id($inx) [submit_job -fail "-N1 -a0 --account=$ta --output=/dev/null --error=/dev/null -t5 $file_in"]
 		    if { !$job_id($inx) } {
 			    fail "sbatch didn't return jobid [test_info $limit \"inc21_21_submit_test\"]"
 		    }
diff --git a/testsuite/expect/inc21.30.12 b/testsuite/expect/inc21.30.12
index 40518c2faf..3f84e658fa 100644
--- a/testsuite/expect/inc21.30.12
+++ b/testsuite/expect/inc21.30.12
@@ -36,7 +36,7 @@ proc inc21_30_12 { } {
 
 	# Since wall is a decayed variable lets reset it to make sure the test
 	# gets exactly what we would expect.
-	reset_qos_usage "" $qostest
+	incr exit_code [reset_qos_usage "" $qostest]
 
 	spawn $salloc --account=$acct --qos=$qostest -N2 -t1 $srun $bin_sleep [expr $grpwall_num * 60 + 1]
 	expect {
@@ -96,7 +96,7 @@ proc inc21_30_12 { } {
 	}
 
 	# Reset the QoS usage
-	reset_qos_usage "" $qostest
+	incr exit_code [reset_qos_usage "" $qostest]
 
 	# Cancel job
 	if {$exit_code} {
diff --git a/testsuite/expect/inc21.30.9 b/testsuite/expect/inc21.30.9
index eb76f94dd0..bea7d1fe83 100644
--- a/testsuite/expect/inc21.30.9
+++ b/testsuite/expect/inc21.30.9
@@ -44,7 +44,7 @@ proc inc21_30_9 { wait_reason } {
 	set timelimit [expr $grpcpumin_num / $nthreads]
 	# Since GrpCpuMins is a decayed variable lets reset it to make sure
 	# the test gets exactly what we would expect.
-	reset_qos_usage "" $qostest
+	incr exit_code [reset_qos_usage "" $qostest]
 
 	spawn $salloc --account=$acct -w$test_node --qos=$qostest -n$nthreads -t$timelimit $srun $bin_sleep 1
 	expect {
@@ -71,7 +71,7 @@ proc inc21_30_9 { wait_reason } {
 	}
 	cancel_job $job_id1
 
-	reset_qos_usage "" $qostest
+	incr exit_code [reset_qos_usage "" $qostest]
 
 	spawn $salloc --account=$acct -w$test_node --qos=$qostest -n$nthreads -t[expr $timelimit + 1] $srun $bin_sleep 1
 	expect {
diff --git a/testsuite/expect/inc21.34.1 b/testsuite/expect/inc21.34.1
index 7e433a3904..7178e8e962 100644
--- a/testsuite/expect/inc21.34.1
+++ b/testsuite/expect/inc21.34.1
@@ -44,7 +44,7 @@ proc inc21_34_1 { qostest wait_reason } {
 	set timelimit [expr $grpcpumin_num / $nthreads]
 	# Since GrpCpuMins is a decayed variable lets reset it to make sure
 	# the test gets exactly what we would expect.
-	reset_qos_usage "" $qostest
+	incr exit_code [reset_qos_usage "" $qostest]
 
 	spawn $salloc --account=$acct -w$test_node -n$nthreads -t$timelimit $srun $bin_sleep 1
 	expect {
@@ -71,7 +71,7 @@ proc inc21_34_1 { qostest wait_reason } {
 	}
 	cancel_job $job_id1
 
-	reset_qos_usage "" $qostest
+	incr exit_code [reset_qos_usage "" $qostest]
 
 	spawn $salloc --account=$acct -w$test_node -n$nthreads -t[expr $timelimit + 1] $srun $bin_sleep 1
 	expect {
diff --git a/testsuite/expect/inc21.34.2 b/testsuite/expect/inc21.34.2
index 11dcf141ea..2ec9ceb22a 100644
--- a/testsuite/expect/inc21.34.2
+++ b/testsuite/expect/inc21.34.2
@@ -36,7 +36,7 @@ proc inc21_34_2 { qostest } {
 
 	# Since wall is a decayed variable, reset it to make sure the test
 	# gets exactly what we would expect.
-	reset_qos_usage "" $qostest
+	incr exit_code [reset_qos_usage "" $qostest]
 
 	spawn $salloc --account=$acct -N2 -t1 $srun $bin_sleep [expr $grpwall_num * 60 + 1]
 	expect {
@@ -96,7 +96,7 @@ proc inc21_34_2 { qostest } {
 	}
 
 	# Reset QoS usage
-	reset_qos_usage "" $qostest
+	incr exit_code [reset_qos_usage "" $qostest]
 
 	# Cancel job
 	if {$exit_code} {
diff --git a/testsuite/expect/inc3.11.10 b/testsuite/expect/inc3.11.10
index da177af097..7eec2f089e 100644
--- a/testsuite/expect/inc3.11.10
+++ b/testsuite/expect/inc3.11.10
@@ -24,7 +24,7 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
 ############################################################################
 proc inc3_11_10 {} {
-	global user_name exit_code
+	global user_name
 
 	set res_name "resv3.11.10"
 	set res_name_test "resv3.11.10.0"
@@ -34,7 +34,7 @@ proc inc3_11_10 {} {
 	#
 	log_info "+++++ STARTING TEST 10 (Within: inc3.11.10) +++++"
 	# Make the reservation
-	set ret_code [create_res $res_name "StartTime=now+60minutes Duration=60 Nodes=[available_nodes_hostnames "" true] flags=DAILY user=$user_name"]
+	set ret_code [create_res $res_name "StartTime=now+60minutes Duration=60 Nodes=[list2hostlist [get_nodes_by_state idle,power_down,powering_down]] flags=DAILY user=$user_name"]
 	if {$ret_code != 0} {
 		fail "Unable to create a valid reservation (Within: inc3.11.10)"
 	}
diff --git a/testsuite/expect/inc3.11.11 b/testsuite/expect/inc3.11.11
index f725c74f16..3771cc9625 100644
--- a/testsuite/expect/inc3.11.11
+++ b/testsuite/expect/inc3.11.11
@@ -113,8 +113,8 @@ proc inc3_11_11 {} {
 	log_info "+++++ STARTING TEST 11 (Within: inc3.11.11) +++++"
 
 
-	set part_nodes [available_nodes_hostnames $def_partition true]
-	set one_node [get_idle_node_in_part $def_partition]
+	set part_nodes [get_partition_param $def_partition "Nodes"]
+	set one_node [lindex [get_nodes_by_state] 0]
 
 	inc3_11_11_resv_create $res_name partition=$def_partition
 	inc3_11_11_resv_test $res_name $def_partition "SPEC_NODES,PART_NODES" $part_nodes
diff --git a/testsuite/expect/inc3.11.5 b/testsuite/expect/inc3.11.5
index 33775fcb83..be3d72be5b 100644
--- a/testsuite/expect/inc3.11.5
+++ b/testsuite/expect/inc3.11.5
@@ -30,7 +30,7 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
 ############################################################################
 proc inc3_11_5 {} {
-	global user_name exit_code
+	global user_name
 
 	set res_name "resv3.11.5"
 	set res_name_test "resv3.11.5.0"
@@ -40,7 +40,7 @@ proc inc3_11_5 {} {
 	#
 	log_info "+++++ STARTING TEST 5 (Within: inc3.11.5) +++++"
 	# Make the reservation
-	set ret_code [create_res $res_name "StartTime=now+60minutes Duration=60 Nodes=[available_nodes_hostnames "" true] user=$user_name"]
+	set ret_code [create_res $res_name "StartTime=now+60minutes Duration=60 Nodes=[list2hostlist [get_nodes_by_state idle,power_down,powering_down]] user=$user_name"]
 	if {$ret_code != 0} {
 		fail "Unable to create a valid reservation (Within: inc3.11.5)"
 	}
diff --git a/testsuite/expect/inc3.11.6 b/testsuite/expect/inc3.11.6
index 131174a79b..24eafaafb7 100644
--- a/testsuite/expect/inc3.11.6
+++ b/testsuite/expect/inc3.11.6
@@ -30,7 +30,7 @@
 ############################################################################
 
 proc inc3_11_6 {} {
-	global user_name exit_code file_in bin_rm
+	global user_name file_in bin_rm
 
 	set res_name "resv3.11.6"
 	set res_name_test "resv3.11.6.0"
@@ -40,13 +40,13 @@ proc inc3_11_6 {} {
 	#
 	log_info "+++++ STARTING TEST 6 (Within: inc3.11.6) +++++"
 	# Make the reservation
-	set ret_code [create_res $res_name "StartTime=now+60minutes Duration=60 Nodes=[available_nodes_hostnames ""] user=$user_name"]
+	set ret_code [create_res $res_name "StartTime=now+60minutes Duration=60 Nodes=[list2hostlist [get_nodes_by_state]] user=$user_name"]
 	if {$ret_code != 0} {
 		fail "Unable to create a valid reservation (Within: inc3.11.6)"
 	}
 
 	# Test for time reservation conflict (front overlap)
-	set ret_code [create_res $res_name_test "StartTime=now+30minutes Duration=60 Nodes=[available_nodes_hostnames ""] user=$user_name"]
+	set ret_code [create_res $res_name_test "StartTime=now+30minutes Duration=60 Nodes=[list2hostlist [get_nodes_by_state]] user=$user_name"]
 	if {$ret_code == 0} {
 		delete_res $res_name_test
 		delete_res $res_name
@@ -63,13 +63,13 @@ proc inc3_11_6 {} {
 
 
 	# Make the reservation
-	set ret_code [create_res $res_name "StartTime=now+30minutes Duration=60 Nodes=[available_nodes_hostnames ""] user=$user_name"]
+	set ret_code [create_res $res_name "StartTime=now+30minutes Duration=60 Nodes=[list2hostlist [get_nodes_by_state]] user=$user_name"]
 	if {$ret_code != 0} {
 		fail "Unable to create a valid reservation. (Within: inc3.11.6)"
 	}
 
 	# Test for time reservation conflict (trail overlap)
-	set ret_code [create_res $res_name_test "StartTime=now+60minutes Duration=60 Nodes=[available_nodes_hostnames ""] user=$user_name"]
+	set ret_code [create_res $res_name_test "StartTime=now+60minutes Duration=60 Nodes=[list2hostlist [get_nodes_by_state]] user=$user_name"]
 	if {$ret_code == 0} {
 		delete_res $res_name_test
 		delete_res $res_name
diff --git a/testsuite/expect/inc3.11.9 b/testsuite/expect/inc3.11.9
index 1474334802..a425b6d540 100644
--- a/testsuite/expect/inc3.11.9
+++ b/testsuite/expect/inc3.11.9
@@ -73,15 +73,15 @@ proc inc3_11_9 {} {
 		fail "Unable to delete reservation ($res_name)"
 	}
 
-	set nodes [available_nodes_hostnames $def_partition ]
-	set num_nodes [available_nodes "IDLE" $def_partition]
+	set nodes [get_nodes_by_state]
+	set num_nodes [llength $nodes]
 
 	set core_res_num   [ expr $cores_per_node / 2 ]
 	set thread_res_num [ expr $core_res_num * $threadcnt ]
 	set job_id 0
 
 	# Submit a batch job using half the threads on the nodes
-	set sbatch_pid [spawn $sbatch -w$nodes --time=10:00 --ntasks-per-node=$thread_res_num --output=/dev/null $file_in]
+	set sbatch_pid [spawn $sbatch -w[list2hostlist $nodes] --time=10:00 --ntasks-per-node=$thread_res_num --output=/dev/null $file_in]
 	expect {
 		-re "Submitted batch job ($number)" {
 			set job_id $expect_out(1,string)
diff --git a/testsuite/expect/regression.py b/testsuite/expect/regression.py
index 34c713ba6a..c90e201c2c 100755
--- a/testsuite/expect/regression.py
+++ b/testsuite/expect/regression.py
@@ -27,6 +27,7 @@
 """This script makes it easier to run the Slurm expect test scripts."""
 
 from __future__ import print_function
+import json
 import os
 import re
 import sys
@@ -62,6 +63,8 @@ def main(argv=None):
     parser.add_option('-b', '--begin-from-test', type='string',
                       dest='begin_from_test', action='callback',
                       callback=test_parser)
+    parser.add_option('-f', '--results-file', type='string',
+                      help='write json result to specified file name')
 
     (options, args) = parser.parse_args(args=argv)
 
@@ -108,12 +111,16 @@ def main(argv=None):
         test_env["SLURM_TESTSUITE_CLEANUP_ON_FAILURE"] = "true"
     print('Started:', time.asctime(time.localtime(start_time)), file=sys.stdout)
     sys.stdout.flush()
+    results_list = []
     for test in tests:
         if begin[0] > test[0] or (begin[0] == test[0] and begin[1] > test[1]):
             continue
-        sys.stdout.write('Running test %d.%d ' % (test[0],test[1]))
+        test_id = f"{test[0]}.{test[1]}"
+        sys.stdout.write(f"Running test {test_id} ")
         sys.stdout.flush()
-        testlog_name = 'test%d.%d.log' % (test[0],test[1])
+        test_dict = {}
+        test_dict['id'] = test_id
+        testlog_name = f"test{test_id}.log"
         try:
             os.remove(testlog_name+'.failed')
         except:
@@ -122,18 +129,76 @@ def main(argv=None):
 
         if options.time_individual:
             t1 = time.time()
+            test_dict['start_time'] = float("%.03f" % t1)
+
         retcode = Popen(('expect', test[2]), shell=False,
                         env=test_env, stdout=testlog, stderr=testlog).wait()
+
         if options.time_individual:
             t2 = time.time()
-            minutes = int(t2-t1)/60
-            seconds = (t2-t1)%60
+            minutes = int(int(t2-t1)/60)
+            seconds = (int(t2-t1))%60
             if minutes > 0:
                 sys.stdout.write('%d min '%(minutes))
             sys.stdout.write('%.2f sec '%(seconds))
+            test_dict['duration'] = float("%.03f" % (t2 - t1))
 
-        testlog.close()
         if retcode == 0:
+            status = 'pass'
+        elif retcode > 127:
+            status = 'skip'
+        else:
+            status = 'fail'
+
+        test_dict['status'] = status
+
+        # Determine the reason if requesting a json results file
+        if status != 'pass' and options.results_file:
+            testlog.flush()
+            testlog.seek(0)
+
+            fatals = []
+            errors = []
+            section = 'pre'
+            for line in testlog.readlines():
+                if re.search(fr"^{'=' * 78}", line):
+                    if section == 'pre':
+                        section = 'header'
+                    elif section == 'header':
+                        section = 'body'
+                    elif section == 'body':
+                        section = 'footer'
+                    elif section == 'footer':
+                        section = 'post'
+                    elif section != 'unknown':
+                        section = 'unknown'
+                    continue
+                if section == 'pre' and re.search(r'^TEST:\s+test', line):
+                    section = 'header'
+                    continue
+                if section == 'body':
+                    match = re.search(r'^\[[^\]]+\][ \[]+Fatal[ \]:]+(.*) \([^\)\(]+\)$', line)
+                    if match:
+                        fatals.append(match.group(1))
+                    else:
+                        match = re.search(r'^\[[^\]]+\][ \[]+Error[ \]:]+(.*) \([^\)\(]+\)$', line)
+                        if match:
+                            errors.append(match.group(1))
+                    continue
+                if section == 'footer':
+                    if re.search(r'^(?:SUCCESS\|SKIPPED\|FAILURE)\s+: test', line):
+                        continue
+
+            if fatals and not re.search(r'previous errors', fatals[0]):
+                test_dict['reason'] = fatals[0]
+            elif errors:
+                test_dict['reason'] = errors[0]
+
+        results_list.append(test_dict)
+
+        testlog.close()
+
+        if status == 'pass':
             passed_tests.append(test)
             sys.stdout.write('\n')
             if not options.keep_logs:
@@ -142,7 +207,7 @@ def main(argv=None):
                 except IOError as e:
                     print('ERROR failed to close %s %s' % (testlog_name, e),
                             file=sys.stederr);
-        elif retcode > 127:
+        elif status == 'skip':
             skipped_tests.append(test)
             sys.stdout.write('SKIPPED\n')
             if not options.keep_logs:
@@ -163,6 +228,11 @@ def main(argv=None):
     print('Ended:', time.asctime(time.localtime(end_time)), file=sys.stdout)
     print('\nTestsuite ran for %d minutes %d seconds'\
           %((end_time-start_time)/60,(end_time-start_time)%60), file=sys.stdout)
+
+    if options.results_file:
+        with open(options.results_file, 'w') as results_file:
+            json.dump(results_list, results_file)
+
     print('Completions  :', len(passed_tests), file=sys.stdout)
     print('Failures     :', len(failed_tests), file=sys.stdout)
     print('Skipped      :', len(skipped_tests), file=sys.stdout)
diff --git a/testsuite/expect/test1.1 b/testsuite/expect/test1.1
index 2eec95721e..63516d5e37 100755
--- a/testsuite/expect/test1.1
+++ b/testsuite/expect/test1.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code            0
 set login_grp_info       ""
 set job_grp_info         ""
 set got_job_grps         0
@@ -56,9 +55,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -77,6 +75,3 @@ if {$got_job_grps == 0} {
 if {[string compare $login_grp_info $job_grp_info] != 0} {
 	fail "Login and slurm user info mismatch"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.10 b/testsuite/expect/test1.10
index 06d209727e..9c5244538a 100755
--- a/testsuite/expect/test1.10
+++ b/testsuite/expect/test1.10
@@ -30,7 +30,6 @@ source ./globals
 
 set debug_get   0
 set debug_set   4
-set exit_code   0
 
 if [param_contains [get_config_param "LaunchParameters"] "test_exec"] {
 	skip "This test is incompatible with LaunchParameters=test_exec"
@@ -49,15 +48,11 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 }
 
 if {$debug_get != $debug_set} {
 	fail "Did not log at proper level ($debug_get != $debug_set)"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.100 b/testsuite/expect/test1.100
index 66929ba140..a427de43da 100755
--- a/testsuite/expect/test1.100
+++ b/testsuite/expect/test1.100
@@ -36,7 +36,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 }
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 2 } {
 	skip "Insufficient nodes in default partition ($node_count < 2)"
 }
@@ -55,9 +55,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -96,9 +95,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -148,9 +146,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.101 b/testsuite/expect/test1.101
index 963732d601..a69e7290d2 100755
--- a/testsuite/expect/test1.101
+++ b/testsuite/expect/test1.101
@@ -30,6 +30,12 @@ set file_in     "test$test_id.input"
 set job_id      0
 set timeout $max_job_delay
 
+proc cleanup {} {
+	global file_in
+
+	exec rm -f $file_in
+}
+
 if {[get_config_param "SlurmdUser"] ne "root(0)"} {
 	skip "This test is incompatible with SlurmdUser != root"
 }
@@ -50,9 +56,7 @@ expect {
 		#log_debug "Job initiated"
 	}
 	timeout {
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		fail "salloc not responding"
 	}
@@ -129,9 +133,6 @@ if {$exec_cnt != $node_cnt} {
 	set exit_code 1
 }
 
-if {$exit_code == 0} {
-	exec rm -f $file_in
-}
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.102 b/testsuite/expect/test1.102
index 0eda6f8ef5..2164e86eb8 100755
--- a/testsuite/expect/test1.102
+++ b/testsuite/expect/test1.102
@@ -48,8 +48,7 @@ expect {
 		fail "srun is OK with a deadline too old"
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.103 b/testsuite/expect/test1.103
index e55ddad6b5..69dac36edb 100755
--- a/testsuite/expect/test1.103
+++ b/testsuite/expect/test1.103
@@ -29,19 +29,6 @@ source ./globals
 set job_id	0
 set exit_code   0
 
-#
-# Since we make changes to configuration, call this function restore
-# configuration before exiting.
-#
-proc endit { } {
-	global exit_code
-	reconfigure
-	if {$exit_code != 0} {
-		fail "Exiting due to previous errors with exit code $exit_code"
-	}
-	pass
-}
-
 #
 # We must be SlurmUser or root in order to change the partition MaxTime limit,
 # otherwise this test may fail.
@@ -50,13 +37,23 @@ if {![is_super_user]} {
 	skip "You must be SlurmUser or root to run this test."
 }
 
+#
+# Since we make changes to configuration, define a cleanup function to restore
+# the configuration before exiting.
+#
+proc cleanup {} {
+	global job_id
+
+	cancel_job $job_id
+	reconfigure
+}
+
 #
 # Ensure that MaxTime is UNLIMITED so this test won't fail due to trying to set
 # time limits greater than MaxTime.
 #
-set exit_code [set_partition_maximum_time_limit "" -1]
-if { $exit_code != 0 } {
-	endit
+if [set_partition_maximum_time_limit "" -1] {
+	fail "Unable to set partition MaxTime to UNLIMITED"
 }
 
 #
@@ -75,16 +72,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$job_id == 0} {
-	log_error "Job launch failed"
-	set exit_code 1
+	fail "Job launch failed"
 } else {
 	spawn $scontrol show job $job_id
 	expect {
@@ -99,8 +94,7 @@ if {$job_id == 0} {
 			set exit_code 1
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -108,10 +102,6 @@ if {$job_id == 0} {
 	}
 }
 
-set rc [cancel_job $job_id]
-if { $rc != 0 } {
-	log_error "Unable to cancel job $job_id."
-	incr exit_code
+if {$exit_code != 0} {
+        fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
-
-endit
diff --git a/testsuite/expect/test1.104 b/testsuite/expect/test1.104
index 3e23b8b1ae..b3bfa9d2fc 100755
--- a/testsuite/expect/test1.104
+++ b/testsuite/expect/test1.104
@@ -54,8 +54,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -71,7 +70,7 @@ if {$found == 1} {
 #
 # Identify usable nodes in default partition
 #
-set def_node [get_idle_node_in_part]
+set def_node [lindex [get_nodes_by_state] 0]
 if {[string compare $def_node ""] == 0} {
 	fail "Default partition seems to have no idle nodes"
 }
@@ -87,8 +86,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -111,8 +109,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -154,8 +151,7 @@ if {[string compare $enforcepartlimits "NO"] == 0} {
 			set exit_code 0
 		}
 		timeout {
-			log_error "srun not responding"
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -182,8 +178,7 @@ if {[string compare $enforcepartlimits "NO"] == 0} {
 					exp_continue
 				}
 				timeout {
-					log_error "scontrol not responding"
-					set exit_code 1
+					fail "scontrol not responding"
 				}
 				eof {
 					wait
@@ -212,8 +207,7 @@ if {[string compare $enforcepartlimits "NO"] == 0} {
 	                exp_continue
 	        }
 	        timeout {
-	                log_error "srun not responding"
-	                set exit_code 1
+	                fail "srun not responding"
 	        }
 	        eof {
 	                wait
@@ -228,8 +222,7 @@ if {[string compare $enforcepartlimits "NO"] == 0} {
 spawn $scontrol delete PartitionName=$part_name
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -252,8 +245,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.105 b/testsuite/expect/test1.105
index c0b9239292..dce7bd197c 100755
--- a/testsuite/expect/test1.105
+++ b/testsuite/expect/test1.105
@@ -50,8 +50,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -73,8 +72,7 @@ if {$job_id == 0} {
 			set exit_code 1
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test1.106 b/testsuite/expect/test1.106
index 41c4278a96..a6ed2fe911 100755
--- a/testsuite/expect/test1.106
+++ b/testsuite/expect/test1.106
@@ -46,8 +46,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.107 b/testsuite/expect/test1.107
index daec823f90..3c368db5d4 100755
--- a/testsuite/expect/test1.107
+++ b/testsuite/expect/test1.107
@@ -29,19 +29,6 @@ source ./globals
 set exit_code   0
 set job_id      0
 
-#
-# Since we make changes to configuration, call this function restore
-# configuration before exiting.
-#
-proc endit { } {
-	global exit_code
-	reconfigure
-	if {$exit_code != 0} {
-		fail "Exiting due to previous errors with exit code $exit_code"
-	}
-	pass
-}
-
 #
 # We must be SlurmUser or root in order to change the partition MaxTime limit,
 # otherwise this test may fail.
@@ -50,13 +37,23 @@ if {![is_super_user]} {
 	skip "You must be SlurmUser or root to run this test."
 }
 
+#
+# Since we make changes to configuration, define a cleanup function to restore
+# the configuration before exiting.
+#
+proc cleanup {} {
+	global job_id
+
+	cancel_job $job_id
+	reconfigure
+}
+
 #
 # Ensure that MaxTime is UNLIMITED so this test won't fail due to trying to set
 # time limits greater than MaxTime.
 #
-set exit_code [set_partition_maximum_time_limit "" -1]
-if { $exit_code != 0 } {
-	endit
+if [set_partition_maximum_time_limit "" -1] {
+	fail "Unable to set partition MaxTime to UNLIMITED"
 }
 
 #
@@ -75,17 +72,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$job_id == 0} {
-	log_error "Job not submitted. This can be due to QOS or account time limit <120 minutes"
-	set exit_code 1
-	endit
+	fail "Job not submitted. This can be due to QOS or account time limit <120 minutes"
 }
 
 #
@@ -105,18 +99,13 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-set rc [cancel_job $job_id]
-if { $rc != 0 } {
-	log_error "Unable to cancel job $job_id."
-	incr exit_code
+if {$exit_code != 0} {
+        fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
-
-endit
diff --git a/testsuite/expect/test1.108 b/testsuite/expect/test1.108
index 62f7420d84..cd8d513579 100755
--- a/testsuite/expect/test1.108
+++ b/testsuite/expect/test1.108
@@ -50,8 +50,7 @@ expect {
 	}
 
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.11 b/testsuite/expect/test1.11
index 7d2a591526..fbb198da38 100755
--- a/testsuite/expect/test1.11
+++ b/testsuite/expect/test1.11
@@ -61,9 +61,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -85,8 +84,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.110 b/testsuite/expect/test1.110
index cd96ec7857..3230ab6b29 100755
--- a/testsuite/expect/test1.110
+++ b/testsuite/expect/test1.110
@@ -57,8 +57,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.111 b/testsuite/expect/test1.111
index b37e55f274..928fe48043 100755
--- a/testsuite/expect/test1.111
+++ b/testsuite/expect/test1.111
@@ -29,19 +29,6 @@ source ./globals
 set exit_code   0
 set job_id      0
 
-#
-# Since we make changes to configuration, call this function restore
-# configuration before exiting.
-#
-proc endit { } {
-	global exit_code
-	reconfigure
-	if {$exit_code != 0} {
-		fail "Exiting due to previous errors with exit code $exit_code"
-	}
-	pass
-}
-
 #
 # We must be SlurmUser or root in order to change the partition MaxTime limit,
 # otherwise this test may fail.
@@ -50,13 +37,23 @@ if {![is_super_user]} {
 	skip "You must be SlurmUser or root to run this test"
 }
 
+#
+# Since we make changes to configuration, define a cleanup function to restore
+# the configuration before exiting.
+#
+proc cleanup {} {
+	global job_id
+
+	cancel_job $job_id
+	reconfigure
+}
+
 #
 # Ensure that MaxTime is UNLIMITED so this test won't fail due to trying to set
 # time limits greater than MaxTime.
 #
-set exit_code [set_partition_maximum_time_limit "" -1]
-if { $exit_code != 0 } {
-	endit
+if [set_partition_maximum_time_limit "" -1] {
+	fail "Unable to set partition MaxTime to UNLIMITED"
 }
 
 #
@@ -82,17 +79,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$job_id == 0} {
-	log_error "Batch not submitted"
-	set exit_code 1
-	endit
+	fail "Batch not submitted"
 }
 
 #
@@ -111,12 +105,13 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sacct not responding"
-		set exit_code 1
+		fail "sacct not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-endit
+if {$exit_code != 0} {
+        fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+}
diff --git a/testsuite/expect/test1.112 b/testsuite/expect/test1.112
index a8add94fd9..df7770fc21 100755
--- a/testsuite/expect/test1.112
+++ b/testsuite/expect/test1.112
@@ -54,8 +54,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -78,8 +77,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.113 b/testsuite/expect/test1.113
index c32b8af994..8153d409d4 100755
--- a/testsuite/expect/test1.113
+++ b/testsuite/expect/test1.113
@@ -48,8 +48,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -80,9 +79,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.114 b/testsuite/expect/test1.114
index c973a56612..369c79b3fb 100755
--- a/testsuite/expect/test1.114
+++ b/testsuite/expect/test1.114
@@ -28,11 +28,11 @@ source ./globals
 
 set node_cnt    0
 set exit_code   0
-
 set jobid_excl  0
 
 proc cleanup {} {
 	global jobid_excl
+
 	cancel_job $jobid_excl
 }
 
@@ -48,9 +48,8 @@ proc run_spread_job { task_cnt } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $sun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -75,8 +74,7 @@ proc run_spread_job { task_cnt } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -93,7 +91,7 @@ if {![check_config_select "cons_res"] &&
 	skip "Test is only compatible with a config of SelectType=select/cons_res or select/cons_tres"
 }
 
-set nodes    [get_partition_nodes [default_partition] idle]
+set nodes    [get_nodes_by_state]
 set node_cnt [llength $nodes]
 if { $node_cnt < 3} {
 	skip "Insufficient nodes for test in default partition ($node_cnt < 3)"
diff --git a/testsuite/expect/test1.115 b/testsuite/expect/test1.115
index d2f0620030..1547c7c40b 100755
--- a/testsuite/expect/test1.115
+++ b/testsuite/expect/test1.115
@@ -50,8 +50,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.116 b/testsuite/expect/test1.116
index a63b5d3cc4..2108d8d105 100755
--- a/testsuite/expect/test1.116
+++ b/testsuite/expect/test1.116
@@ -109,18 +109,15 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$no_start != 0} {
-	if {$job_id != 0} {
-		cancel_job $job_id
-	}
+	cancel_job $job_id
 	skip "Partition too small for test"
 }
 if {$job_id == 0} {
diff --git a/testsuite/expect/test1.13 b/testsuite/expect/test1.13
index 6457afbeb9..e31cd50c2f 100755
--- a/testsuite/expect/test1.13
+++ b/testsuite/expect/test1.13
@@ -44,9 +44,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -76,9 +75,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.14 b/testsuite/expect/test1.14
index 7670c4d0ff..7300d3a535 100755
--- a/testsuite/expect/test1.14
+++ b/testsuite/expect/test1.14
@@ -91,9 +91,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.15 b/testsuite/expect/test1.15
index 240858a8f4..96936685e4 100755
--- a/testsuite/expect/test1.15
+++ b/testsuite/expect/test1.15
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.bash"
 set matches     0
 
@@ -48,9 +47,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -60,6 +58,3 @@ expect {
 if {$matches != 2} {
 	fail "Problem with srun wait option matches was $matches"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.16 b/testsuite/expect/test1.16
index 263f202786..31c53894fb 100755
--- a/testsuite/expect/test1.16
+++ b/testsuite/expect/test1.16
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code          0
 set job_id             0
 set matches            0
 set scratch_file       "scratch.$test_id"
@@ -55,9 +54,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -72,6 +70,3 @@ if {$matches != 1} {
 	exec $bin_rm -f $scratch_file
 	fail "srun --unbuffered option failure"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.17 b/testsuite/expect/test1.17
index 92bde20933..86560b88ca 100755
--- a/testsuite/expect/test1.17
+++ b/testsuite/expect/test1.17
@@ -66,9 +66,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -141,9 +140,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.18 b/testsuite/expect/test1.18
index 1b3ae9d070..90e0062d1d 100755
--- a/testsuite/expect/test1.18
+++ b/testsuite/expect/test1.18
@@ -81,8 +81,7 @@ if {[string compare $licenses ""] != 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding. This test can fail if the selected license is in use"
-			set exit_code 1
+			fail "srun not responding. This test can fail if the selected license is in use"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test1.2 b/testsuite/expect/test1.2
index 5e916e69bb..6bbeb2fc6e 100755
--- a/testsuite/expect/test1.2
+++ b/testsuite/expect/test1.2
@@ -29,7 +29,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set tasks       0
 set task_cnt	10
 
@@ -46,9 +45,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -56,9 +54,5 @@ expect {
 }
 
 if {$task_cnt != $tasks} {
-	log_error "Did not get proper number of tasks: $task_cnt != $tasks"
-	set exit_code 1
-}
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+	fail "Did not get proper number of tasks: $task_cnt != $tasks"
 }
diff --git a/testsuite/expect/test1.20 b/testsuite/expect/test1.20
index 63ea2c04b4..78208bd08a 100755
--- a/testsuite/expect/test1.20
+++ b/testsuite/expect/test1.20
@@ -48,9 +48,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -74,9 +73,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.21 b/testsuite/expect/test1.21
index 99727e38b5..2dcdd001ec 100755
--- a/testsuite/expect/test1.21
+++ b/testsuite/expect/test1.21
@@ -62,9 +62,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -105,9 +104,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.22 b/testsuite/expect/test1.22
index 50dd4c04d6..9db9742490 100755
--- a/testsuite/expect/test1.22
+++ b/testsuite/expect/test1.22
@@ -46,9 +46,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -83,9 +82,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.23 b/testsuite/expect/test1.23
index 2181ad21ec..2dae60c66b 100755
--- a/testsuite/expect/test1.23
+++ b/testsuite/expect/test1.23
@@ -49,9 +49,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -84,9 +83,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -116,9 +114,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -161,9 +158,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -193,9 +189,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -228,9 +223,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.24 b/testsuite/expect/test1.24
index 5ac0b42b58..58e4685551 100755
--- a/testsuite/expect/test1.24
+++ b/testsuite/expect/test1.24
@@ -28,8 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 #
 # Submit a job with invalid constraint requirement
 #
@@ -48,9 +46,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -58,13 +55,8 @@ expect {
 }
 
 if {[string compare $host_0 ""] != 0} {
-	log_error "Job ran with invalid constraint option"
-	set exit_code   1
+	fail "Job ran with invalid constraint option"
 }
 if {$err_msg != 1} {
 	fail "Job failed to report required error"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.25 b/testsuite/expect/test1.25
index 5beba88bd0..14edbaa9f8 100755
--- a/testsuite/expect/test1.25
+++ b/testsuite/expect/test1.25
@@ -47,9 +47,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.26 b/testsuite/expect/test1.26
index 2dd242efda..330be623fe 100755
--- a/testsuite/expect/test1.26
+++ b/testsuite/expect/test1.26
@@ -31,7 +31,6 @@
 source ./globals
 
 set iterations 100
-set exit_code   0
 
 if {![is_super_user]} {
 	skip "This test can't be run except as SlurmUser"
@@ -41,43 +40,20 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
     skip "This test is incompatible with front-end systems"
 }
 
-set switch [switch_type]
-if {[string compare $switch "none"]} {
-        skip "This test is incompatible with switch/$switch"
+set switch [get_config_param "SwitchType"]
+if {$switch ne "switch/none"} {
+        skip "This test is incompatible with $switch"
 }
 
 #
 # Submit a 1 node job and record the node name
 #
-# NOTE: Check explicity for "^0:" or "\n0:. Otherwise in srun verbose mode we
-# can get a hostname ending with 0 in the messages that gets used to generate
-# a bad value for host_0 below.
-#
-set host_0      ""
-set nodelist_name ""
-set timeout $max_job_delay
-set srun_pid [spawn $srun -v -N1 -l -t1 $bin_printenv SLURMD_NODENAME]
-expect {
-	-re "on host ($re_word_str)," {
-		set nodelist_name $expect_out(1,string)
-		exp_continue
-	}
-	-re "^0: ($re_word_str)" {
-		set host_0 $expect_out(1,string)
-		exp_continue
-	}
-	-re "\n0: ($re_word_str)" {
-		set host_0 $expect_out(1,string)
-		exp_continue
-	}
-	timeout {
-		log_error "srun not responding"
-		slow_kill $srun_pid
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
+set output [run_command_output -fail "$srun -v -N1 -l -t1 $bin_printenv SLURMD_NODENAME"]
+if {![regexp {on host (\S+),} $output - nodelist_name]} {
+	fail "Unable to parse assigned task host name from srun output"
+}
+if {![regexp -line {^0: (\S+)} $output - host_0]} {
+	fail "Unable to parse value of SLURMD_NODENAME from srun output"
 }
 
 #
@@ -97,50 +73,11 @@ set include_node $host_0
 #
 # Submit a job directly to that node
 #
-set host_1      ""
-set slurm_user  1
-set timeout     10
-set srun_pid [spawn $srun -N1 -l --nodelist=$include_node --no-allocate -t1 $bin_printenv SLURMD_NODENAME]
-expect {
-	-re "Invalid job credential" {
-		log_warn "Not SlurmUser or root"
-		set slurm_user 0
-		exp_continue
-	}
-	-re "error: .*try again" {
-		log_debug "Can't avoid this possible error"
-		set host_1 $host_0
-		exp_continue
-	}
-	-re "error: .*already in shared memory" {
-		log_debug "Can't avoid this possible error"
-		set host_1 $host_0
-		exp_continue
-	}
-	-re "error: .*exit code 1" {
-		exp_continue
-	}
-	-re "0: ($re_word_str)" {
-		set host_1 $expect_out(1,string)
-		exp_continue
-	}
-	timeout {
-		log_error "srun not responding."
-		slow_kill $srun_pid
-		set slurm_user 0
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-if {$slurm_user == 0} {
-	pass
-}
-if {[string compare $host_1 $include_node]} {
-	log_error "Allocation lacked an included node"
-	set exit_code 1
+set output [run_command_output -fail "$srun -N1 -l --nodelist=$include_node --no-allocate -t1 $bin_printenv SLURMD_NODENAME"]
+if {![regexp -line {^0: (\S+)} $output - host_1]} {
+	fail "Unable to parse value of SLURMD_NODENAME from srun output"
 }
+subtest {$host_1 eq $include_node} "Allocation was on included host" "$host_1 !=$include_node"
 
 #
 # Run three tasks at a time on some node and do so repeatedly
@@ -149,8 +86,6 @@ if {[string compare $host_1 $include_node]} {
 # logic has time to be processed (slurmd -> slurmctld messages)
 # Note: process output in order of expected completion
 #
-set front_end {[get_config_param "FrontendName"] ne "MISSING"}
-
 set successes 0
 for {set inx 0} {$inx < $iterations} {incr inx} {
 	exec $bin_sleep 0.25
@@ -244,14 +179,6 @@ for {set inx 0} {$inx < $iterations} {incr inx} {
 
 	if {$failures == 0} {
 		incr successes
-	} else {
-		set exit_code 1
 	}
 }
-if {$successes != $iterations} {
-	fail "Only $successes of $iterations completed successfully"
-}
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
+subtest {$successes == $iterations} "Race condition check" "[expr $iterations - $successes] out of $iterations iterations failed"
diff --git a/testsuite/expect/test1.27 b/testsuite/expect/test1.27
index 559518dc34..4913d887c3 100755
--- a/testsuite/expect/test1.27
+++ b/testsuite/expect/test1.27
@@ -29,7 +29,6 @@
 ############################################################################
 source ./globals
 
-set exit_code        0
 set matches          0
 
 # These are the variables for which we are checking existence.
@@ -86,9 +85,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -113,7 +111,3 @@ foreach {slurm_var check_flag} [array get good_vars] {
 if {$good < $total} {
 	fail "Only $good of $total Slurm environment variables set"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.28 b/testsuite/expect/test1.28
index fc3a496eb2..76806b0da8 100755
--- a/testsuite/expect/test1.28
+++ b/testsuite/expect/test1.28
@@ -31,9 +31,14 @@ source ./globals
 set file_in          "test$test_id.input"
 set test_env_name    "TEST_ENV_$test_id"
 set test_env_val     123
-set exit_code        0
 set matches          0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 make_bash_script $file_in "env | grep TEST; exit 0"
 
 #
@@ -49,9 +54,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -76,9 +80,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -101,9 +104,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -126,9 +128,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -137,9 +138,3 @@ expect {
 if {$matches != 0} {
 	fail "Environment variables were propagated ($matches != 0)"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.29 b/testsuite/expect/test1.29
index b75ee4afd8..b78bcdc5c1 100755
--- a/testsuite/expect/test1.29
+++ b/testsuite/expect/test1.29
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code        0
 set file_err         "test$test_id.error"
 set file_in          "test$test_id.input"
 set file_out         "test$test_id.output"
@@ -41,6 +40,12 @@ set limit_nproc      34500
 set limit_stack      5021
 set matches          0
 
+proc cleanup {} {
+	global bin_rm file_err file_in file_prog_get file_out
+
+	exec $bin_rm -f $file_err $file_in $file_prog_get $file_out
+}
+
 if {[get_config_param "FrontendName"] ne "MISSING" && ![is_super_user]} {
 	skip "This test is incompatible with front-end systems"
 }
@@ -139,9 +144,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -219,8 +223,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "Sort not responding"
-		set exit_code 1
+		fail "sort not responding"
 	}
 	eof {
 		wait
@@ -231,10 +234,3 @@ set target 5
 if {$matches != $target} {
 	fail "User limits not propagated got $matches of $target matches. Check PropagateResourceLimits configuration parameter. Check $file_err for errors. A long running slurmd could cause a file size limit error. slurmd could have been started with limits lower than user launching the task"
 }
-
-if {$exit_code == 0} {
-    exec $bin_rm -f $file_err $file_in $file_prog_get $file_out
-
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.3 b/testsuite/expect/test1.3
index 21544b50cf..caae55d64c 100755
--- a/testsuite/expect/test1.3
+++ b/testsuite/expect/test1.3
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set version     0
 
 #
@@ -41,9 +40,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$version != 1} {
 	fail "Did not get proper srun version number"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.30 b/testsuite/expect/test1.30
index c7249996ce..5c3ecea65f 100755
--- a/testsuite/expect/test1.30
+++ b/testsuite/expect/test1.30
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set error 0
 set srun_opts "-c1"
 
@@ -52,9 +51,7 @@ for {set node_cnt 1} {$node_cnt < $max_node_cnt} {set node_cnt [expr $node_cnt *
 			exp_continue
 		}
 		-re "Unable to contact" {
-			log_error "Slurm appears to be down"
-			set exit_code 1
-			exp_continue
+			fail "Slurm appears to be down"
 		}
 		-re "Unable to allocate resources" {
 			log_debug "This error is expected, no worries"
@@ -72,9 +69,8 @@ for {set node_cnt 1} {$node_cnt < $max_node_cnt} {set node_cnt [expr $node_cnt *
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -85,7 +81,3 @@ for {set node_cnt 1} {$node_cnt < $max_node_cnt} {set node_cnt [expr $node_cnt *
 if {$error == 1} {
 	fail "Some error happened"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.31 b/testsuite/expect/test1.31
index 79f798e1a4..e53d2b28f2 100755
--- a/testsuite/expect/test1.31
+++ b/testsuite/expect/test1.31
@@ -74,9 +74,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -130,9 +129,7 @@ expect {
 	}
 
 	timeout {
-		log_error "$bin_sort not responding"
-		set exit_code 1
-		exp_continue
+		fail "$bin_sort not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.32 b/testsuite/expect/test1.32
index 15c4eea76b..046bf221d8 100755
--- a/testsuite/expect/test1.32
+++ b/testsuite/expect/test1.32
@@ -96,9 +96,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		log_debug "EOF"
diff --git a/testsuite/expect/test1.33 b/testsuite/expect/test1.33
index de126f1285..098fedc097 100755
--- a/testsuite/expect/test1.33
+++ b/testsuite/expect/test1.33
@@ -67,9 +67,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.34 b/testsuite/expect/test1.34
index 3ea5ddcd9c..734377a429 100755
--- a/testsuite/expect/test1.34
+++ b/testsuite/expect/test1.34
@@ -29,10 +29,15 @@
 ############################################################################
 source ./globals
 
-set exit_code      0
 set file_in        "test$test_id.bash"
 set test_prog      "test$test_id.prog"
 
+proc cleanup {} {
+	global bin_rm file_in test_prog
+
+	exec $bin_rm -f $file_in $test_prog
+}
+
 if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
@@ -60,24 +65,13 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "srun failed to report exit code"
-	set exit_code 1
-}
-
-#
-# Post-processing
-#
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $test_prog
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+	fail "srun failed to report exit code"
 }
diff --git a/testsuite/expect/test1.35 b/testsuite/expect/test1.35
index b7e25de599..c373ef9b80 100755
--- a/testsuite/expect/test1.35
+++ b/testsuite/expect/test1.35
@@ -33,7 +33,6 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set file_err    "test$test_id.error"
 
-set exit_code            0
 set job_id               0
 set steps_started        30
 set job_mem_opt          "--mem-per-cpu=128M"
@@ -41,9 +40,8 @@ set step_mem_opt         "--mem-per-cpu=4M"
 
 proc cleanup {} {
 	global job_id bin_rm file_in file_out file_err
-	if {$job_id} {
-		cancel_job $job_id
-	}
+
+	cancel_job $job_id
 	exec $bin_rm -f $file_in $file_out $file_err
 }
 
@@ -134,9 +132,3 @@ expect {
 	}
 }
 subtest {$step_cnt == $steps_started} "All steps ($steps_started) should be reported on the output file: $file_out" "($step_cnt != $steps_started)"
-
-
-if {$exit_code} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
-
diff --git a/testsuite/expect/test1.36 b/testsuite/expect/test1.36
index 3fd88f6869..983719e172 100755
--- a/testsuite/expect/test1.36
+++ b/testsuite/expect/test1.36
@@ -28,8 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
-
 #
 # Spawn srun with $task_cnt tasks each of which runs a $mult way /bin/id
 #
@@ -46,9 +44,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -58,7 +55,3 @@ expect {
 if {$task_output != [expr $task_cnt * $mult]} {
 	fail "Failed to get output from all tasks"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.37 b/testsuite/expect/test1.37
index 05c4cd554a..dff7ff6c20 100755
--- a/testsuite/expect/test1.37
+++ b/testsuite/expect/test1.37
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set task_num    0
 
 if {[get_config_param "FrontendName"] ne "MISSING"} {
@@ -55,9 +54,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -67,7 +65,3 @@ expect {
 if {$task_output != $task_num} {
 	fail "Failed to get output from all tasks"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.38 b/testsuite/expect/test1.38
index 0f69a64601..62b6b2bf9f 100755
--- a/testsuite/expect/test1.38
+++ b/testsuite/expect/test1.38
@@ -83,9 +83,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -134,9 +133,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.4 b/testsuite/expect/test1.4
index 004ca8eeaa..cbb0d0188b 100755
--- a/testsuite/expect/test1.4
+++ b/testsuite/expect/test1.4
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -41,9 +40,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$matches != 1} {
 	fail "srun failed to report usage format"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.40 b/testsuite/expect/test1.40
index 094cb50dfd..6ec6060d0a 100755
--- a/testsuite/expect/test1.40
+++ b/testsuite/expect/test1.40
@@ -59,9 +59,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -82,8 +81,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -114,9 +112,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -138,8 +135,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.41 b/testsuite/expect/test1.41
index fbaf3a310b..18442084e5 100755
--- a/testsuite/expect/test1.41
+++ b/testsuite/expect/test1.41
@@ -69,9 +69,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.43 b/testsuite/expect/test1.43
index 9ca57b7ff5..6fef551f11 100755
--- a/testsuite/expect/test1.43
+++ b/testsuite/expect/test1.43
@@ -54,9 +54,8 @@ for {set node_cnt 1} {$node_cnt > 0} {set node_cnt [expr $node_cnt * 2]} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test1.45 b/testsuite/expect/test1.45
index 285673d105..7e63be0aba 100755
--- a/testsuite/expect/test1.45
+++ b/testsuite/expect/test1.45
@@ -70,8 +70,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.46 b/testsuite/expect/test1.46
index 906e1b436c..90ab8084de 100755
--- a/testsuite/expect/test1.46
+++ b/testsuite/expect/test1.46
@@ -32,6 +32,12 @@ set exit_code   0
 set file_in     "test$test_id.prog"
 set matches     0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in $file_in.c
+}
+
 #
 # Delete left-over input script
 # Build input script file
@@ -79,9 +85,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -91,8 +96,3 @@ expect {
 if {$matches != 1} {
 	fail "Problem with --kill-on-bad-exit option"
 }
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_in.c
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.48 b/testsuite/expect/test1.48
index 88ed3b591d..d83e7852b9 100755
--- a/testsuite/expect/test1.48
+++ b/testsuite/expect/test1.48
@@ -28,49 +28,82 @@
 ############################################################################
 source ./globals
 
-set exit_code            0
 set got_job_grps         0
 set got_login_grps       0
+set config_dir           [get_conf_path]
+set config_file          "$config_dir/slurm.conf"
+set cwd                  "[$bin_pwd]"
+set mail_prog            "$test_id.MailProg.sh"
+set mail_prog_out        "$test_id.MailProg.out"
 
 if {[get_config_param "FrontendName"] ne "MISSING" && ![is_super_user]} {
 	skip "This test is incompatible with front-end systems"
 }
 
+proc cleanup { } {
+	global config_file bin_rm mail_prog mail_prog_out
+
+	restore_conf $config_file
+	exec $bin_rm -f $mail_prog $mail_prog_out
+	reconfigure
+}
+
+save_conf $config_file
+make_bash_script $mail_prog "
+echo $@ >> $cwd/$mail_prog_out
+"
+
+#Comment MailProg line if existed before
+exec $bin_sed -i /^\[\t\s\]*MailProg\[\t\s\]*=/Id $config_file
+
+# Append MailProg config to the slurm.conf
+exec $bin_echo "MailProg=$cwd/$mail_prog" >> $config_file
+reconfigure
+
+
 #
 # Execute 'id' to determine my user and group ID...
 #
-
 set login_grp_info [get_my_user_name]
 
 #
 # Submit a slurm job that will execute 'id'
 #
+set job_id 0
+set got_job_id 0
 set timeout $max_job_delay
-set srun_pid [spawn $srun -N1 -t1 --job-name=test$test_id --mail-type=all --mail-user=$login_grp_info $bin_id -un]
+set srun_pid [spawn $srun -N1 -t1 --job-name=test$test_id --mail-type=all --mail-user=$login_grp_info /bin/bash -c "echo \$SLURM_JOB_ID"]
 expect {
 	-re "error" {
-		log_error "Error running srun"
-		set exit_code 1
-		exp_continue
+		fail "Error running srun"
 	}
-	-re "$login_grp_info" {
-		set got_job_grps 1
+	-re "($number)" {
+		set job_id $expect_out(1,string)
+		set got_job_id 1
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$got_job_grps == 0} {
-	fail "Did not get user info from slurm job"
+if {$got_job_id == 0} {
+	fail "Did not get JobId info from slurm job"
 }
 
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+# Wait for mails to go through agent
+if {[wait_for_file $mail_prog_out] != 0} {
+	fail "No output file"
+}
+
+set output [run_command_output -fail "$bin_cat $mail_prog_out"]
+if {![regexp "-s Slurm Job_id=$job_id Name=test$test_id Began" $output]} {
+	fail "Began mail not sent for $job_id"
+}
+if {![regexp "-s Slurm Job_id=$job_id Name=test$test_id Ended" $output]} {
+	fail "Ended mail not sent for $job_id"
 }
diff --git a/testsuite/expect/test1.49 b/testsuite/expect/test1.49
index 4e57bf52ba..1a447f46f2 100755
--- a/testsuite/expect/test1.49
+++ b/testsuite/expect/test1.49
@@ -86,9 +86,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.5 b/testsuite/expect/test1.5
index 5cbbc5067a..984e02f436 100755
--- a/testsuite/expect/test1.5
+++ b/testsuite/expect/test1.5
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -49,9 +48,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -62,6 +60,3 @@ set target_matches 3
 if {$matches < $target_matches} {
 	fail "srun failed to report help message ($matches of $target_matches)"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.50 b/testsuite/expect/test1.50
index 3bc9a2116d..5b678dfb3f 100755
--- a/testsuite/expect/test1.50
+++ b/testsuite/expect/test1.50
@@ -65,9 +65,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.51 b/testsuite/expect/test1.51
index d18315620b..c998a7f903 100755
--- a/testsuite/expect/test1.51
+++ b/testsuite/expect/test1.51
@@ -28,10 +28,15 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
 set file_in      "test$test_id.input"
 set file_script  "test$test_id.script"
 
+proc cleanup {} {
+	global bin_rm file_in file_script
+
+	exec $bin_rm -f $file_in $file_script
+}
+
 if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
@@ -68,9 +73,3 @@ expect {
 if {$matches != 1} {
 	fail "umask not propagated"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_script
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.52 b/testsuite/expect/test1.52
index 75cc42f9ee..86a72319da 100755
--- a/testsuite/expect/test1.52
+++ b/testsuite/expect/test1.52
@@ -63,7 +63,7 @@ expect {
 	}
 }
 
-set idle_nodes [available_nodes idle]
+set idle_nodes [llength [get_nodes_by_state]]
 if { ($idle_nodes < 3) || ($max_nodes < 3) } {
 	if { $max_nodes == 999999 } {
 		skip "Default partition must have at least 3 idle nodes and MaxNodes >= 3 to run this test on. IDLE:$idle_nodes MaxNodes:UNLIMITED"
@@ -128,9 +128,8 @@ for {set i 0} {$i<3} {incr i} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test1.53 b/testsuite/expect/test1.53
index 3523f9f5b9..f3b6d8d9d5 100755
--- a/testsuite/expect/test1.53
+++ b/testsuite/expect/test1.53
@@ -29,9 +29,14 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
 set file_prog    "test$test_id.prog"
 
+proc cleanup {} {
+	global file_prog
+
+	exec rm -f $file_prog
+}
+
 #
 # Delete left-over programs and rebuild them.
 #
@@ -56,9 +61,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -69,10 +73,3 @@ if {$began_flag == 0} {
 } elseif {$run_time < 59 || $run_time > 121} {
 	fail "Problem with time limit signal"
 }
-
-if {$exit_code == 0} {
-	exec rm -f $file_prog
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
-
diff --git a/testsuite/expect/test1.54 b/testsuite/expect/test1.54
index 9b2c26477f..4e468dc2a9 100755
--- a/testsuite/expect/test1.54
+++ b/testsuite/expect/test1.54
@@ -31,6 +31,12 @@ source ./globals
 set file_in     "test$test_id.input"
 set exit_code   0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
@@ -74,20 +80,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 4} {
-	log_error "Did not get expected multi-program output"
-	set exit_code 1
-}
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+	fail "Did not get expected multi-program output"
 } else {
 	log_debug "So far, so good"
 }
@@ -132,9 +133,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -169,9 +169,8 @@ expect {
 		incr matches
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -210,9 +209,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -222,8 +220,6 @@ if {$matches != 2} {
 	fail "Processing MPMD line continuation ($matches != 2)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.55 b/testsuite/expect/test1.55
index 5390a6383a..253dbfc78a 100755
--- a/testsuite/expect/test1.55
+++ b/testsuite/expect/test1.55
@@ -118,7 +118,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		fail "Squeue not responding"
+		fail "squeue not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.59 b/testsuite/expect/test1.59
index 1fc3b807c8..9e5a7229e0 100755
--- a/testsuite/expect/test1.59
+++ b/testsuite/expect/test1.59
@@ -36,13 +36,19 @@ set task_count  0
 set job_id      0
 set hostfile    "test$test_id.hostfile"
 
+proc cleanup {} {
+	global bin_rm hostfile
+
+	exec $bin_rm -f $hostfile
+}
+
 exec $bin_rm -f $hostfile
 if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test incompatible with front-end systems"
 }
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 3 } {
 	skip "Insufficient nodes in default partition ($node_count < 3)"
 }
@@ -72,9 +78,8 @@ expect {
 		#log_debug "Job initiated"
 	}
 	timeout {
-		log_error "salloc not responding"
 		slow_kill $salloc_pid
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -379,8 +384,6 @@ expect {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $hostfile
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.6 b/testsuite/expect/test1.6
index f28cf76144..fe90c2e78a 100755
--- a/testsuite/expect/test1.6
+++ b/testsuite/expect/test1.6
@@ -31,7 +31,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 set tmp_dir	"/tmp"
 
@@ -49,9 +48,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -61,6 +59,3 @@ expect {
 if {$matches != 1} {
 	fail "Srun failed to change working directory"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.60 b/testsuite/expect/test1.60
index 0291d749e1..76d3d0b98e 100755
--- a/testsuite/expect/test1.60
+++ b/testsuite/expect/test1.60
@@ -119,7 +119,9 @@ if {$file_cnt != $node_count} {
 	log_error "File format of %t in stdout failed"
 	set exit_code 1
 }
-fail_on_error "Test failed due to previous errors"
+if {$exit_code != 0} {
+	fail "Test failed due to previous errors"
+}
 for {set node_id 0} {$node_id < $node_count} {incr node_id} {
 	set file_out_n_glob  "test$test_id.n.$node_id.output"
 	exec $bin_rm -f $file_out_n_glob
diff --git a/testsuite/expect/test1.61 b/testsuite/expect/test1.61
index 8d48b6efab..5227f6789b 100755
--- a/testsuite/expect/test1.61
+++ b/testsuite/expect/test1.61
@@ -52,8 +52,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.62 b/testsuite/expect/test1.62
index 13a641f28e..18510f97b8 100755
--- a/testsuite/expect/test1.62
+++ b/testsuite/expect/test1.62
@@ -71,9 +71,8 @@ proc run_gpu_test { gres_cnt } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -106,9 +105,8 @@ proc run_gpu_fail { gres_spec } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test1.63 b/testsuite/expect/test1.63
index b276706039..7c58b661dc 100755
--- a/testsuite/expect/test1.63
+++ b/testsuite/expect/test1.63
@@ -29,9 +29,14 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_prog   "test$test_id.prog"
 
+proc cleanup {} {
+	global bin_rm file_prog
+
+	exec $bin_rm -f $file_prog
+}
+
 #
 # Delete left-over programs and rebuild them.
 # We use our own program to get ulimit values since the output
@@ -72,9 +77,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -89,12 +93,3 @@ if {$match_sig < 1} {
 if {$match_abort < 1} {
 	fail "srun failed to properly process multiple SIGINT to abort"
 }
-
-#
-# Post-processing
-#
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_prog
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.65 b/testsuite/expect/test1.65
index 761aa057e1..1a48bd4240 100755
--- a/testsuite/expect/test1.65
+++ b/testsuite/expect/test1.65
@@ -26,7 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -43,9 +42,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -56,6 +54,3 @@ set target_matches 2
 if {$matches < $target_matches} {
 	fail "srun failed to report help message ($matches of $target_matches)"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.66 b/testsuite/expect/test1.66
index 0916941b2d..fde25cf5bf 100755
--- a/testsuite/expect/test1.66
+++ b/testsuite/expect/test1.66
@@ -32,7 +32,7 @@ set script      "test$test_id.bash"
 set file_out    "test$test_id.out"
 set job_id      0
 
-set node_cnt [available_nodes]
+set node_cnt [llength [get_nodes_by_state idle,alloc,comp]]
 if {$node_cnt < 2} {
 	skip "Not enough nodes in partition ($node_cnt < 2)"
 }
@@ -52,8 +52,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.67 b/testsuite/expect/test1.67
index 536cc5dd7e..cbf81d2488 100755
--- a/testsuite/expect/test1.67
+++ b/testsuite/expect/test1.67
@@ -33,6 +33,12 @@ set test_srun   "test$test_id.test_srun"
 set job_id      0
 set exit_code   0
 
+proc cleanup {} {
+	global bin_rm test_timer test_srun file_in
+
+	exec $bin_rm -f $test_timer $test_srun $file_in
+}
+
 # remove any remaining files
 exec $bin_rm -f $test_timer $test_srun $file_in
 
@@ -80,8 +86,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -98,9 +103,7 @@ if {$fini_match != 1} {
 	fail "srun did not finish the program submitted"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $test_timer $test_srun $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
 
diff --git a/testsuite/expect/test1.68 b/testsuite/expect/test1.68
index 3d8cf38cc0..b47fab517d 100755
--- a/testsuite/expect/test1.68
+++ b/testsuite/expect/test1.68
@@ -34,6 +34,12 @@ set stop_srun   "test$test_id.stop_srun"
 set job_id      0
 set exit_code   0
 
+proc cleanup {} {
+	global bin_rm test_timer test_srun file_in stop_srun
+
+	exec $bin_rm -f $test_timer $test_srun $file_in $stop_srun
+}
+
 #remove any remaining files
 exec $bin_rm -f $test_timer $test_srun $file_in $stop_srun
 
@@ -119,8 +125,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -140,8 +145,6 @@ if {$fini_match != 1} {
 	fail "srun did not finish the program submitted"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $test_timer $test_srun $file_in $stop_srun
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.69 b/testsuite/expect/test1.69
index ec53b0c619..b851b52a88 100755
--- a/testsuite/expect/test1.69
+++ b/testsuite/expect/test1.69
@@ -33,7 +33,13 @@ set test_srun   "test$test_id.test_srun"
 set run_timer   2
 set exit_code   0
 
-set nb_nodes [get_node_cnt_in_part]
+proc cleanup {} {
+	global bin_rm test_timer test_srun file_in
+
+	exec $bin_rm -f $test_timer $test_srun $file_in
+}
+
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {[check_config_select "linear"]} {
 	if {$nb_nodes < 2} {
 		skip "This test is incompatible with select/linear and only one node"
@@ -120,8 +126,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -139,8 +144,6 @@ if {$fini_match != $run_timer} {
 	fail "srun did not finish the program submitted ($fini_match != $run_timer)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $test_timer $test_srun $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.7 b/testsuite/expect/test1.7
index c43d76e603..b0792d00ae 100755
--- a/testsuite/expect/test1.7
+++ b/testsuite/expect/test1.7
@@ -60,8 +60,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -85,6 +84,16 @@ if {$inactive_limit < $sleep_time} {
 	log_debug "Reset job sleep time to $sleep_time seconds"
 }
 
+proc capture_debug_for_bug_10313 {} {
+	global scontrol bin_cat bin_ls slurm_dir
+
+	run_command "$scontrol show config"
+	set testsuite_dir [file dirname [info script]]
+	run_command "$bin_cat ${testsuite_dir}/globals.local"
+	run_command "ls -l ${slurm_dir}/lib/slurm"
+	run_command "stat ${slurm_dir}/lib/slurm/switch_generic.so"
+}
+
 #
 # Execute a couple of three minute jobs; one with a one minute time
 # limit and the other with a four minute time limit. Confirm jobs
@@ -100,6 +109,10 @@ set timeout [expr $max_job_delay + $sleep_time]
 set timed_out 0
 set srun_pid [spawn $srun -t1 $bin_sleep $sleep_time]
 expect {
+	-re "Incompatible Slurm plugin" {
+		capture_debug_for_bug_10313
+		exp_continue
+	}
 	-re "time limit" {
 		set timed_out 1
 		exp_continue
@@ -116,9 +129,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -154,9 +166,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.70 b/testsuite/expect/test1.70
index a370b99a00..02732e1227 100755
--- a/testsuite/expect/test1.70
+++ b/testsuite/expect/test1.70
@@ -42,8 +42,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -60,8 +59,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "diff is not responding"
-		set exit_code 1
+		fail "diff is not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.71 b/testsuite/expect/test1.71
index 753b6ec408..295ab55845 100755
--- a/testsuite/expect/test1.71
+++ b/testsuite/expect/test1.71
@@ -68,8 +68,7 @@ expect {
 		incr error_match
 	 }
 	timeout {
-		log_error "Program is not responding"
-		set exit_code 1
+		fail "Program is not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.72 b/testsuite/expect/test1.72
index d84e8d215c..66580cd242 100755
--- a/testsuite/expect/test1.72
+++ b/testsuite/expect/test1.72
@@ -53,8 +53,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -74,8 +73,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.73 b/testsuite/expect/test1.73
index 3255a61aa6..6391690923 100755
--- a/testsuite/expect/test1.73
+++ b/testsuite/expect/test1.73
@@ -34,12 +34,32 @@ set good_script     "$test_id\_good_script"
 set good_job        "$test_id\_good_job_sc"
 set bad_job         "$test_id\_bad_job_sc"
 set timeout         [expr $max_job_delay + 500]
-set exit_code       0
 
 if {![is_super_user]} {
 	skip "This test can't be run except as SlurmUser"
 }
 
+#
+# Get the slurm.conf path
+#
+set config_dir [get_conf_path]
+set config_file $config_dir/slurm.conf
+
+#
+# Copy the original slurm.conf file
+#
+save_conf $config_file
+
+proc cleanup {} {
+	global config_file
+	global bin_rm good_script bad_script good_job bad_job conf_script
+
+	# Restore the slurm.conf file back to original values
+	restore_conf $config_file
+	reconfigure
+	exec $bin_rm -f $good_script $bad_script $good_job $bad_job $conf_script
+}
+
 #
 # Slurm time limit enforcement is performed within one minute of the actual
 # job time limit, so a one minute limit job will be killed 60 to 120 seconds
@@ -58,7 +78,7 @@ echo RC=$\?
 "
 
 proc check_rc { job } {
-	global number exit_code
+	global number
 
 	set rc -1
 	spawn ./$job
@@ -68,8 +88,7 @@ proc check_rc { job } {
 			exp_continue
 		}
 		timeout {
-			log_error "echo is not responding"
-			set exit_code 1
+			fail "echo is not responding"
 		}
 		eof {
 			wait
@@ -79,19 +98,6 @@ proc check_rc { job } {
 	return $rc
 }
 
-#
-# Get the slurm.conf path
-#
-set config_dir [get_conf_path]
-fail_on_error "Unable to get config path"
-
-set config_file $config_dir/slurm.conf
-
-#
-# Copy the original slurm.conf file
-#
-save_conf $config_file
-
 #
 # Add OverTimeLimit value to slurm.conf and reconfigure
 #
@@ -99,9 +105,7 @@ make_bash_script $conf_script "$bin_echo OverTimeLimit=2 >> $config_file"
 spawn ./$conf_script
 expect {
 	-re "Permission denied" {
-		log_warn "Unable to update slurm.conf"
-		set exit_code 1
-		exp_continue
+		fail "Unable to update slurm.conf"
 	}
 	eof {
 		wait
@@ -121,7 +125,7 @@ expect {
 if {$match == 0} {
 	fail "slurm.conf was not updated"
 }
-reconfigure
+reconfigure -fail
 
 set rc [check_rc $good_job]
 if {$rc != 0} {
@@ -132,14 +136,3 @@ set rc [check_rc $bad_job]
 if {$rc == 0} {
 	fail "Bad job exit code ($rc == 0)"
 }
-
-# Restore the slurm.conf file back to original values
-restore_conf $config_file
-reconfigure
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $good_script $bad_script $good_job $bad_job
-	exec $bin_rm -f $conf_script
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.74 b/testsuite/expect/test1.74
index d761e391bf..3716fa80d1 100755
--- a/testsuite/expect/test1.74
+++ b/testsuite/expect/test1.74
@@ -94,8 +94,7 @@ proc srun_test {exp_cnt account} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun is not responding"
-			set exit_code 1
+			fail "srun is not responding"
 		}
 		eof {
 			wait
@@ -149,7 +148,7 @@ proc add_child {parent child maxnode grpnode} {
 cleanup
 
 # Setup
-set node_cnt [available_nodes "idle,alloc,comp"]
+set node_cnt [llength [get_nodes_by_state idle,alloc,comp]]
 if {$node_cnt < 3} {
 	skip "Default partition has too few nodes ($node_cnt < 3)"
 }
@@ -158,7 +157,7 @@ if {$node_cnt < 3} {
 if {[wait_for_node idle 3]} {
 	skip "Default Partition lacks 3 idle nodes"
 }
-set node_cnt [available_nodes idle]
+set node_cnt [llength [get_nodes_by_state]]
 
 # Add parent account (off root)
 if {[add_child "root" $acct -1 -1]} {
@@ -279,8 +278,6 @@ srun_test [expr $node_cnt - 1] $acct_c1
 
 srun_test [expr $node_cnt - 2] $acct_c2
 
-cleanup
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test1.75 b/testsuite/expect/test1.75
index a3f66598e5..de0ac7faed 100755
--- a/testsuite/expect/test1.75
+++ b/testsuite/expect/test1.75
@@ -46,6 +46,12 @@ array set freq_lvl_2 {
 	powersave     0
 }
 
+proc cleanup {} {
+	global bin_rm file_id file_in file_out
+
+	exec $bin_rm -f $file_id $file_in $file_out
+}
+
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "This test can't be run without AccountStorageType=slurmdbd"
 }
@@ -95,8 +101,7 @@ proc sub_job { freq } {
 				exp_continue
 			}
 			timeout {
-				log_error "srun is not responding"
-				set exit_code 1
+				fail "srun is not responding"
 			}
 			eof {
 				wait
@@ -127,8 +132,7 @@ proc sub_job { freq } {
 				exp_continue
 			}
 			timeout {
-				log_error "sacct is not responding"
-				set exit_code 1
+				fail "sacct is not responding"
 			}
 			eof {
 				wait
@@ -154,8 +158,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -197,8 +200,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -243,8 +245,6 @@ if { (($freq_lvl_1(low) > $freq_lvl_1(medium)) ||
 	fail "CPU frequency values are not valid. Test with smaller JobAcctGatherFrequency configuration or longer running jobs"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_id $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.76 b/testsuite/expect/test1.76
index 78f64485f1..6600e37971 100755
--- a/testsuite/expect/test1.76
+++ b/testsuite/expect/test1.76
@@ -34,7 +34,6 @@ source ./globals
 # - task affinity either cgroups or cpusets
 
 set nerr	0
-set exit_code	0
 set test_prog   "test$test_id.prog"
 set avail_freq	[split "1000 2000" " "]
 set nfreq	0
@@ -377,6 +376,3 @@ if {$nerr != 0} {
 } else {
 	exec $bin_rm -f $wd/test1.76.out
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.77 b/testsuite/expect/test1.77
index a2e85c07cb..533b941172 100755
--- a/testsuite/expect/test1.77
+++ b/testsuite/expect/test1.77
@@ -27,7 +27,6 @@
 ############################################################################
 source ./globals
 
-set exit_code	0
 set job_id      0
 set number      "\[0-9\]+"
 set name        "banana"
@@ -98,9 +97,7 @@ expect {
 if {$found != 1} {
 	fail "Could not find SLURM_JOB_NAME=banana"
 }
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_out
-}
+exec $bin_rm -f $file_out
 exec rm -f slurm-$job_id.out
 
 #
@@ -125,6 +122,3 @@ if {$found != 1} {
 	fail "Could not find SLURM_JOB_NAME=banana"
 }
 exec rm -f $file_in
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.8 b/testsuite/expect/test1.8
index 47d2190762..2015ab7315 100755
--- a/testsuite/expect/test1.8
+++ b/testsuite/expect/test1.8
@@ -43,6 +43,12 @@ set got_job_grps         0
 set got_login_grps       0
 set got_sleep_err        0
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 #
 # Delete left-over stdin/out/err files
 # Build stdin file
@@ -63,9 +69,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -145,17 +150,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.80 b/testsuite/expect/test1.80
index 67333c374f..ebb51466a2 100755
--- a/testsuite/expect/test1.80
+++ b/testsuite/expect/test1.80
@@ -37,7 +37,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 }
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 2 } {
 	skip "Insufficient nodes in default partition ($node_count < 2)"
 }
@@ -79,9 +79,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -144,9 +143,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.81 b/testsuite/expect/test1.81
index 5cb2edf148..428c76496f 100755
--- a/testsuite/expect/test1.81
+++ b/testsuite/expect/test1.81
@@ -33,7 +33,7 @@ source ./globals
 set exit_code   0
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 2 } {
 	skip "Insufficient nodes in default partition ($node_count < 2)"
 }
@@ -61,9 +61,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -88,9 +87,8 @@ expect {
 		set alloc_fail 1
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -124,9 +122,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -174,9 +171,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -238,9 +234,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.82 b/testsuite/expect/test1.82
index 08f507c5a2..90646264a2 100755
--- a/testsuite/expect/test1.82
+++ b/testsuite/expect/test1.82
@@ -42,7 +42,7 @@ set host_3      ""
 set node_cnt 3
 set timeout $max_job_delay
 
-set available [available_nodes idle]
+set available [llength [get_nodes_by_state]]
 if {$available < $node_cnt} {
     skip "Not enough nodes currently available ($available avail, $node_cnt needed)"
 }
@@ -197,9 +197,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.83 b/testsuite/expect/test1.83
index c70752a311..4be85ea968 100755
--- a/testsuite/expect/test1.83
+++ b/testsuite/expect/test1.83
@@ -34,15 +34,13 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 } elseif {[get_config_param "TopologyPlugin"] ne "topology/none"} {
 	skip "This test is incompatible with topology configured systems"
 }
 
-set available [available_nodes]
+set available [llength [get_nodes_by_state idle,alloc,comp]]
 if {$available < 3} {
 	skip "This test requires 3 nodes, but only $available available"
 }
diff --git a/testsuite/expect/test1.84 b/testsuite/expect/test1.84
index f8f417a6a0..67c1f96c58 100755
--- a/testsuite/expect/test1.84
+++ b/testsuite/expect/test1.84
@@ -85,8 +85,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -139,9 +138,8 @@ expect {
 		skip "Nodes have too many CPUs for test"
  	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -183,9 +181,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test1.85 b/testsuite/expect/test1.85
index 337dcf7cc8..227074791c 100755
--- a/testsuite/expect/test1.85
+++ b/testsuite/expect/test1.85
@@ -155,3 +155,7 @@ expect {
 if {[ string compare $host2 $hostname] != 0} {
 	fail "The execution hostname $hostname != $host2 requested hostname."
 }
+
+if {$exit_code != 0} {
+        fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+}
diff --git a/testsuite/expect/test1.86 b/testsuite/expect/test1.86
index cc9770649e..cc105ff9da 100755
--- a/testsuite/expect/test1.86
+++ b/testsuite/expect/test1.86
@@ -40,7 +40,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 }
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 2 } {
 	skip "Insufficient nodes in default partition ($node_count < 2)"
 }
diff --git a/testsuite/expect/test1.87 b/testsuite/expect/test1.87
index 4deef9fdd2..6516b488c8 100755
--- a/testsuite/expect/test1.87
+++ b/testsuite/expect/test1.87
@@ -38,7 +38,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 }
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 4 } {
 	skip "Insufficient nodes in default partition ($node_count < 4)"
 }
diff --git a/testsuite/expect/test1.88 b/testsuite/expect/test1.88
index d938ab90b9..5015831b72 100755
--- a/testsuite/expect/test1.88
+++ b/testsuite/expect/test1.88
@@ -35,6 +35,12 @@ set file_err           "test$test_id.error"
 set test_prog          "test$test_id.prog"
 set job_id             0
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err test_prog
+
+	exec $bin_rm -f $file_in $file_out $file_err $test_prog ${test_prog}.o
+}
+
 #
 # Test for existence of mpi compiler
 #
@@ -133,9 +139,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -143,9 +148,7 @@ expect {
 }
 
 if {$no_start != 0} {
-	if {$job_id != 0} {
-		cancel_job $job_id
-	}
+	cancel_job $job_id
 	skip "Partition too small for test"
 }
 if {$job_id == 0} {
@@ -217,9 +220,7 @@ if {[wait_for_file $file_out] == 0} {
 	set exit_code 1
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err $test_prog ${test_prog}.o
-} else {
+if {$exit_code != 0} {
 	set matches 0
 	spawn head $file_err
 	expect {
@@ -236,8 +237,6 @@ if {$exit_code == 0} {
 	} else {
 		log_debug "Check contents of $file_err"
 	}
-}
 
-if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.9 b/testsuite/expect/test1.9
index a7bd6a2723..42b709577b 100755
--- a/testsuite/expect/test1.9
+++ b/testsuite/expect/test1.9
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set tasks       0
 set task_cnt	5
 set verbosity   0
@@ -51,9 +50,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -66,6 +64,3 @@ if {$task_cnt != $tasks} {
 if {$verbosity != 1} {
 	fail "Did not report job id with verbosity on"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test1.90 b/testsuite/expect/test1.90
index 7e0e705f75..bc08f7fc5f 100755
--- a/testsuite/expect/test1.90
+++ b/testsuite/expect/test1.90
@@ -31,6 +31,12 @@ source ./globals
 set exit_code   0
 set file_prog   "test$test_id.prog"
 
+proc cleanup {} {
+	global bin_rm file_prog
+
+	exec $bin_rm -f $file_prog
+}
+
 #
 # Test if memory affinity support is supported.
 #
@@ -132,8 +138,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	-re $test_prompt {
 	}
@@ -181,8 +186,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	-re $test_prompt
 }
@@ -209,9 +213,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
-		exp_continue
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	-re $test_prompt
 }
@@ -233,8 +235,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	-re $test_prompt
 }
@@ -255,8 +256,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	-re $test_prompt
 }
@@ -284,9 +284,7 @@ while {$cpu_cnt < $task_cnt} {
 			exp_continue
 		}
 		timeout {
-			log_error "salloc not responding or failure to recognize prompt"
-			set exit_code 1
-			exp_continue
+			fail "salloc not responding or failure to recognize prompt"
 		}
 		-re $test_prompt
 	}
@@ -317,9 +315,7 @@ while {$cpu_cnt < $task_cnt} {
 			exp_continue
 		}
 		timeout {
-			log_error "salloc not responding or failure to recognize prompt"
-			set exit_code 1
-			exp_continue
+			fail "salloc not responding or failure to recognize prompt"
 		}
 		-re $test_prompt
 	}
@@ -391,9 +387,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
-		exp_continue
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	-re $test_prompt
 }
@@ -418,9 +412,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
-		exp_continue
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	-re $test_prompt
 }
@@ -445,9 +437,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
-		exp_continue
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	-re $test_prompt
 }
@@ -472,8 +462,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
+		fail "salloc not responding or failure to recognize prompt"
 		exp_continue
 	}
 	-re $test_prompt
@@ -499,9 +488,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
-		exp_continue
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	-re $test_prompt
 }
@@ -526,9 +513,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
-		set exit_code 1
-		exp_continue
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	-re $test_prompt
 }
@@ -547,18 +532,15 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "salloc not responding or failure to recognize prompt"
 		slow_kill $salloc_pid
-		set exit_code 1
+		fail "salloc not responding or failure to recognize prompt"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_prog
-} else {
+if {$exit_code != 0} {
 	fail "This test can fail if the node configuration in slurm.conf (sockets, cores, threads) differs from the actual configuration. SPANK plugins (e.g. auto-affinity.so)"
 }
 
diff --git a/testsuite/expect/test1.92 b/testsuite/expect/test1.92
index a9747cc656..293889da33 100755
--- a/testsuite/expect/test1.92
+++ b/testsuite/expect/test1.92
@@ -38,7 +38,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 }
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 2 } {
 	skip "Insufficient nodes in default partition ($node_count < 2)"
 }
diff --git a/testsuite/expect/test1.93 b/testsuite/expect/test1.93
index 85e9151c9d..f85b56c4e8 100755
--- a/testsuite/expect/test1.93
+++ b/testsuite/expect/test1.93
@@ -29,7 +29,7 @@ set exit_code   0
 set file_prog   "test$test_id.prog"
 
 proc get_cpu_bind { type name } {
-	global re_word_str exit_code scontrol
+	global re_word_str scontrol
 
 	set cpu_bind "off"
 	spawn $scontrol show $type $name
@@ -49,7 +49,7 @@ proc get_cpu_bind { type name } {
 }
 
 proc set_cpu_bind { type name cpu_bind } {
-	global exit_code scontrol
+	global scontrol
 
 	spawn $scontrol update ${type}Name=$name CpuBind=$cpu_bind
 	expect {
@@ -114,7 +114,7 @@ if {![is_super_user]} {
 }
 
 set partition [default_partition]
-set nb_nodes [get_node_cnt_in_part $partition]
+set nb_nodes [get_partition_param $partition "TotalNodes"]
 if {$nb_nodes < 2} {
 	skip "Need 2 or more nodes in default partition"
 }
diff --git a/testsuite/expect/test1.94 b/testsuite/expect/test1.94
index a8dfab187d..49b2bca879 100755
--- a/testsuite/expect/test1.94
+++ b/testsuite/expect/test1.94
@@ -36,6 +36,14 @@ set server_prog        "test$test_id.server"
 set client_prog        "test$test_id.client"
 set job_id             0
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err server_prog client_prog
+
+	exec $bin_rm -f $file_in $file_out $file_err
+	exec $bin_rm -f $server_prog ${server_prog}.o
+	exec $bin_rm -f $client_prog ${client_prog}.o
+}
+
 #
 # Test for existence of mpi compiler
 #
@@ -57,8 +65,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -107,9 +114,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -117,9 +123,7 @@ expect {
 }
 
 if {$no_start != 0} {
-	if {$job_id != 0} {
-		cancel_job $job_id
-	}
+	cancel_job $job_id
 	skip "Partition too small for test"
 }
 if {$job_id == 0} {
@@ -169,11 +173,7 @@ if {[wait_for_file $file_out] == 0} {
 	set exit_code 1
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-	exec $bin_rm -f $server_prog ${server_prog}.o
-	exec $bin_rm -f $client_prog ${client_prog}.o
-} else {
+if {$exit_code != 0} {
 	set matches 0
 	spawn head $file_err
 	expect {
@@ -190,8 +190,6 @@ if {$exit_code == 0} {
 	} else {
 		log_debug "Check contents of $file_err"
 	}
-}
 
-if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.95 b/testsuite/expect/test1.95
index a890472d52..3c61bc9452 100755
--- a/testsuite/expect/test1.95
+++ b/testsuite/expect/test1.95
@@ -26,7 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code          0
 set file_in            "test$test_id.input"
 set file_out           "test$test_id.output"
 set file_err           "test$test_id.error"
@@ -35,6 +34,12 @@ set job_id             0
 set task_cnt           2
 set thread_cnt         4
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err test_prog
+
+	exec $bin_rm -f $file_in $file_out $file_err $test_prog ${test_prog}.o
+}
+
 #
 # Test for existence of UPC compiler
 #
@@ -92,9 +97,7 @@ expect {
 }
 
 if {$no_start != 0} {
-	if {$job_id != 0} {
-		cancel_job $job_id
-	}
+	cancel_job $job_id
 	skip "Partition too small for test"
 }
 if {$job_id == 0} {
@@ -143,9 +146,3 @@ if {[wait_for_file $file_out] == 0} {
 } else {
 	fail "Output file for job ($job_id) did not get created"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err $test_prog ${test_prog}.o
-} else {
-	fail "Check contents of $file_err\n"
-}
diff --git a/testsuite/expect/test1.96 b/testsuite/expect/test1.96
index a639d4f4a3..303dbb9f8a 100755
--- a/testsuite/expect/test1.96
+++ b/testsuite/expect/test1.96
@@ -34,6 +34,12 @@ set test_prog          "test$test_id.prog"
 set job_id             0
 set task_cnt           8
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err test_prog
+
+	exec $bin_rm -f $file_in $file_out $file_err $test_prog ${test_prog}.o
+}
+
 if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 } elseif {![file exists $oshcc]} {
@@ -83,9 +89,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -93,9 +98,7 @@ expect {
 }
 
 if {$no_start != 0} {
-	if {$job_id != 0} {
-		cancel_job $job_id
-	}
+	cancel_job $job_id
 	skip "Partition too small for test"
 }
 if {$job_id == 0} {
@@ -135,12 +138,7 @@ if {[wait_for_file $file_out] == 0} {
 	set exit_code 1
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err $test_prog ${test_prog}.o
-} else {
-	log_debug "Check contents of $file_err"
-}
-
 if {$exit_code != 0} {
+	log_debug "Check contents of $file_err"
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.97 b/testsuite/expect/test1.97
index 9ee1136c71..0e05de9991 100755
--- a/testsuite/expect/test1.97
+++ b/testsuite/expect/test1.97
@@ -37,6 +37,12 @@ set file_in      "test$test_id\_sc"
 array set nodes {}
 array set tasks {}
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 # some systems take a while to run the | sort -V | uniq -c stuff
 set timeout 60
 
@@ -49,8 +55,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 }
 
 proc check_node_config { } {
-
-	global scontrol nodelist sys_homo number exit_code
+	global scontrol nodelist sys_homo number
 
 	set match 0
 	set low 0
@@ -74,8 +79,7 @@ proc check_node_config { } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -95,7 +99,6 @@ proc check_node_config { } {
 }
 
 proc check_tasks_all {ntaskspn tasks} {
-
 	global scontrol exit_code
 
 	array set ntasks $tasks
@@ -113,7 +116,6 @@ proc check_tasks_all {ntaskspn tasks} {
 }
 
 proc check_tasks_off {ntaskspn tasks offset} {
-
 	global scontrol exit_code
 
 	array set ntasks $tasks
@@ -135,7 +137,6 @@ proc check_tasks_off {ntaskspn tasks offset} {
 }
 
 proc check_cpu_all {nodes job_cpus ncpus} {
-
 	global scontrol exit_code
 
 	array set nnodes $nodes
@@ -149,8 +150,7 @@ proc check_cpu_all {nodes job_cpus ncpus} {
 				exp_continue
 			}
 			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
+				fail "scontrol is not responding"
 			}
 			eof {
 				wait
@@ -165,7 +165,6 @@ proc check_cpu_all {nodes job_cpus ncpus} {
 }
 
 proc check_cpu_off {nodes job_cpus ncpus} {
-
 	global scontrol exit_code
 
 	array set nnodes $nodes
@@ -179,8 +178,7 @@ proc check_cpu_off {nodes job_cpus ncpus} {
 				exp_continue
 			}
 			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
+				fail "scontrol is not responding"
 			}
 			eof {
 				wait
@@ -195,8 +193,7 @@ proc check_cpu_off {nodes job_cpus ncpus} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -210,8 +207,7 @@ proc check_cpu_off {nodes job_cpus ncpus} {
 }
 
 proc submit_cpu {ntasks ncpus} {
-
-	global srun bin_printenv nodelist exit_code num_nodes tasks nodes
+	global srun bin_printenv nodelist num_nodes tasks nodes
 	global bin_bash number re_word_str wait_for_job
 	global bin_sort bin_uniq
 
@@ -231,8 +227,7 @@ proc submit_cpu {ntasks ncpus} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun is not responding"
-			set exit_code 1
+			fail "srun is not responding"
 		}
 		eof {
 			wait
@@ -245,8 +240,7 @@ proc submit_cpu {ntasks ncpus} {
 }
 
 proc submit_tasks {ntasks ntaskpn} {
-
-	global srun bin_printenv nodelist exit_code num_nodes tasks nodes bin_bash
+	global srun bin_printenv nodelist num_nodes tasks nodes bin_bash
 	global number re_word_str
 	global bin_sort bin_uniq
 
@@ -266,8 +260,7 @@ proc submit_tasks {ntasks ntaskpn} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun is not responding"
-			set exit_code 1
+			fail "srun is not responding"
 		}
 		eof {
 			wait
@@ -280,7 +273,7 @@ proc submit_tasks {ntasks ntaskpn} {
 }
 
 ######################## Test Starts Here ########################
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 3} {
 	skip "This test requires at least 3 nodes in the cluster"
 }
@@ -296,8 +289,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -321,8 +313,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -367,8 +358,6 @@ check_tasks_off $ntaskpn [array get tasks] 1
 submit_tasks [expr $ntask -2] $ntaskpn
 check_tasks_off $ntaskpn [array get tasks] 2
 
-if {$exit_code == 0} {
-	exec $bin_rm $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test1.99 b/testsuite/expect/test1.99
index 2a8bead389..423326960f 100755
--- a/testsuite/expect/test1.99
+++ b/testsuite/expect/test1.99
@@ -27,13 +27,13 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
 set chk_ports    [get_config_param "SrunPortRange"]
 set cwd          "[$bin_pwd]"
 set port_dir     "test$test_id\_port_conf"
 set config_path  ""
 set file_in      "test$test_id\_sc"
 set tmp_job      "test$test_id\_tmp_job"
+set job_id       0
 array set ports {}
 
 if {![is_super_user]} {
@@ -59,11 +59,20 @@ if {[expr $ports(1) - $ports(0)] < 5} {
 # Copy the slurm.conf file
 #
 set config_path [get_conf_path]
-fail_on_error "Test failed due to previous errors (\$exit_code = $exit_code)"
 set config_file $config_path/slurm.conf
-
 save_conf $config_file
 
+proc cleanup {} {
+	global bin_rm file_in tmp_job job_id config_file
+
+	exec $bin_rm -f $file_in $tmp_job
+	cancel_job $job_id
+
+	# Clean up vestigial files and restore original slurm.conf file
+	restore_conf $config_file
+	reconfigure
+}
+
 ### Check that SrunPortRange in scontrol show config and slurm.conf match ###
 log_info "---Checking SrunPortRange in slurm.conf and scontrol show conf---"
 
@@ -75,8 +84,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "cat is not responding"
-		set exit_code 1
+		fail "cat is not responding"
 	}
 	eof {
 		wait
@@ -91,8 +99,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -100,8 +107,7 @@ expect {
 }
 
 if {[string compare $show_config_range $slurm_conf_range]} {
-	log_error "SrunPortRange from scontrol show config does not match what is in slurm.conf"
-	set exit_code 1
+	fail "SrunPortRange from scontrol show config does not match what is in slurm.conf"
 }
 
 set range [split $slurm_conf_range -]
@@ -132,8 +138,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -141,8 +146,7 @@ expect {
 }
 
 if {$out_of_range != 0} {
-	log_error "srun has exceeded the allowed port range"
-	set exit_code 1
+	fail "srun has exceeded the allowed port range"
 }
 
 #
@@ -151,36 +155,33 @@ if {$out_of_range != 0} {
 exec $bin_sed -i "s/SrunPortRange=$slurm_conf_range/#SrunPortRange=$slurm_conf_range/Ig" $config_file
 exec $bin_echo SrunPortRange=$ports(0)-[expr $ports(0) + 5] > $config_path/$port_dir
 exec $bin_echo include $config_path/$port_dir >> $config_file
-reconfigure
+reconfigure -fail
 
 ###### Check that srun produces an error when all ports are exhausted ######
 log_info "---Checking srun error when ports are exhausted---"
 
 make_bash_script $tmp_job "$srun -t1 sleep 10"
 
-set tmp_id 0
 spawn $sbatch -N1 -o/dev/null -t1 $tmp_job
 expect {
 	-re "Submitted batch job ($number)" {
-		set tmp_id $expect_out(1,string)
+		set job_id $expect_out(1,string)
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$tmp_id == 0} {
+if {$job_id == 0} {
 	fail "Job was not submitted"
 }
 
-if {[wait_for_job $tmp_id "RUNNING"] != 0} {
-	log_error "Error waiting for job $tmp_id to start"
-	set exit_code 1
+if {[wait_for_job $job_id "RUNNING"] != 0} {
+	fail "Error waiting for job $job_id to start"
 }
 set match 0
 spawn $srun -t1 sleep 10
@@ -191,8 +192,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -200,18 +200,5 @@ expect {
 }
 
 if {$match != 1} {
-	log_error "srun should have failed due to exhausted ports but did not"
-	set exit_code 1
-}
-
-cancel_job $tmp_id
-
-# Clean up vestigial files and restore original slurm.conf file
-restore_conf $config_file
-reconfigure
-
-if {$exit_code == 0} {
-	exec $bin_rm $file_in $tmp_job
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+	fail "srun should have failed due to exhausted ports but did not"
 }
diff --git a/testsuite/expect/test12.1 b/testsuite/expect/test12.1
index 2878177f79..cc305154ba 100755
--- a/testsuite/expect/test12.1
+++ b/testsuite/expect/test12.1
@@ -30,7 +30,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 set not_support 0
 
@@ -64,8 +63,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacct not responding"
-		set exit_code 1
+		fail "sacct not responding"
 	}
 	eof {
 		wait
@@ -78,7 +76,3 @@ if {$not_support != 0} {
 if {$matches != 3} {
 	fail "sacct --help failed ($matches != 3)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test12.10 b/testsuite/expect/test12.10
index 3ae8ee4177..10e148687c 100755
--- a/testsuite/expect/test12.10
+++ b/testsuite/expect/test12.10
@@ -26,7 +26,6 @@
 
 source ./globals
 
-set exit_code   0
 set timeout     60
 set ntest       0
 
@@ -211,7 +210,7 @@ exec $bin_sleep 2
 # Start a long job (will be cancelled)
 # Test job will depend on it to test non-eligible
 #
-set def_node [get_idle_node_in_part]
+set def_node [lindex [get_nodes_by_state] 0]
 set pid_depend [spawn $sbatch -t5 -w $def_node --exclusive -J queue-test$test_id --output=/dev/null --error=/dev/null --wrap "$bin_sleep 300"]
 expect {
 	-re "Submitted batch job ($number)" {
@@ -238,7 +237,7 @@ wait_for_job $jobid_dependent "RUNNING"
 # Start a long job (will be cancelled)
 # Test job will wait until this job, to test eligible
 #
-set def_node [get_idle_node_in_part]
+set def_node [lindex [get_nodes_by_state] 0]
 set pid_queue [spawn $sbatch -t5 -w $def_node --exclusive -J queue-test$test_id --output=/dev/null --error=/dev/null --wrap "$bin_sleep 300"]
 expect {
 	-re "Submitted batch job ($number)" {
@@ -2534,6 +2533,3 @@ log_info "Failures : $failures"
 if {$failures != 0} {
 	fail "Test failed due to previous failures (\$failures = $failures)"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test12.2 b/testsuite/expect/test12.2
index d1de500767..a82ddf16c6 100755
--- a/testsuite/expect/test12.2
+++ b/testsuite/expect/test12.2
@@ -28,15 +28,20 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-set file_in     "test$test_id.input"
-set file_out    "test$test_id.output"
-set file_err    "test$test_id.error"
-set file_prog   "test$test_id.prog"
-set file_name   "/tmp/test$test_id.filename"
+set file_in     "$test_name.input"
+set file_out    "$test_name.output"
+set file_err    "$test_name.error"
+set file_prog   "$test_name.prog"
+set file_stem   "$test_name"
 set job_id      0
 set matches     0
 
+proc cleanup {} {
+	global file_prog file_in file_out file_err file_stem
+
+	exec rm -f $file_prog $file_in $file_out $file_err $file_stem.read $file_stem.write
+}
+
 # job parameters
 set mem_size    102400
 set sleep_time  32
@@ -46,7 +51,19 @@ set num_tasks   3
 set max_time_error 5
 set max_mem_error 4300
 set step_id	0
+set job_mem_limit [expr ($mem_size + $max_mem_error)  / 1024 + 10]
+
+# Expected values in sacct
+set expected_state    "FAILED"
+set expected_ret_code $ret_code
+if {[get_config_param "KillOnBadExit"] == 1} {
+	set expected_state "CANCELLED"
+	set expected_ret_code "0:15"
+}
 
+#
+# Check requirements
+#
 if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
@@ -54,187 +71,125 @@ set accounting_storage_enforce [get_config_param "AccountingStorageEnforce"]
 if {[param_contains $accounting_storage_enforce "nosteps"] || [param_contains $accounting_storage_enforce "nojobs"]} {
 	skip "This test can not be run with nosteps or nojobs (AccountingStorageEnforce)"
 }
+if {[get_config_param JobAcctGatherType] != "jobacct_gather/linux" &&
+    [get_config_param JobAcctGatherType] != "jobacct_gather/cgroup"} {
+	skip "Job accounting information not gathered on this system"
+}
+if {[get_config_param AccountingStorageType] == "accounting_storage/none"} {
+	skip "Job accounting information not stored on this system"
+}
+
+set nodes [get_nodes_by_request "-n$num_tasks --mem-per-cpu=$job_mem_limit -t2"]
+if {![llength $nodes]} {
+	skip "Unable to test with current node configuration"
+}
 
 proc _get_mem {prog} {
 	global float number mem_size job_id step_id max_mem_error num_tasks
 
+	set result   [list]
 	set mem_used -1
 	set mem_task -1
 	set ave_used -1
-	set exit_code 0
-
-	spawn $prog --noheader -p --job=$job_id.$step_id --format \
-		    maxrss,maxrsstask,averss --noconvert
-	expect {
-		-re "($number).($number).($number)" {
-			set mem_used  $expect_out(1,string)
-			set mem_task  $expect_out(2,string)
-			set ave_used  $expect_out(3,string)
+	set prog_base [file rootname [file tail $prog]]
 
-			set mem_used [scale_to_ks $mem_used ""]
-			set ave_used [scale_to_ks $ave_used ""]
+	set output [run_command_output -fail "$prog --noheader -p --job=$job_id.$step_id --format maxrss,maxrsstask,averss --noconvert"]
 
-			exp_continue
-		}
-		timeout {
-			log_error "$prog not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
+	dict set subtest cond [regexp "($number).($number).($number)" $output - mem_used mem_task ave_used]
+	dict set subtest desc "$prog_base should provide the right output format"
+	dict set subtest diag "$output"
+	lappend result $subtest
+	if {![dict get $subtest cond]} {
+		return $result
 	}
 
-	if { $exit_code } {
-		return 1
-	}
+	set mem_used [scale_to_ks $mem_used ""]
+	set ave_used [scale_to_ks $ave_used ""]
 
-	if { $mem_used == -1 } {
-		log_error "$prog stat memory not found"
-		return 1
-	} elseif { $mem_task != 0 } {
-		log_error "$prog stat memory task not zero"
-		return 1
-	} elseif { ($ave_used * $num_tasks) < $mem_used } {
-		log_error "$prog stat ave memory not believable against max memory"
-		return 1
-	}
-	# Compute error in KB
-	set diff_mem [expr $mem_used - $mem_size]
-	set error_mem [expr abs($diff_mem)]
-	if {($mem_used < $mem_size) || ($error_mem > $max_mem_error)} {
-		log_error [format "%s memory use discrepancy of %s KB (wanted %s KB, got %s KB)" \
-			   $prog $diff_mem $mem_size $mem_used]
-		return 1
-	} else {
-		log_info [format "%s memory use discrepancy of %s KB" $prog $error_mem]
-	}
-	return 0
+	dict set subtest cond [tolerance $mem_size $mem_used "+$max_mem_error"]
+	dict set subtest desc "$prog_base should provide MaxRSS close and bigger than $mem_size"
+	dict set subtest diag "$mem_used not in tolerance values of $mem_size"
+	lappend result $subtest
+
+	dict set subtest cond [expr {$mem_used <= ($ave_used * $num_tasks)}]
+	dict set subtest desc "$prog_base should provide MaxrRSS <= AveRSS * num_tasks"
+	dict set subtest diag "$mem_used > $ave_used * $num_tasks"
+	lappend result $subtest
+
+	return $result
 }
 
 # Check the job written and read file size.
 proc _get_file_size {prog} {
 	global number float job_id step_id file_size
 
+	set result          [list]
 	set max_disk_write  -1
 	set ave_disk_write  -1
 	set max_disk_read   -1
 	set ave_disk_read   -1
-
-	spawn $prog --noheader -p --job=$job_id.$step_id --format \
-		    MaxDiskWrite,AveDiskWrite,MaxDiskRead,AveDiskRead,MaxDiskWriteTask,MaxDiskReadTask \
-		    --noconvert
-	expect {
-		-re  "($float)(\[MGT\]*).($float)(\[MGT\]*).($float)(\[MGT\]*).($float)(\[MGT\]*).($number).($number)" {
-			set max_disk_write    $expect_out(1,string)
-			set scale1            $expect_out(2,string)
-			set ave_disk_write    $expect_out(3,string)
-			set scale2            $expect_out(4,string)
-			set max_disk_read     $expect_out(5,string)
-			set scale3            $expect_out(6,string)
-			set ave_disk_read     $expect_out(7,string)
-			set scale4            $expect_out(8,string)
-			set w_task            $expect_out(9,string)
-			set r_task            $expect_out(10,string)
-
-			set max_disk_write [scale_to_megs $max_disk_write \
-							  $scale1]
-			set ave_disk_write [scale_to_megs $ave_disk_write \
-							  $scale2]
-			set max_disk_read  [scale_to_megs $max_disk_read  \
-							  $scale3]
-			set ave_disk_read  [scale_to_megs $ave_disk_read  \
-							  $scale4]
-		}
-		timeout {
-			log_error "$prog not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-
-	set mb_file_size [ expr ($file_size/(1024 * 1024)) ]
-	if { $max_disk_write == -1 } {
-		log_error "MaxDiskWrite not reported"
-		return 1
-	}
-	if { $ave_disk_write == -1 } {
-		log_error "AveDiskWrite not reported"
-		return 1
-	}
-	if { $max_disk_read == -1 } {
-		log_error "MaxDiskRead not reported"
-		return 1
-	}
-	if { $ave_disk_read == -1 } {
-		log_error "AveDiskRead not reported"
-		return 1
-	}
-	if { $w_task != 1 } {
-		log_error "MaxDiskWriteTask not 1"
-		return 1
-	}
-	if { $r_task != 2 } {
-		log_error "MaxDiskReadTask not 2"
-		return 1
-	}
-
-	# Compute error in MB
-	set diff_io [expr $max_disk_write - $max_disk_read]
-	set error_io [expr abs($diff_io)]
-	if { $error_io > 0.3 } {
-		log_error [format "written file size does not match read size file_size:%s MB max_disk_write:%s MB max_disk_read:%s MB" \
-			   $mb_file_size $max_disk_write $max_disk_read]
-		return 1
-	}
-
-	set diff_io [expr $ave_disk_write - $ave_disk_read]
-	set error_io [expr abs($diff_io)]
-	if { $error_io > 0.3 } {
-		log_error [format "average written file size does not match average read size file_size:%s MB ave_disk_write:%s MB ave_disk_read:%s MB" \
-			   $mb_file_size $ave_disk_write $ave_disk_read]
-		return 1
-	}
-
-	log_info [format "%s reported correct written and read file size (file_size:%s MB max_disk_write:%s MB max_disk_read:%s MB)" \
-		  $prog $mb_file_size $max_disk_write $max_disk_read]
-
-	return 0
+	set prog_base [file rootname [file tail $prog]]
+
+	set output [run_command_output -fail "$prog --noheader -p --job=$job_id.$step_id --format MaxDiskWrite,AveDiskWrite,MaxDiskRead,AveDiskRead,MaxDiskWriteTask,MaxDiskReadTask --noconvert"]
+
+	dict set subtest cond [regexp "($float)(\[MGT\]*).($float)(\[MGT\]*).($float)(\[MGT\]*).($float)(\[MGT\]*).($number).($number)" $output \
+			       - \
+			       max_disk_write scale1 \
+			       ave_disk_write scale2 \
+			       max_disk_read  scale3 \
+			       ave_disk_read  scale4 \
+			       w_task r_task]
+	dict set subtest desc "$prog_base should provide the right output format"
+	dict set subtest diag "$output"
+	lappend result $subtest
+	if {![dict get $subtest cond]} {
+		return $result
+	}
+
+	set max_disk_write [scale_to_megs $max_disk_write $scale1]
+	set ave_disk_write [scale_to_megs $ave_disk_write $scale2]
+	set max_disk_read  [scale_to_megs $max_disk_read  $scale3]
+	set ave_disk_read  [scale_to_megs $ave_disk_read  $scale4]
+
+	dict set subtest cond [expr {$w_task == 1}]
+	dict set subtest desc "$prog_base should provide MaxDiskWriteTask equal to 1"
+	dict set subtest diag "$w_task != 1"
+	lappend result $subtest
+
+	dict set subtest cond [expr {$r_task == 2}]
+	dict set subtest desc "$prog_base should provide MaxDiskReadTask equal to 2"
+	dict set subtest diag "$r_task != 2"
+	lappend result $subtest
+
+	dict set subtest cond [tolerance $max_disk_write $max_disk_read "0.3"]
+	dict set subtest desc "$prog_base should provide MaxDiskWrite close to MaxDiskRead with 0.3 tolerance"
+	dict set subtest diag "$max_disk_write is too different from $max_disk_read"
+	lappend result $subtest
+
+	dict set subtest cond [tolerance $ave_disk_write $ave_disk_read "0.3"]
+	dict set subtest desc "$prog_base should provide AveDiskWrite close to AveDiskRead with 0.3 tolerance"
+	dict set subtest diag "$ave_disk_write is too different from $ave_disk_read"
+	lappend result $subtest
+
+	return $result
 }
 
-#
-# Check if accounting is enabled
-#
-set supported_gather  0
-set supported_storage 1
-log_user 0
-spawn $scontrol show config
-expect {
-	-re "AccountingStorageType *= accounting_storage/none" {
-		set supported_storage 0
-		exp_continue
-	}
-	-re "JobAcctGatherType *= jobacct_gather/linux" {
-		set supported_gather 1
-		exp_continue
-	}
-	-re "JobAcctGatherType *= jobacct_gather/cgroup" {
-		set supported_gather 1
-		exp_continue
+proc wait_and_subtest {test prog} {
+	set all_passed false
+	wait_for -timeout 15 {$all_passed} {
+		set result [$test $prog]
+
+		set all_passed true
+		foreach subtest $result {
+			if {![dict get $subtest cond]} {
+				set all_passed false
+			}
+		}
 	}
-	eof {
-		wait
+	foreach subtest $result {
+		subtest [dict get $subtest cond] [dict get $subtest desc] [dict get $subtest diag]
 	}
 }
-log_user 1
-if {$supported_gather == 0} {
-	skip "Job accounting information not gathered on this system"
-}
-if {$supported_storage == 0} {
-	skip "Job accounting information not stored on this system"
-}
 
 #
 # Delete left-over program and rebuild it
@@ -246,227 +201,80 @@ exec $bin_cc -o $file_prog ${file_prog}.c
 exec $bin_chmod 700 $file_prog
 
 make_bash_script $file_in "
-    $srun ./$file_prog $ret_code $sleep_time $mem_size $file_size $file_name
+    $srun ./$file_prog $ret_code $sleep_time $mem_size $file_size $file_stem
 "
 
+# Create a file to read
+set fd [open ${file_stem}.read "wb"]
+for {set i 0} {$i < $file_size} {incr i} {
+    puts -nonewline $fd [binary format n $i]
+}
+close $fd
+
 #
 # Run a simple job
 # Usage: test12.2.prog <exit_code> <sleep_secs> <mem_kb>
-# <file_size> <file_name>
+# <file_size> <file_stem>
 #
 set config_prob 0
 set timeout [expr $max_job_delay + $sleep_time]
-set job_mem_limit [expr ($mem_size + $max_mem_error)  / 1024 + 10]
-set sbatch_pid [spawn $sbatch -n$num_tasks --mem-per-cpu=$job_mem_limit \
-			      --output=$file_out --error=$file_err -t2 \
-			      $file_in]
-expect {
-	-re "Requested node configuration is not available" {
-		set config_prob 1
-		exp_continue
-	}
-	-re "Submitted batch job ($number)" {
-		set job_id $expect_out(1,string)
-		exp_continue
-	}
-	timeout {
-		slow_kill $sbatch_pid
-		fail "srun not responding"
-	}
-	eof {
-		wait
-	}
-}
-if {$config_prob != 0} {
-	skip "Unable to test with current node configuration"
-}
-if {$job_id == 0} {
-	fail "Batch submit failure"
-}
+set job_id [submit_job -fail "-n$num_tasks --mem-per-cpu=$job_mem_limit --output=$file_out --error=$file_err -t2 $file_in"]
 
 #
 # Wait for job to run
 #
-if {[wait_for_job $job_id "RUNNING"] != 0} {
-	log_error "waiting for job to run"
-	set exit_code 1
+if {[wait_for_job $job_id "RUNNING"]} {
+	fail "job never run"
 }
 
-# Wait for data to get logged
-exec $bin_sleep 15
-
-if {[_get_mem $sstat] != 0} {
-	set exit_code 1
-}
-
-if {[_get_file_size $sstat] != 0} {
-	set exit_code 1
-}
+wait_and_subtest _get_mem       $sstat
+wait_and_subtest _get_file_size $sstat
 
 #
 # Wait for job to complete
 #
 if {[wait_for_job $job_id "DONE"] != 0} {
-	log_error "waiting for job to complete"
-	set exit_code 1
+	fail "job never end"
 }
 
-#
-# Wait for accounting data to be propagated to slurmdbd
-#
-sleep 10
+wait_and_subtest _get_mem       $sacct
+wait_and_subtest _get_file_size $sacct
 
-set expected_state "FAILED"
-if {[get_config_param "KillOnBadExit"] == 1} {
-	set expected_state "CANCELLED"
-	set ret_code "0:15"
-}
 #
 # Report basic sacct info
 #
-spawn $sacct --noheader -P --job=$job_id.$step_id --format \
-	     jobid,jobname,state,exitcode --starttime=00:00
-expect {
-	-re "$job_id\\.$step_id" {
-		incr matches
-		exp_continue
-	}
-	-re "$file_prog" {
-		incr matches
-		exp_continue
-	}
-	-re "$expected_state" {
-		incr matches
-		exp_continue
-	}
-	-re "COMPLETING" {
-		log_warn "Step in completing state rather than $expected_state"
-		incr matches
-		exp_continue
-	}
-	-re "$ret_code" {
-		incr matches
-		exp_continue
-	}
-	timeout {
-		log_error "sacct not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-
-if {$matches < 4} {
-	log_error "sacct reporting failed ($matches < 4)"
-	set exit_code 1
+set output "COMPLETING"
+wait_for -fail {![regexp "COMPLETING" $output]} {
+	set output [run_command_output "$sacct --noheader -P --job=$job_id.$step_id --format jobid,jobname,state,exitcode --starttime=00:00"]
 }
+subtest {[regexp "$job_id\\.$step_id.$file_prog.$expected_state.$expected_ret_code" $output]} "sacct should report $job_id\\.$step_id.$file_prog.$expected_state.$expected_ret_code" "$output"
 
 #
 # Report the sacct accounting info
-# Note we load each digit of seconds individually to avoid this error:
-#   expected integer but got "08" (looks like invalid octal number)
 #
-set elapsed_time 0
-spawn $sacct --noheader -P --job=$job_id.$step_id --format elapsed \
-	     --starttime=00:00
-expect {
-	-re "($number):($number):(\[0-9\])(\[0-9\])" {
-		set hours $expect_out(1,string)
-		set mins $expect_out(2,string)
-		set sec_ten $expect_out(3,string)
-		set sec_one $expect_out(4,string)
-		set secs [expr $sec_ten * 10 + $sec_one]
-		set elapsed_time [expr ($hours * 3600) + ($mins * 60) + $secs]
-		exp_continue
-	}
-	timeout {
-		log_error "sacct not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-set diff_time [expr $elapsed_time - $sleep_time]
-set error_time [expr abs($diff_time)]
-if {$error_time > $max_time_error} {
-	log_error [format "sacct elapsed time discrepancy of %s secs. Wanted %s secs, got %s secs" \
-		   $error_time $sleep_time $elapsed_time]
-	set exit_code 1
-} else {
-	log_info "sacct elapsed time discrepancy of $error_time secs"
-}
-
-set total_cpu 0
-spawn $sacct --noheader -P --job=$job_id.$step_id --format totalcpu \
-	     --starttime=00:00
-# Ignore the milliseconds portion
-expect {
-	-re "($number):(\[0-9\])(\[0-9\])" {
-		set mins $expect_out(1,string)
-		set sec_ten $expect_out(2,string)
-		set sec_one $expect_out(3,string)
-		set secs [expr $sec_ten * 10 + $sec_one]
-		set total_cpu [expr ($mins * 60) + $secs]
-		exp_continue
-	}
-	timeout {
-		log_error "sacct not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-if {$total_cpu > $sleep_time} {
-	log_error [format "sacct reported an impossible TotalCPU time of %s secs Has to be less than %s secs!" \
-		   $total_cpu $sleep_time]
-	set exit_code 1
-} else {
-	log_info [format "sacct TotalCPU time looks reasonable (%s seconds)" \
-		  $total_cpu]
-}
-
-set min_cpu 0
-spawn $sacct --noheader -P --job=$job_id.$step_id --format mincpu \
-	     --starttime=00:00
-expect {
-	-re "($number):($number):(\[0-9\])(\[0-9\])" {
-		set hours $expect_out(1,string)
-		set mins $expect_out(2,string)
-		set sec_ten $expect_out(3,string)
-		set sec_one $expect_out(4,string)
-		set secs [expr $sec_ten * 10 + $sec_one]
-		set min_cpu [expr ($hours * 3600) + ($mins * 60) + $secs]
-		exp_continue
-	}
-	timeout {
-		log_error "sacct not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-if {$min_cpu > $sleep_time} {
-	log_error [format "sacct reported an impossible MinCPU time of %s secs. Has to be less than %s secs!" \
-		   $min_cpu $sleep_time]
-	set exit_code 1
-} else {
-	log_info "sacct MinCPU time looks reasonable ($min_cpu seconds)"
-}
-
-if {[_get_mem $sacct] != 0} {
-	set exit_code 1
-}
-
-if {[_get_file_size $sacct] != 0} {
-	set exit_code 1
-}
-
-if {$exit_code == 0} {
-	exec rm -f $file_prog $file_in $file_out $file_err $file_name
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
+set hours 0
+set mins 0
+set secs 0
+set output [run_command_output "$sacct --noheader -P --job=$job_id.$step_id --format elapsed --starttime=00:00"]
+set matches [scan $output "%d:%d:%d" hours mins secs]
+set value  [expr ($hours * 3600) + ($mins * 60) + $secs]
+subtest {$matches == 3} "sacct should report the elapsed time in the format HH:MM:SS" "$output"
+subtest {[tolerance $sleep_time $value +$max_time_error]} "Elapsed time reported by sacct should be close to $sleep_time" "$value too different from $sleep_time"
+
+set hours 0
+set mins 0
+set secs 0
+set output [run_command_output "$sacct --noheader -P --job=$job_id.$step_id --format totalcpu --starttime=00:00"]
+set matches [scan $output "%d:%d.%d" mins secs msecs]
+set value  [expr ($mins * 60) + $secs]
+subtest {$matches == 3} "sacct should report the TotalCPU time in the format MM:SS.sss" "$output"
+subtest {$value <= $sleep_time} "TotalCPU reported by sacct should be less than $sleep_time secs" "$value > $sleep_time"
+
+set hours 0
+set mins 0
+set secs 0
+set output [run_command_output "$sacct --noheader -P --job=$job_id.$step_id --format mincpu --starttime=00:00"]
+set matches [scan $output "%d:%d:%d" hours mins secs]
+set value  [expr ($hours * 3600) + ($mins * 60) + $secs]
+subtest {$matches == 3} "sacct should report the MinCPU time in the format HH:MM:SS" "$output"
+subtest {$value <= $sleep_time} "MinCPU reported by sacct should be less than $sleep_time secs" "$value > $sleep_time"
diff --git a/testsuite/expect/test12.2.prog.c b/testsuite/expect/test12.2.prog.c
index 1f58d92120..92478a7df4 100644
--- a/testsuite/expect/test12.2.prog.c
+++ b/testsuite/expect/test12.2.prog.c
@@ -1,6 +1,6 @@
  /*****************************************************************************\
  *  test12.2.prog.c - Simple test program for Slurm regression test12.2.
- *  Usage: test12.2.prog <exit_code> <sleep_secs> <mem_kb>
+ *  Usage: test12.2.prog <exit_code> <sleep_secs> <mem_kb> <file_size> <file_stem>
  *****************************************************************************
  *  Copyright (C) 2005 The Regents of the University of California.
  *  Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
@@ -43,13 +43,15 @@ main (int argc, char **argv)
 	long long int file_size;
 	int fd;
 	char *mem = NULL;
-	char *file_name;
+	char *file_stem;
+	char file_read_path[64];
+	char file_write_path[64];
 	time_t time_start = time(NULL);
 	int size, rank;
 
 	if (argc != 6) {
 		fprintf(stderr,
-			"Usage: %s <exit_code> <sleep_time> <mem_kb> <file_size>\n",
+			"Usage: %s <exit_code> <sleep_time> <mem_kb> <file_size> <file_stem>\n",
 			argv[0]);
 		exit(1);
 	}
@@ -58,7 +60,9 @@ main (int argc, char **argv)
 	sleep_time = atoi(argv[2]);
 	mem_kb     = atoi(argv[3]);
 	file_size  = atoll(argv[4]);
-	file_name  = argv[5];
+	file_stem  = argv[5];
+	sprintf(file_read_path, "%s.read", file_stem);
+	sprintf(file_write_path, "%s.write", file_stem);
 
 	rank = atoi(getenv("SLURM_PROCID"));
 
@@ -80,7 +84,7 @@ main (int argc, char **argv)
 		 * test, don't use stdio for the same reason, it
 		 * allocates memory.
 		 */
-		fd = open(file_name, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR);
+		fd = open(file_write_path, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR);
 		n = file_size/sizeof(int);
 
 		for (i = 0; i < n; i++) {
@@ -94,11 +98,11 @@ main (int argc, char **argv)
 	}
 
 	if (rank == 2) {
-		sleep(5);
-		fd = open(file_name, O_RDONLY, S_IRUSR|S_IWUSR);
+		fd = open(file_read_path, O_RDONLY, S_IRUSR|S_IWUSR);
 		n = file_size/sizeof(int);
+		int j = 0;
 		for (i = 0; i < n; i++) {
-			if (read(fd, &i, sizeof(int)) != sizeof(int)) {
+			if (read(fd, &j, sizeof(int)) != sizeof(int)) {
 				fprintf(stderr, "FAILURE: read error\n");
 				exit(1);
 			}
diff --git a/testsuite/expect/test12.3 b/testsuite/expect/test12.3
index a953b3dfc1..88ac6fadc1 100755
--- a/testsuite/expect/test12.3
+++ b/testsuite/expect/test12.3
@@ -34,9 +34,10 @@ source ./inc12.3.1
 source ./inc12.3.2
 
 set exit_code   0
+set job_id_1    0
+set job_id_2    0
 set job_name_1  "JOB1"
 set job_name_2  "JOB2"
-set job_name_3  "JOB3"
 set file_in     "test.$test_id.input"
 set test_acct	"slurm_test-account.1"
 set step_id	0
@@ -59,11 +60,39 @@ if {[string compare [get_admin_level] "Administrator"]} {
 #
 # Make sure we have enough nodes to test functionality
 #
-set partition [default_partition]
-set node_count [get_node_cnt_in_part $partition]
-if { $node_count < 3 } {
-	skip "System must have at least 3 nodes to run this test on.  This system only has $node_count"
+set nodes [get_nodes_by_request "-N3"]
+if {[llength $nodes] != 3} {
+	skip "This test requires to be able to run a job on as least 3 nodes"
 }
+lassign $nodes node1 node2 node3
+
+set config_dir [get_conf_path]
+save_conf $config_dir/slurmdbd.conf
+
+proc cleanup {} {
+	global sacctmgr test_acct config_dir
+
+	# TODO: Temporarily dump database on subtest failure to debug bug 9681 (restore once fixed)
+	global _subtest_fail_count slurm_dir
+	set username [get_my_user_name]
+	set hostname [string trimright [run_command_output "hostname -s"]]
+	if {$hostname eq "knl2" && $username eq "jenkins" && $_subtest_fail_count > 0} {
+		set dbd_dict [get_config -dbd]
+		set database_user [dict get $dbd_dict "StorageUser"]
+		set database_host [dict get $dbd_dict "StorageHost"]
+		set database_port [dict get $dbd_dict "StoragePort"]
+		set database_name [dict get $dbd_dict "StorageLoc"]
+		run_command "mysqldump -u $database_user -h $database_host -P $database_port $database_name > $slurm_dir/log/slurmdb.sql"
+	}
+
+	run_command "$sacctmgr -i delete account $test_acct"
+	restore_conf $config_dir/slurmdbd.conf
+	run_command "$sacctmgr reconfigure"
+}
+
+# Add slurmdbd job query logging to troubleshoot bug 9681
+run_command "$bin_echo DebugFlags=DB_JOB >> $config_dir/slurmdbd.conf"
+run_command "$sacctmgr reconfigure"
 
 #
 # Identify the user and his current default account
@@ -101,9 +130,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $sadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -119,9 +147,8 @@ if {$aamatches != 1} {
 set sadd_pid [spawn $sacctmgr -i create user name=$user_name account=$test_acct]
 expect {
 	 timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $sadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -131,23 +158,18 @@ expect {
 #
 # Submit two slurm jobs to capture job info
 #
-set job_id_1 0
 set job_1_node_inx 0
-set job_1_node(0) "TBD"
-set job_1_node(1) "TBD"
 set timeout $max_job_delay
-set srun_pid [spawn $srun -N2 -t1 -A $test_acct -J $job_name_1 -v $bin_id]
+set srun_pid [spawn $srun -N2 -w$node1,$node2 -t1 -A $test_acct -J $job_name_1 -v $bin_id]
 expect {
 	-re "launching ($number)\\.$step_id on host ($re_word_str)," {
 		set job_id_1 $expect_out(1,string)
-		set job_1_node($job_1_node_inx) $expect_out(2,string)
 		incr job_1_node_inx
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -159,25 +181,20 @@ if {$job_1_node_inx != 2} {
 }
 
 #
-# Second job explicitly excludes node zero from previous job
+# Second job includes one node from the first job and another different node
 #
-set job_id_2 0
 set job_2_node_inx 0
-set job_2_node(0) "TBD"
-set job_2_node(1) "TBD"
-set srun_pid [spawn $srun -N2 -x $job_1_node(0) -t1 -A $test_acct -J $job_name_2 -v $bin_id]
+set srun_pid [spawn $srun -N2 -w$node2,$node3 -t1 -A $test_acct -J $job_name_2 -v $bin_id]
 expect {
 
 	-re "launching ($number)\\.$step_id on host ($re_word_str)," {
 		set job_id_2 $expect_out(1,string)
-		set job_2_node($job_2_node_inx) $expect_out(2,string)
 		incr job_2_node_inx
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -188,53 +205,16 @@ if {$job_2_node_inx != 2} {
 	set exit_code 1
 }
 
-#
-# Third job explicitly excludes node 1 from previous job
-#
-set job_id_3 0
-set job_3_node_inx 0
-set job_3_node(0) "TBD"
-set job_3_node(1) "TBD"
-set srun_pid [spawn $srun -w$job_1_node(0),$job_2_node(1) -t1 -A $test_acct -J $job_name_3 -v $bin_id]
-expect {
-
-	-re "launching ($number)\\.$step_id on host ($re_word_str)," {
-		set job_id_3 $expect_out(1,string)
-		set job_3_node($job_3_node_inx) $expect_out(2,string)
-		incr job_3_node_inx
-		exp_continue
-	}
-	timeout {
-		log_error "srun not responding"
-		slow_kill $srun_pid
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-if {$job_3_node_inx != 2} {
-	log_error "srun host count bad ($job_3_node_inx != 2)"
-	set exit_code 1
-}
-
 #
 # Wait for accounting data to be propagated to slurmdbd
 #
-if {[wait_for_command $sacct "-A 'slurm_test-account.1' --name=$job_name_1
-                              -X -n -P -j $job_id_1 -o jobid,jobname" \
-                              "$job_id_1.$job_name_1"]} {
-	set exit_code 1
-}
-if {[wait_for_command $sacct "-A 'slurm_test-account.1' --name=$job_name_2
-                              -X -n -P -j $job_id_2 -o jobid,jobname" \
-                              "$job_id_2.$job_name_2"]} {
-	set exit_code 1
+# Displaying start and end times to troubleshoot bug 9681
+#
+if [wait_for_command_match "$sacct -A 'slurm_test-account.1' --name=$job_name_1 -X -n -P -j $job_id_1 -o jobid,jobname,start,end" "$job_id_1.$job_name_1"] {
+	fail "Accounting data for job 1 ($job_id_1) not propogated to slurmdbd"
 }
-if {[wait_for_command $sacct "-A 'slurm_test-account.1' --name=$job_name_3
-                              -X -n -P -j $job_id_3 -o jobid,jobname" \
-                              "$job_id_3.$job_name_3"]} {
-	set exit_code 1
+if [wait_for_command_match "$sacct -A 'slurm_test-account.1' --name=$job_name_2 -X -n -P -j $job_id_2 -o jobid,jobname,start,end" "$job_id_2.$job_name_2"] {
+	fail "Accounting data for job 2 ($job_id_2) not propogated to slurmdbd"
 }
 
 # Only run these sub-tests if we haven't failed already
@@ -244,33 +224,8 @@ if {$exit_code == 0} {
 	#
 	inc12_3_1 $job_id_1 $job_id_2 $job_name_1 $job_name_2 $test_acct
 
-	inc12_3_2 $job_id_1 $job_id_2 $job_id_3 $job_name_1 $job_name_2   \
-	          $test_acct $job_1_node(0) $job_1_node(1) $job_2_node(0) \
-	          $job_2_node(1)
-}
-
-#
-# Use sacctmgr to delete the test account
-#
-set damatches 0
-set sadel_pid [spawn $sacctmgr -i delete account $test_acct]
-expect {
-	-re "Deleting account" {
-		incr damatches
-		exp_continue
-	}
-	timeout {
-		log_error "sacctmgr delete not responding"
-		slow_kill $sadel_pid
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-if {$damatches != 1} {
-	log_error "sacctmgr had a problem deleting account"
-	set exit_code 1
+	inc12_3_2 $job_id_1 $job_id_2 $job_name_1 $job_name_2 $test_acct \
+		$node1 $node2 $node3
 }
 
 if {$exit_code != 0} {
diff --git a/testsuite/expect/test12.4 b/testsuite/expect/test12.4
index a849685cf5..d7fbe027a1 100755
--- a/testsuite/expect/test12.4
+++ b/testsuite/expect/test12.4
@@ -87,9 +87,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $sadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -105,9 +104,8 @@ if {$aamatches != 1} {
 set sadd_pid [spawn $sacctmgr -i create user name=$user_name account=$test_acct cluster=$cluster]
 expect {
 	 timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $sadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -126,8 +124,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -145,8 +142,7 @@ if {$job_id == 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -176,8 +172,8 @@ if {$accounting_storage_type eq "accounting_storage/slurmdbd"} {
 
 proc sacct_job { soption job_id} {
 	global sacct accounting_storage_type
+
 	set debug       0
-	set exit_code   0
 	set matches     0
 	set not_support 0
 	set total_opts "$sacct -$soption -X -p --starttime=00:00 -j $job_id"
@@ -201,8 +197,7 @@ proc sacct_job { soption job_id} {
 				exp_continue
 			}
 			timeout {
-				log_error "sacct not responding"
-				set exit_code 1
+				fail "sacct not responding"
 			}
 			eof {
 				wait
@@ -257,8 +252,7 @@ proc sacct_job { soption job_id} {
 				exp_continue
 			}
 			timeout {
-				log_error "sacct not responding"
-				set exit_code 1
+				fail "sacct not responding"
 			}
 			eof {
 				wait
@@ -299,8 +293,7 @@ proc sacct_job { soption job_id} {
 				exp_continue
 			}
 			timeout {
-				log_error "sacct not responding"
-				set exit_code 1
+				fail "sacct not responding"
 			}
 			eof {
 				wait
@@ -330,8 +323,7 @@ proc sacct_job { soption job_id} {
 				exp_continue
 			}
 			timeout {
-				log_error "sacct not responding"
-				set exit_code 1
+				fail "sacct not responding"
 			}
 			eof {
 				wait
@@ -361,8 +353,7 @@ proc sacct_job { soption job_id} {
 				exp_continue
 			}
 			timeout {
-				log_error "sacct not responding"
-				set exit_code 1
+				fail "sacct not responding"
 			}
 			eof {
 				wait
@@ -402,8 +393,7 @@ proc sacct_job { soption job_id} {
 				exp_continue
 			}
 			timeout {
-				log_error "sacct not responding"
-				set exit_code 1
+				fail "sacct not responding"
 			}
 			eof {
 				wait
@@ -431,8 +421,8 @@ proc sacct_job { soption job_id} {
 
 proc sacct_vargs { soption vargs job_id} {
 	global sacct
+
 	set debug       0
-	set exit_code   0
 	set matches     0
 	set not_support 0
 	set total_opts "$sacct -$soption $vargs -X -p -j $job_id"
@@ -461,8 +451,7 @@ proc sacct_vargs { soption vargs job_id} {
 				exp_continue
 			}
 			timeout {
-				log_error "sacct not responding"
-				set exit_code 1
+				fail "sacct not responding"
 			}
 			eof {
 				wait
@@ -493,9 +482,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $sadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -511,9 +499,8 @@ if {$aamatches != 1} {
 set sadd_pid [spawn $sacctmgr -i create user name=$user_name account=$test_acct cluster=$cluster]
 expect {
 	 timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $sadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -531,8 +518,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -550,8 +536,7 @@ if {$job_id == 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -691,9 +676,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test12.5 b/testsuite/expect/test12.5
index 268812ecf0..a0f0405f3b 100755
--- a/testsuite/expect/test12.5
+++ b/testsuite/expect/test12.5
@@ -54,7 +54,6 @@ if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"}
 proc sacct_job { soption } {
 	global sacct
 	set debug       0
-	set exit_code   0
 	set matches     0
 	set not_support 0
 	log_debug "Sacct $soption"
@@ -76,8 +75,7 @@ proc sacct_job { soption } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacct not responding"
-			set exit_code 1
+			fail "sacct not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test12.7 b/testsuite/expect/test12.7
index eac5e284e5..7da5fc0ada 100755
--- a/testsuite/expect/test12.7
+++ b/testsuite/expect/test12.7
@@ -283,7 +283,7 @@ if {$canc_count != 1} {
 set run_count [check_sacct_states "RUNNING" 0]
 # The requeued job and its batch step should now be running.
 if {$run_count != 2} {
-	endit 1 "Bad RUNNING count ($run_count != 1)"
+	endit 1 "Bad RUNNING count ($run_count != 2)"
 }
 log_info "So far, so good"
 
@@ -318,7 +318,7 @@ if {$req_count != 1} {
 # The first and second batch steps should both show CANCELLED
 set canc_count [check_sacct_states "CANCELLED" 0]
 if {$canc_count != 2} {
-	endit 1 "Bad CANCELLED count ($canc_count != 1)"
+	endit 1 "Bad CANCELLED count ($canc_count != 2)"
 }
 set pend_count [check_sacct_states "PENDING" 0]
 if {$pend_count != 1} {
@@ -349,12 +349,12 @@ if {$req_count != 1} {
 }
 set canc_count [check_sacct_states "CANCELLED" 0]
 if {$canc_count != 2} {
-	endit 1 "Bad CANCELLED count ($canc_count != 1)"
+	endit 1 "Bad CANCELLED count ($canc_count != 2)"
 }
 # The job and its batch step should be RUNNING
 set run_count [check_sacct_states "RUNNING" 0]
 if {$run_count != 2} {
-	endit 1 "Bad RUNNING count ($run_count != 1)"
+	endit 1 "Bad RUNNING count ($run_count != 2)"
 }
 log_info "So far, so good"
 
@@ -377,7 +377,7 @@ if {$req_count != 1} {
 }
 set canc_count [check_sacct_states "CANCELLED" 0]
 if {$canc_count != 2} {
-	endit 1 "Bad CANCELLED count ($canc_count != 1)"
+	endit 1 "Bad CANCELLED count ($canc_count != 2)"
 }
 set comp_count [check_sacct_states "COMPLETED" 0]
 if {$comp_count != 2} {
diff --git a/testsuite/expect/test12.8 b/testsuite/expect/test12.8
index 47229c19b5..e464c144ea 100755
--- a/testsuite/expect/test12.8
+++ b/testsuite/expect/test12.8
@@ -31,6 +31,12 @@ set exit_code     0
 set job_id        0
 set file_in       "test$test_id\_sc"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 set accounting_storage_enforce [get_config_param "AccountingStorageEnforce"]
 if {[param_contains $accounting_storage_enforce "nosteps"] || [param_contains $accounting_storage_enforce "nojobs"]} {
 	skip "This test can not be run with nosteps or nojobs (AccountingStorageEnforce)"
@@ -51,8 +57,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -82,8 +87,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacct is not responding"
-		set exit_code 1
+		fail "sacct is not responding"
 	}
 	eof {
 		wait
@@ -103,8 +107,6 @@ if {$failed_cnt != 2 || $timeout_cnt != 1} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test12.9 b/testsuite/expect/test12.9
index 0dadf4e8bb..b77f4a1ccc 100755
--- a/testsuite/expect/test12.9
+++ b/testsuite/expect/test12.9
@@ -26,7 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code	0
 set timeout	60
 
 #
@@ -97,8 +96,7 @@ expect {
 		fail "sbatch did not submit jobs"
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -112,18 +110,19 @@ expect {
 		log_debug "Job $array2_job_id was submitted"
 	}
 	-re "error" {
-		fail "Sbatch did not submit jobs"
+		fail "sbatch did not submit jobs"
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {[expect_extern_step]} {
+# If PrologFlags=contain is in slurm.conf, then an "extern" step will be
+# launched on each node, so we need to check for 3 steps per job instead of 2.
+if {[param_contains [get_config_param "PrologFlags"] "Contain"]} {
 	set expected_steps 3
 } else {
 	set expected_steps 2
@@ -150,7 +149,3 @@ run_sacct "$array1_job_id,$array2_job_id\_3" [expr $expected_steps * 6] $expecte
 
 # Now test sacct one task from the first array and the second full
 run_sacct "$array1_job_id\_2,$array2_job_id" $expected_steps [expr $expected_steps * 6]
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test13.1 b/testsuite/expect/test13.1
index 3d136af25d..5ec2f51e26 100755
--- a/testsuite/expect/test13.1
+++ b/testsuite/expect/test13.1
@@ -51,8 +51,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test14.1 b/testsuite/expect/test14.1
index 0cfde1dfca..c836369427 100755
--- a/testsuite/expect/test14.1
+++ b/testsuite/expect/test14.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 if {[get_config_param "FrontendName"] ne "MISSING"} {
@@ -46,8 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbcast not responding"
-		set exit_code 1
+		fail "sbcast not responding"
 	}
 	eof {
 		wait
@@ -57,6 +55,3 @@ expect {
 if {$matches != 1} {
 	fail "sbcast failed to report usage format"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test14.10 b/testsuite/expect/test14.10
index d53bc477e5..f971947d61 100755
--- a/testsuite/expect/test14.10
+++ b/testsuite/expect/test14.10
@@ -28,7 +28,6 @@ source ./globals
 
 set file_in1   "test$test_id.in1"
 set file_in2   "test$test_id.in2"
-set exit_code  0
 set job_id     0
 set hostlist   ""
 set node1      ""
@@ -118,8 +117,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc is not responding"
-		set exit_code 1
+		fail "salloc is not responding"
 	}
 	eof {
 		wait
@@ -131,7 +129,3 @@ if {$job_id == 0} {
 if {$matches != 2} {
 	fail "sbcast did not copy the file to the correct nodes ($matches != 2)"
 }
-
-if {$exit_code} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test14.2 b/testsuite/expect/test14.2
index f7e7174525..d63c8cc946 100755
--- a/testsuite/expect/test14.2
+++ b/testsuite/expect/test14.2
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 if {[get_config_param "FrontendName"] ne "MISSING"} {
@@ -50,8 +49,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbcast not responding"
-		set exit_code 1
+		fail "sbcast not responding"
 	}
 	eof {
 		wait
@@ -61,6 +59,3 @@ expect {
 if {$matches != 2} {
 	fail "sbcast failed to report help message"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test14.3 b/testsuite/expect/test14.3
index f2fb49162c..fc3640e1dc 100755
--- a/testsuite/expect/test14.3
+++ b/testsuite/expect/test14.3
@@ -29,7 +29,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set version     0
 
 if {[get_config_param "FrontendName"] ne "MISSING"} {
@@ -46,9 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbcast not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbcast not responding"
 	}
 	eof {
 		wait
@@ -58,6 +55,3 @@ expect {
 if {$version != 1} {
 	fail "Did not get proper sbcast version number"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test14.4 b/testsuite/expect/test14.4
index 6ea7c9ee34..0a2517291b 100755
--- a/testsuite/expect/test14.4
+++ b/testsuite/expect/test14.4
@@ -35,6 +35,12 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set file_err    "test$test_id.error"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 set exit_code            0
 set skips                0
 set job_id               0
@@ -89,9 +95,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -133,9 +138,7 @@ if {$differ_found == 0} {
 	fail "sbcast overwrote file without --force option"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
 
diff --git a/testsuite/expect/test14.5 b/testsuite/expect/test14.5
index 68ca0106ca..d317d33aaf 100755
--- a/testsuite/expect/test14.5
+++ b/testsuite/expect/test14.5
@@ -32,6 +32,12 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set file_err    "test$test_id.error"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 set exit_code            0
 set job_id               0
 
@@ -75,9 +81,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -144,8 +149,6 @@ if {$reset == 0} {
 	fail "Did not reset file time stamp"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test14.6 b/testsuite/expect/test14.6
index d2efec8b84..d946fb881d 100755
--- a/testsuite/expect/test14.6
+++ b/testsuite/expect/test14.6
@@ -32,6 +32,12 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set file_err    "test$test_id.error"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 set exit_code            0
 set job_id               0
 
@@ -71,9 +77,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -125,8 +130,6 @@ if {$matches != 4} {
 	fail "sbcast --verbose option did not produced expected logging ($matches != 4)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test14.7 b/testsuite/expect/test14.7
index 970756b422..ee27ab9358 100755
--- a/testsuite/expect/test14.7
+++ b/testsuite/expect/test14.7
@@ -32,6 +32,12 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set file_err    "test$test_id.error"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 set exit_code            0
 set job_id               0
 
@@ -39,7 +45,9 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
 
-stop_root_user
+if {[get_my_uid] == 0} {
+	skip "This test can't be run as user root"
+}
 
 # Delete left-over stdout/err files
 file delete $file_out $file_err
@@ -63,9 +71,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -117,8 +124,6 @@ if {$matches != 2} {
 	fail "sbcast wrote into root file system without root access ($matches)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test14.8 b/testsuite/expect/test14.8
index da1c023cec..185284b80c 100755
--- a/testsuite/expect/test14.8
+++ b/testsuite/expect/test14.8
@@ -35,6 +35,12 @@ source ./globals
 set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 set exit_code            0
 set job_id               0
 
@@ -80,9 +86,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -125,8 +130,6 @@ if {[wait_for_file $file_out] == 0} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test14.9 b/testsuite/expect/test14.9
index 4c10f2f2aa..47f645d873 100755
--- a/testsuite/expect/test14.9
+++ b/testsuite/expect/test14.9
@@ -30,6 +30,12 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set file_err    "test$test_id.error"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 set exit_code            0
 set job_id               0
 
@@ -63,9 +69,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -116,8 +121,6 @@ if {$matches != 2} {
 	fail "sbcast moved file with invalid credential ($matches)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test15.1 b/testsuite/expect/test15.1
index d3ee67d1c9..0226d50d0e 100755
--- a/testsuite/expect/test15.1
+++ b/testsuite/expect/test15.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$matches != 1} {
 	fail "salloc failed to report usage format"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test15.10 b/testsuite/expect/test15.10
index e7428cd839..31a968f074 100755
--- a/testsuite/expect/test15.10
+++ b/testsuite/expect/test15.10
@@ -53,9 +53,7 @@ for {set inx 1} {$inx < 4} {set inx [expr $inx * 2]} {
 		}
 		timeout {
 			log_error "salloc not responding"
-			if {$job_id != 0} {
-				cancel_job $job_id
-			}
+			cancel_job $job_id
 			slow_kill [expr 0 - $salloc_pid]
 			set exit_code 1
 		}
diff --git a/testsuite/expect/test15.11 b/testsuite/expect/test15.11
index cbec85dc60..260f193247 100755
--- a/testsuite/expect/test15.11
+++ b/testsuite/expect/test15.11
@@ -33,8 +33,7 @@ set job_id      0
 set job_name    "jobname$test_id"
 set name_read   ""
 
-set prio_type [priority_type]
-if {[string compare $prio_type "multifactor"] == 0} {
+if {[get_config_param "PriorityType"] eq "priority/multifactor"} {
 	skip "Not compatible with priority/multifactor"
 }
 
@@ -62,9 +61,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -100,9 +97,7 @@ expect {
         }
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 		exp_continue
diff --git a/testsuite/expect/test15.13 b/testsuite/expect/test15.13
index d1b2e39756..6d8141e67b 100755
--- a/testsuite/expect/test15.13
+++ b/testsuite/expect/test15.13
@@ -63,9 +63,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.14 b/testsuite/expect/test15.14
index 19caa1165b..54f68f53b1 100755
--- a/testsuite/expect/test15.14
+++ b/testsuite/expect/test15.14
@@ -35,6 +35,12 @@ set exit_code   0
 set job_id1     0
 set job_id2     0
 
+proc cleanup {} {
+	global bin_rm file_in1 file_in2 file_out2
+
+	exec $bin_rm -f $file_in1 $file_in2 $file_out2
+}
+
 #
 # Build input script files
 #
@@ -52,9 +58,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -76,9 +81,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -99,8 +103,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -136,8 +139,6 @@ if {[wait_for_file $file_out2] != 0} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2 $file_out2
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test15.15 b/testsuite/expect/test15.15
index aea5281304..507481249e 100755
--- a/testsuite/expect/test15.15
+++ b/testsuite/expect/test15.15
@@ -48,9 +48,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -78,9 +76,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.16 b/testsuite/expect/test15.16
index 36b2d3d841..ff870f5c65 100755
--- a/testsuite/expect/test15.16
+++ b/testsuite/expect/test15.16
@@ -49,9 +49,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -81,9 +79,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.18 b/testsuite/expect/test15.18
index 9ba65a1185..c981ee61be 100755
--- a/testsuite/expect/test15.18
+++ b/testsuite/expect/test15.18
@@ -53,9 +53,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.19 b/testsuite/expect/test15.19
index 132768a0ef..3aad0228b2 100755
--- a/testsuite/expect/test15.19
+++ b/testsuite/expect/test15.19
@@ -46,9 +46,7 @@ expect {
 		exp_continue
 	}
 	-re "(Task count specification invalid|configuration not available)" {
-		if {$job_id != 0} {
-             cancel_job $job_id
-		}
+		cancel_job $job_id
 		if {[get_config_param "FrontendName"] ne "MISSING"} {
 			skip "Error expected, Testing is incompatible with front-end systems"
 		} else {
@@ -64,9 +62,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -98,9 +94,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -141,9 +135,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -198,9 +190,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -236,7 +226,7 @@ if {$dup_host == 1} {
 }
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 2 } {
 	skip "Insufficient nodes in default partition to continue ($node_count < 2)"
 }
@@ -257,9 +247,7 @@ expect {
 		exp_continue
 	}
 	-re "salloc: error" {
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		skip "Can't test salloc task distribution"
 	}
 	-re "($number): *($re_word_str)" {
@@ -279,9 +267,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.2 b/testsuite/expect/test15.2
index c71ce4f57c..caa035f251 100755
--- a/testsuite/expect/test15.2
+++ b/testsuite/expect/test15.2
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -46,8 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -57,6 +55,3 @@ expect {
 if {$matches != 2} {
 	fail "salloc failed to report help message"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test15.20 b/testsuite/expect/test15.20
index 65aa6d569b..83ab36b1d8 100755
--- a/testsuite/expect/test15.20
+++ b/testsuite/expect/test15.20
@@ -43,7 +43,7 @@ set job_id      0
 set node_cnt 3
 set timeout $max_job_delay
 
-set available [available_nodes]
+set available [llength [get_nodes_by_state idle,alloc,comp]]
 if {$available < $node_cnt} {
     skip "Not enough nodes currently available ($available avail, $node_cnt needed)"
 }
@@ -81,9 +81,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		fail "salloc not responding"
 	}
@@ -160,9 +158,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		fail "salloc not responding"
 	}
@@ -222,9 +218,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.21 b/testsuite/expect/test15.21
index 81535052d4..1eebb1bfaf 100755
--- a/testsuite/expect/test15.21
+++ b/testsuite/expect/test15.21
@@ -33,15 +33,13 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 } elseif {[get_config_param "TopologyPlugin"] ne "topology/none"} {
 	skip "This test is incompatible with topology configured systems"
 }
 
-set available [available_nodes]
+set available [llength [get_nodes_by_state idle,alloc,comp]]
 if {$available < 3} {
 	skip "This test requires 3 nodes, but only $available available"
 }
diff --git a/testsuite/expect/test15.22 b/testsuite/expect/test15.22
index 3d10090d07..02f46dd2b9 100755
--- a/testsuite/expect/test15.22
+++ b/testsuite/expect/test15.22
@@ -53,8 +53,7 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -74,9 +73,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -136,9 +133,7 @@ expect {
 	}
 	timeout {
 		log_error "srun not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.23 b/testsuite/expect/test15.23
index a1bb285d7a..5f39d0ab2d 100755
--- a/testsuite/expect/test15.23
+++ b/testsuite/expect/test15.23
@@ -73,9 +73,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -110,9 +108,7 @@ expect {
 	}
 	timeout {
 		log_error "scontrol not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.24 b/testsuite/expect/test15.24
index d236057161..5600f9e3bf 100755
--- a/testsuite/expect/test15.24
+++ b/testsuite/expect/test15.24
@@ -28,12 +28,17 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set job_id      0
 set task_cnt	10
 
+proc cleanup {} {
+	global file_in file_out
+
+	file delete $file_in $file_out
+}
+
 #
 # Submit a slurm job that will print slurm env vars and execute 'id'
 #
@@ -67,8 +72,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -80,9 +84,3 @@ if {$matches != 2} {
 if {$task_cnt != $tasks} {
 	fail "Did not get proper number of tasks: $task_cnt, $tasks"
 }
-
-if {$exit_code == 0} {
-	file delete $file_in $file_out
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test15.25 b/testsuite/expect/test15.25
index d3fb71015c..0c824f73aa 100755
--- a/testsuite/expect/test15.25
+++ b/testsuite/expect/test15.25
@@ -35,6 +35,12 @@ set job_id2     0
 set job_acct    "TEST_ACCT"
 set job_acct_lc "test_acct"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if [param_contains [get_config_param "AccountingStorageEnforce"] "associations"] {
 	skip "This test will not work when associations are enforced"
 }
@@ -61,9 +67,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -126,8 +131,6 @@ if {$match_acct == 0} {
 	fail "Account information not processed"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test15.27 b/testsuite/expect/test15.27
index 97866ea365..5f41865752 100755
--- a/testsuite/expect/test15.27
+++ b/testsuite/expect/test15.27
@@ -51,8 +51,7 @@ proc check_alloc { } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -73,8 +72,7 @@ proc check_alloc { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacct is not responding"
-			set exit_code 1
+			fail "sacct is not responding"
 		}
 		eof {
 			wait
@@ -92,8 +90,7 @@ proc check_alloc { } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -138,8 +135,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc is not responding"
-		set exit_code 1
+		fail "salloc is not responding"
 	}
 	eof {
 		wait
@@ -159,8 +155,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc is not responding"
-		set exit_code 1
+		fail "salloc is not responding"
 	}
 	eof {
 		wait
@@ -181,8 +176,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding\n"
-		set exit_code 1
+		fail "salloc not responding\n"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test15.3 b/testsuite/expect/test15.3
index 4c2a4352b3..29aabd69cf 100755
--- a/testsuite/expect/test15.3
+++ b/testsuite/expect/test15.3
@@ -29,7 +29,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set version     0
 
 #
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$version != 1} {
 	fail "Did not get proper salloc version number"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test15.30 b/testsuite/expect/test15.30
index 41c4304146..7a713137a1 100755
--- a/testsuite/expect/test15.30
+++ b/testsuite/expect/test15.30
@@ -44,8 +44,7 @@ expect {
 		fail "Salloc is OK with a deadline too old"
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test15.31 b/testsuite/expect/test15.31
index a12c3eaaab..7434113882 100755
--- a/testsuite/expect/test15.31
+++ b/testsuite/expect/test15.31
@@ -27,20 +27,6 @@
 source ./globals
 
 set job_id	0
-set exit_code   0
-
-#
-# Since we make changes to configuration, call this function restore
-# configuration before exiting.
-#
-proc endit { } {
-	global exit_code
-	reconfigure
-	if {$exit_code != 0} {
-		fail "Exiting due to previous errors with exit code $exit_code"
-	}
-	pass
-}
 
 #
 # We must be SlurmUser or root in order to change the partition MaxTime limit,
@@ -50,13 +36,23 @@ if {![is_super_user]} {
 	skip "You must be SlurmUser or root to run this test."
 }
 
+#
+# Since we make changes to configuration, define a cleanup function to restore
+# the configuration before exiting.
+#
+proc cleanup {} {
+	global job_id
+
+	cancel_job $job_id
+	reconfigure
+}
+
 #
 # Ensure that MaxTime is UNLIMITED so this test won't fail due to trying to set
 # time limits greater than MaxTime.
 #
-set exit_code [set_partition_maximum_time_limit "" -1]
-if { $exit_code != 0 } {
-	endit
+if [set_partition_maximum_time_limit "" -1] {
+	fail "Unable to set partition MaxTime to UNLIMITED"
 }
 
 #
@@ -75,8 +71,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -97,11 +92,7 @@ if {$job_id != 0} {
 			set exit_code 1
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
-			exp_continue
+			fail "scontrol not responding"
 		}
 	}
 }
-
-endit
diff --git a/testsuite/expect/test15.32 b/testsuite/expect/test15.32
index 84f1844ce7..7132203d21 100755
--- a/testsuite/expect/test15.32
+++ b/testsuite/expect/test15.32
@@ -33,6 +33,12 @@ set authorized     1
 set exit_code      0
 set part_name      "QA_TEST"
 
+proc cleanup {} {
+	global bin_rm test_salloc file_in
+
+	exec $bin_rm $test_salloc $file_in
+}
+
 if {![is_super_user]} {
 	skip "Can not test more unless SlurmUser or root"
 }
@@ -53,8 +59,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -70,11 +75,11 @@ if {$found == 1} {
 #
 # Identify usable nodes in default partition
 #
-set def_node [get_idle_node_in_part]
+set def_node [lindex [get_nodes_by_state] 0]
 if {[string compare $def_node ""] == 0} {
 #	Wait for possible Epilog
 	sleep 10
-	set def_node [get_idle_node_in_part]
+	set def_node [lindex [get_nodes_by_state] 0]
 }
 if {[string compare $def_node ""] == 0} {
 	fail "Default partition seems to have no nodes"
@@ -91,8 +96,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -115,8 +119,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -184,9 +187,7 @@ if {[string compare $enforcepartlimits "NO"] == 0} {
 					exp_continue
 				}
 				timeout {
-					log_error "scontrol not responding"
-					set exit_code 1
-					exp_continue
+					fail "scontrol not responding"
 				}
 				eof {
 					wait
@@ -213,8 +214,7 @@ if {[string compare $enforcepartlimits "NO"] == 0} {
                         exp_continue
                 }
                 timeout {
-                        log_error "salloc not responding"
-                        set exit_code 1
+                        fail "salloc not responding"
                 }
                 eof {
                         wait
@@ -228,8 +228,7 @@ if {[string compare $enforcepartlimits "NO"] == 0} {
 spawn $scontrol delete PartitionName=$part_name
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -252,8 +251,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -263,8 +261,6 @@ if {$found != 0} {
 	fail "Partition not deleted"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm $test_salloc $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test15.33 b/testsuite/expect/test15.33
index cb9ffa088e..18d4322ebc 100755
--- a/testsuite/expect/test15.33
+++ b/testsuite/expect/test15.33
@@ -51,8 +51,7 @@ expect {
 	}
 
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -77,9 +76,7 @@ if {$job_id != 0} {
 			set exit_code 1
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
-			exp_continue
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test15.34 b/testsuite/expect/test15.34
index 596c54b63c..94a69ec4db 100755
--- a/testsuite/expect/test15.34
+++ b/testsuite/expect/test15.34
@@ -45,8 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test15.35 b/testsuite/expect/test15.35
index f0571aeac1..61fa3592de 100755
--- a/testsuite/expect/test15.35
+++ b/testsuite/expect/test15.35
@@ -29,19 +29,6 @@ source ./globals
 set exit_code   0
 set job_id      0
 
-#
-# Since we make changes to configuration, call this function restore
-# configuration before exiting.
-#
-proc endit { } {
-	global exit_code
-	reconfigure
-	if {$exit_code != 0} {
-		fail "Exiting due to previous errors with exit code $exit_code"
-	}
-	pass
-}
-
 #
 # We must be SlurmUser or root in order to change the partition MaxTime limit,
 # otherwise this test may fail.
@@ -50,13 +37,23 @@ if {![is_super_user]} {
 	skip "You must be SlurmUser or root to run this test."
 }
 
+#
+# Since we make changes to configuration, define a cleanup function to restore
+# the configuration before exiting.
+#
+proc cleanup {} {
+	global job_id
+
+	cancel_job $job_id
+	reconfigure
+}
+
 #
 # Ensure that MaxTime is UNLIMITED so this test won't fail due to trying to set
 # time limits greater than MaxTime.
 #
-set exit_code [set_partition_maximum_time_limit "" -1]
-if { $exit_code != 0 } {
-	endit
+if [set_partition_maximum_time_limit "" -1] {
+	fail "Unable to set partition MaxTime to UNLIMITED"
 }
 
 #
@@ -82,9 +79,7 @@ expect {
 	}
 }
 if {$job_id == 0} {
-	log_error "Job not submitted"
-	set exit_code 1
-	endit
+	fail "Job not submitted"
 }
 
 #
@@ -111,5 +106,3 @@ expect {
 		wait
 	}
 }
-
-endit
diff --git a/testsuite/expect/test15.36 b/testsuite/expect/test15.36
index 2debabd061..85c0574e63 100755
--- a/testsuite/expect/test15.36
+++ b/testsuite/expect/test15.36
@@ -49,8 +49,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test15.37 b/testsuite/expect/test15.37
index a94154622e..ab68cc74f5 100755
--- a/testsuite/expect/test15.37
+++ b/testsuite/expect/test15.37
@@ -3,10 +3,13 @@
 # Purpose: Test of Slurm functionality
 #          Test of --deadline and --begin option and --time_min too long
 ############################################################################
+# Copyright (C) 2020 SchedMD LLC.
+# Written by Albert Gil <albert.gil@schedmd.com>
+#
 # Copyright (C) 2015 CEA/DAM/DIF
 # Written by Aline Roy <aline.roy@cea.fr>
 #
-# This fie is part of Slurm, a resource management program.
+# This file is part of Slurm, a resource management program.
 # For details, see <https://slurm.schedmd.com/>.
 # Please also read the included file: DISCLAIMER.
 #
@@ -26,114 +29,81 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-set job_id      0
+set job_list ""
+
+proc cleanup {} {
+	global job_list
+	cancel_job $job_list
+}
+
+#
+# Get the node to use
+#
+set node [get_nodes_by_request "-N1 -t 5"]
+if {[llength $node] != 1} {
+	skip "This test needs to be able to submit a job with '-N1 -t 5'"
+}
 
 #
-# Spawn a batch job with a deadline and no time
+# Submit a blocking job
 #
-set timeout [expr $max_job_delay + 60]
-set salloc_pid [spawn $salloc --begin now+60 --deadline now+600 --time-min 10 $bin_sleep 1 ]
+set job_block [submit_job -fail "-w $node --exclusive -t 5 --wrap '$bin_sleep 300' -J $test_name -o /dev/null -e /dev/null"]
+lappend job_list $job_block
+wait_for_job $job_block "RUNNING"
+
+#
+# Submit a salloc job with deadline that will rest pending until deadlines
+#
+spawn $salloc -w $node --begin=now+5 --deadline=now+75 --time-min=1 -J $test_name $bin_sleep 300
 expect {
-	-re "Requested time limit is invalid" {
-		set exit_code 1
-		exp_continue
-	}
-	-re "Job allocation ($number) has been revoked" {
-		set job_id $expect_out(1,string)
-		set exit_code 0
-		exp_continue
-	}
 	-re "job ($number) queued and waiting for resources" {
 		set job_id $expect_out(1,string)
-		set exit_code 0
-		exp_continue
 	}
-	-re "Pending job allocation ($number)" {
-		set job_id $expect_out(1,string)
-		set exit_code 0
-		exp_continue
+	-re "Granted job allocation ($number)" {
+		fail "job granted and it shouldn't"
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
+		fail "salloc not responding"
 	}
 }
-if {$job_id == 0} {
-	fail "Batch not submitted with a deadline too short"
+lappend job_list $job_id
+
+#
+# Check that job goes from PENDING with reason BeginTime to finally
+# end with DEADLINE.
+#
+set state  ""
+set reason ""
+wait_for -timeout 10 {$state == "PENDING" && $reason == "BeginTime"} {
+	set state  [get_job_param $job_id "JobState"]
+	set reason [get_job_param $job_id "Reason"]
 }
+subtest {$state == "PENDING" && $reason == "BeginTime"} "Job should be PENDING with reason BeginTime" "JobState=$state Reason=$reason"
 
-if {[wait_for_job $job_id DONE] != 0} {
-	fail "Job failed to run to completion"
+wait_for -timeout 60 {$state == "DEADLINE" && $reason == "DeadLine"} {
+	set state  [get_job_param $job_id "JobState"]
+	set reason [get_job_param $job_id "Reason"]
 }
+subtest {$state == "DEADLINE" && $reason == "DeadLine"} "Job should end with state DEADLINE and reason DeadLine" "JobState=$state Reason=$reason"
 
 #
-# test job status in scontrol and sacct
+# Wait and check that job state reach the deadline
 #
-spawn $scontrol show job $job_id
-expect {
-	-re "JobState=DEADLINE" {
-		exp_continue
-	}
-	-re "JobState=($re_word_str)" {
-		set current_state $expect_out(1,string)
-		log_error "Invalid job state ($current_state != DEADLINE)"
-		set exit_code 1
-		exp_continue
-	}
-	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-
-set cycle_count 8
-set not_support 0
-for {set inx 0} {$inx < $cycle_count} {incr inx} {
-	spawn $sacct  -n -P -X -j $job_id -o State
-	expect {
-		-re "Slurm accounting storage is disabled" {
-			set not_support 1
-			break
-		}
-		-re "DEADLINE" {
-			set exit_code 0
-			break
-		}
-		-re "COMPLETED" {
-			log_error "Batch submitted with a deadline too short"
-			set exit_code 1
-			break
-		}
-		-re "PENDING" {
-			set exit_code 1
-			exp_continue
-		}
-		-re "CANCELLED by ($number)" {
-			log_error "Batch killed by timeout before start"
-			set exit_code 1
-			break
-		}
-		timeout {
-			log_error "sacct not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	sleep 5
+set state "PENDING"
+wait_for -timeout 60 {$state == "DEADLINE"} {
+	set state [get_job_param $job_id "JobState"]
 }
+subtest {$state == "DEADLINE"} "Job should end with state DEADLINE" "$state != DEADLINE"
 
-if {$not_support != 0} {
+#
+# Test that the state is accounted properly
+#
+if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "Can not test without accounting enabled"
 }
-if {$exit_code == 1} {
-	fail "Batch submitted with a deadline too short"
+
+set sacct_state ""
+wait_for -timeout 30 {[regexp "DEADLINE" $sacct_state]} {
+	set sacct_state [run_command_output -fail "$sacct  -n -P -X -j $job_id -o State"]
 }
+subtest {[regexp "DEADLINE" $sacct_state]} "Job should be accounted with state DEADLINE" "$sacct_state != DEADLINE"
diff --git a/testsuite/expect/test15.38 b/testsuite/expect/test15.38
index 8007d58115..65b815e76a 100755
--- a/testsuite/expect/test15.38
+++ b/testsuite/expect/test15.38
@@ -29,6 +29,16 @@ source ./globals
 set exit_code   0
 set job_id      0
 
+#
+# Ensure that default partition has a DefaultTime big enough
+#
+run_command -fail "$scontrol update partitionname=[default_partition] DefaultTime=10"
+
+proc cleanup {} {
+	# Restore DefaultTime
+	reconfigure
+}
+
 #
 # Spawn a batch job with a deadline and no time
 #
@@ -54,8 +64,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -83,8 +92,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -104,8 +112,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacct not responding"
-		set exit_code 1
+		fail "sacct not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test15.39 b/testsuite/expect/test15.39
index 5fae8888ff..06726d4bb7 100755
--- a/testsuite/expect/test15.39
+++ b/testsuite/expect/test15.39
@@ -48,8 +48,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -83,8 +82,7 @@ expect {
 		}
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test15.4 b/testsuite/expect/test15.4
index e8652fc55f..5c8a04a9ef 100755
--- a/testsuite/expect/test15.4
+++ b/testsuite/expect/test15.4
@@ -62,9 +62,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.5 b/testsuite/expect/test15.5
index 56a3ffe0c0..83a53f06c6 100755
--- a/testsuite/expect/test15.5
+++ b/testsuite/expect/test15.5
@@ -34,6 +34,12 @@ set exit_code   0
 set file_in     "test$test_id.input"
 set job_id      0
 
+proc cleanup {} {
+	global file_in
+
+	file delete $file_in
+}
+
 # NOTE: If you increase sleep_time, change job time limits as well
 set sleep_time  180
 
@@ -60,8 +66,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -125,9 +130,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -156,9 +159,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -170,8 +171,6 @@ if {$completions != 1} {
 	fail "Job failed to complete properly ($completions)"
 }
 
-if {$exit_code == 0} {
-	file delete $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test15.6 b/testsuite/expect/test15.6
index 8fcf592fd0..69bfce5503 100755
--- a/testsuite/expect/test15.6
+++ b/testsuite/expect/test15.6
@@ -64,9 +64,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.7 b/testsuite/expect/test15.7
index 557d5e1ba2..78f6b1c115 100755
--- a/testsuite/expect/test15.7
+++ b/testsuite/expect/test15.7
@@ -54,9 +54,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -111,8 +109,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test15.8 b/testsuite/expect/test15.8
index 7b0d0cdf5e..97476fd83a 100755
--- a/testsuite/expect/test15.8
+++ b/testsuite/expect/test15.8
@@ -55,9 +55,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -92,9 +90,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test15.9 b/testsuite/expect/test15.9
index 050e942ce6..46b7099250 100755
--- a/testsuite/expect/test15.9
+++ b/testsuite/expect/test15.9
@@ -64,9 +64,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
diff --git a/testsuite/expect/test16.1 b/testsuite/expect/test16.1
index 3db6b6c9c3..7be52f460b 100755
--- a/testsuite/expect/test16.1
+++ b/testsuite/expect/test16.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sattach not responding"
-		set exit_code 1
+		fail "sattach not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$matches != 1} {
 	fail "sattach failed to report usage format"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test16.2 b/testsuite/expect/test16.2
index 53c646a875..76f0f5738e 100755
--- a/testsuite/expect/test16.2
+++ b/testsuite/expect/test16.2
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sattach not responding"
-		set exit_code 1
+		fail "sattach not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$matches != 1} {
 	fail "sattach failed to report help message"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test16.3 b/testsuite/expect/test16.3
index 55f737c7a9..cd3a9d1d50 100755
--- a/testsuite/expect/test16.3
+++ b/testsuite/expect/test16.3
@@ -29,7 +29,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set version     0
 
 #
@@ -42,9 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sattach not responding"
-		set exit_code 1
-		exp_continue
+		fail "sattach not responding"
 	}
 	eof {
 		wait
@@ -54,6 +51,3 @@ expect {
 if {$version != 1} {
 	fail "Did not get proper sattach version number"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test16.4 b/testsuite/expect/test16.4
index 98a00fb7e8..f422690777 100755
--- a/testsuite/expect/test16.4
+++ b/testsuite/expect/test16.4
@@ -34,6 +34,12 @@ set file_prog   "test$test_id.prog"
 set job_id      0
 set matches     0
 
+proc cleanup {} {
+	global bin_rm file_prog
+
+	exec $bin_rm -f $file_prog
+}
+
 if {[get_config_param "LaunchType"] ne "launch/slurm"} {
 	skip "This test is only compatible with systems using launch/slurm"
 }
@@ -68,9 +74,7 @@ expect {
 	}
 	timeout {
 		log_error "salloc not responding"
-		if {$job_id != 0} {
-			cancel_job $job_id
-		}
+		cancel_job $job_id
 		slow_kill [expr 0 - $salloc_pid]
 		set exit_code 1
 	}
@@ -102,8 +106,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sattach not responding"
-		set exit_code 1
+		fail "sattach not responding"
 	}
 	eof {
 		wait
@@ -134,8 +137,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sattach not responding"
-		set exit_code 1
+		fail "sattach not responding"
 	}
 	eof {
 		wait
@@ -167,8 +169,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sattach not responding"
-		set exit_code 1
+		fail "sattach not responding"
 	}
 	eof {
 		wait
@@ -186,17 +187,14 @@ if {$matches != [expr $task_cnt + 1]} {
 set spawn_id $init_id
 expect {
 	timeout {
-		log_error "srun (terminate) not responding"
-		set exit_code 1
+		fail "srun (terminate) not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_prog
-} else {
+if {$exit_code != 0} {
 	cancel_job $job_id
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.1 b/testsuite/expect/test17.1
index 3de83abe49..e94eb3ff9b 100755
--- a/testsuite/expect/test17.1
+++ b/testsuite/expect/test17.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$matches != 1} {
 	fail "sbatch failed to report usage format"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test17.10 b/testsuite/expect/test17.10
index 9664b3867f..07fd7cae99 100755
--- a/testsuite/expect/test17.10
+++ b/testsuite/expect/test17.10
@@ -35,6 +35,12 @@ set exit_code   0
 set file_in     "test$test_id.input"
 set job_id      0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 set cpu_cnt     1
 set mem_size    13
 set tmp_size    2
@@ -59,9 +65,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -114,8 +118,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -127,8 +130,6 @@ if {$matches != 5} {
 if {[cancel_job $job_id] != 0} {
 	fail "Unable to cancel job ($job_id)"
 }
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.11 b/testsuite/expect/test17.11
index 1409d6bc17..a6fabe864a 100755
--- a/testsuite/expect/test17.11
+++ b/testsuite/expect/test17.11
@@ -33,6 +33,12 @@ set file_in     "test$test_id.input"
 set force_part  0
 set job_id      0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 set oversubscribe [partition_oversubscribe]
 if {[string compare $oversubscribe "FORCE"] == 0} {
 	set force_part 1
@@ -57,9 +63,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -85,8 +89,7 @@ if {$job_id != 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -166,8 +169,6 @@ if {$force_part == 0 && $match_oversubscribe != 1} {
 	fail "Did not properly set oversubscribe flag"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.12 b/testsuite/expect/test17.12
index 38b7405bfc..1cf91f782f 100755
--- a/testsuite/expect/test17.12
+++ b/testsuite/expect/test17.12
@@ -28,1004 +28,258 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-set file_in     "test$test_id.input"
-set test_part   "test$test_id\_part"
-set feat0       "test$test_id\_zero"
-set feat1       "test$test_id\_one"
-set feat2       "test$test_id\_two"
-set feat3       "test$test_id\_three"
-set feat4       "test$test_id\_four"
+set test_part   "$test_name\_part"
+set feat0       "$test_name\_feat0"
+set feat1       "$test_name\_feat1"
+set feat2       "$test_name\_feat2"
+set feat3       "$test_name\_feat3"
+set feat4       "$test_name\_feat4"
+set wrap_cmd    "--wrap='$bin_sleep 5'"
 array set nodes {}
-array set def_active_node_feat {}
-array set def_avail_node_feat  {}
 
-proc check_job_nodes {test_job node_name find_node} {
-	global exit_code sbatch test_part file_in
-	global feat0 feat1 number scontrol re_word_str bin_bash
-	global bin_grep
+proc cleanup {} {
+	global scontrol test_part
 
-	set nodelist ""
+	# Remove test partition
+	wait_for_part_done $test_part
+	run_command "$scontrol delete partition=$test_part"
 
-	if {[wait_for_job $test_job "RUNNING"] != 0} {
-		log_error "Error waiting for job $test_job to start"
-		cancel_job $test_job
-		set exit_code 1
-	}
-
-	# Check that job that the job used the correct nodes
-	log_user 0
-	spawn $scontrol show job $test_job
-	expect {
-		-re " NodeList=($re_word_str)" {
-			set nodelist $expect_out(1,string)
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
-
-	set match 0
-	spawn $bin_bash -c "$scontrol show hostnames $nodelist"
-	expect {
-		-re "$node_name" {
-			set match 1
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-
-	if {$match != $find_node} {
-		log_error "Invalid node found"
-		set exit_code 1
-	}
+	# Reset node features
+	reconfigure
 }
 
-proc check_job {nnode test_job} {
-	global exit_code sbatch test_part file_in
-	global feat0 feat1 number scontrol re_word_str bin_bash
-	global bin_grep
-
-	set nodelist ""
-
-	if {[wait_for_job $test_job "RUNNING"] != 0} {
-		log_error "Error waiting for job $test_job to start"
-		cancel_job $test_job
-		set exit_code 1
-	}
-
-	# Check that job that the job used the correct nodes
-	spawn $scontrol show job $test_job
-	expect {
-		-re " NodeList=($re_word_str)" {
-			set nodelist $expect_out(1,string)
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code
-		}
-		eof {
-			wait
-		}
-	}
-
-	set node_cnt 0
-	spawn $bin_bash -c "$scontrol show node $nodelist | $bin_grep AvailableFeatures"
-	expect {
-		-re "AvailableFeatures=$feat0|$feat1" {
-			incr node_cnt
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-
-	if {$node_cnt != $nnode} {
-		log_error "sbatch bad node count ($node_cnt != $nnode)"
-		set exit_code 1
-	}
-
-	cancel_job $test_job
+#
+# Prerequisites
+#
+if {![is_super_user] || [get_config_param "NodeFeaturesPlugins"] ne "(null)"} {
+	skip "Test needs super user and not NodeFeaturesPlugins"
 }
 
-proc sub_job_and {nnode fail_test} {
-	global exit_code sbatch test_part file_in nodes
-	global feat0 feat1 feat2 feat3 number scontrol re_word_str bin_bash
-	global bin_grep
-
-	set test_job 0
-	set fail_node_config 0
-
-	if {$fail_test} {
-		spawn $sbatch -C "$feat1&$feat3" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				set fail_node_config 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
-
-		if {$fail_node_config == $fail_test} {
-			log_debug "This error is expected, no worries"
-		}
-		if {$test_job != 0} {
-			log_error "Job should have been rejected, but was not"
-			cancel_job $test_job
-			set exit_code 1
-		}
-	} else {
-		spawn $sbatch -C "$feat2&$feat3" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				log_error "Unexpected job submit failure"
-				set exit_code 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
-
-		# Check that nodes have the correct features
-		if {$test_job == 0} {
-			log_error "Job submit failure"
-			set exit_code 1
-		} else {
-#			Make sure nodes(3) included in allocation
-			check_job_nodes $test_job $nodes(3) 1
-			check_job $nnode $test_job
-		}
-	}
+set nodelist [get_nodes_by_request "-N4 -t1"]
+if {[llength $nodelist] != 4} {
+	skip "Tests needs to be able to submit up to 4 nodes"
 }
+set nodes(0) [lindex $nodelist 0]
+set nodes(1) [lindex $nodelist 1]
+set nodes(2) [lindex $nodelist 2]
+set nodes(3) [lindex $nodelist 3]
 
-proc sub_batch_host {nnode} {
-	global exit_code sbatch scontrol test_part file_in nodes
-	global feat0 feat1 feat2 feat3 number scontrol re_word_str bin_bash
-	global bin_grep
+proc test_constrain_invalid {nnode constrain} {
+	global sbatch scontrol test_part wrap_cmd
 
+	# Submit the job
 	set test_job 0
-	set fail_node_config 0
-
-	spawn $sbatch -C "$feat0|$feat3" --batch=$feat3 -p$test_part -N$nnode -t1 -o /dev/null $file_in
-	expect {
-		-re "Submitted batch job ($number)" {
-			set test_job $expect_out(1,string)
-			exp_continue
-		}
-		-re "Requested node configuration is not available" {
-			log_error "Unexpected job submit failure"
-			set exit_code 1
-			exp_continue
-		}
-		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-
-	if {$test_job == 0} {
-		log_error "Job submit failure"
-		set exit_code 1
-	} else {
-		if {[wait_for_job $test_job "RUNNING"] != 0} {
-			log_error "Waiting for job to start"
-			set exit_code 1
-		} else {
-			set match 0
-			spawn $scontrol show job $test_job
-			expect {
-				-re "BatchHost=$nodes(3)" {
-					set match 1
-					exp_continue
-				}
-				timeout {
-					log_error "sbatch is not responding"
-					set exit_code 1
-				}
-				eof {
-					wait
-				}
-			}
-			if {$match != 1} {
-				log_error "Invalid BatchHost value"
-				set exit_code 1
-			}
-		}
-		cancel_job $test_job
-	}
+	set result [run_command -none "$sbatch -C \"$constrain\" -p$test_part -N$nnode -t1 -o /dev/null $wrap_cmd"]
+	set output [dict get $result output]
+	set rc     [dict get $result exit_code]
+	regexp {Submitted batch job (\d+)} $output - test_job
+
+	# Check expected output
+	subtest {$test_job == 0} "Job should have been rejected"
+	subtest {[regexp "Invalid feature specification" $output]} "Job should be rejected due invalid feature"
+	cancel_job $test_job
 }
 
-proc sub_job_count {nnode fail_test} {
-	global exit_code sbatch test_part file_in nodes
-	global feat0 feat1 feat2 feat3 number scontrol re_word_str bin_bash
-	global bin_grep
+proc test_constrain {nnode constrain mandatory_nodes {posible_nodes ""} {excluded_nodes ""}} {
+	global sbatch scontrol test_part wrap_cmd
 
+	# Submit the job
 	set test_job 0
-	set fail_node_config 0
-
-	if {$fail_test} {
-		spawn $sbatch -C "$feat2*$nnode" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				set fail_node_config 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
-
-		if {$fail_node_config == $fail_test} {
-			log_debug "This error is expected, no worries"
-		}
-		if {$test_job != 0} {
-			log_error "Job should have been rejected, but was not"
-			cancel_job $test_job
-			set exit_code 1
-		}
+	set result [run_command -none "$sbatch -C \"$constrain\" -p$test_part -N$nnode -t1 -o /dev/null $wrap_cmd"]
+	set output [dict get $result output]
+	set rc     [dict get $result exit_code]
+	regexp {Submitted batch job (\d+)} $output - test_job
+
+	# Check expected output
+	if {![llength $mandatory_nodes] && ![llength $posible_nodes]} {
+		subtest {$test_job == 0} "Job should have been rejected"
+		subtest {[regexp "Requested node configuration is not available" $output]} "Job should be rejected due configuration not available"
 	} else {
-		spawn $sbatch -C "$feat2*2" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				log_error "Unexpected job submit failure"
-				set exit_code 1
-				exp_continue
+		if {[subtest {$test_job != 0} "Job should be submitted"]} {
+			if {[wait_for_job $test_job "RUNNING"]} {
+				fail "Error waiting for job $test_job to start"
 			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
+
+			# Check that job that the job used the correct nodes
+			set hostslist [get_job_param $test_job "NodeList"]
+			set nodeslist [run_command_output -fail "$scontrol show hostnames $hostslist"]
+			# TODO: make nodeslist an actual list
+			subtest {[llength $nodeslist] == $nnode} "Job's NodeList should contain $nnode nodes" "[llength $nodeslist]"
+			foreach node $nodeslist {
+				subtest {[lsearch $posible_nodes $node] != -1 || [lsearch $mandatory_nodes $node] != -1} "Job's node $node should be in the expected list: $posible_nodes $mandatory_nodes"
+				subtest {[lsearch $excluded_nodes $node] == -1 } "Job's node $node should NOT be in the excluded list: $excluded_nodes"
 			}
-			eof {
-				wait
+			foreach node $mandatory_nodes {
+				subtest {[lsearch $nodeslist $node] != -1} "Node $node should be in the jobs NodeList ($nodeslist)"
 			}
 		}
-
-		# Check that nodes have the correct features
-		if {$test_job == 0} {
-			log_error "Job submit failure"
-			set exit_code 1
-		} else {
-#			Make sure nodes(2 and 3) included in allocation
-			check_job_nodes $test_job $nodes(2) 1
-			check_job_nodes $test_job $nodes(3) 1
-			check_job $nnode $test_job
-		}
 	}
+	cancel_job $test_job
 }
 
-proc sub_job_or {nnode fail_test} {
-	global exit_code sbatch test_part file_in
-	global feat0 feat1 feat2 feat3 number scontrol re_word_str bin_bash
-	global bin_grep
+proc test_constrain_batch {nnode constrain constrain_batch expected_batch_node} {
+	global sbatch scontrol test_part wrap_cmd
 
+	# Submit the job
 	set test_job 0
-	set fail_node_config 0
-
-	if {$fail_test} {
-		spawn $sbatch -C "$feat0|$feat1" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				set fail_node_config 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
-
-		if {$fail_node_config == $fail_test} {
-			log_debug "This error is expected, no worries"
-		}
-		if {$test_job != 0} {
-			log_error "Job should have been rejected, but was not"
-			cancel_job $test_job
-			set exit_code 1
-		}
-	} else {
-		spawn $sbatch -C "$feat0|$feat1" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				log_error "Unexpected job submit failure"
-				set exit_code 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
+	set result [run_command -none "$sbatch -C \"$constrain\" --batch=$constrain_batch -p$test_part -N$nnode -t1 -o /dev/null $wrap_cmd"]
+	set output [dict get $result output]
+	set rc     [dict get $result exit_code]
+	regexp {Submitted batch job (\d+)} $output - test_job
 
-		# Check that nodes have the correct features
-		if {$test_job == 0} {
-			log_error "Job submit failure"
-			set exit_code 1
-		} else {
-			check_job $nnode $test_job
+	if {[subtest {$test_job != 0} "Job should be submitted"]} {
+		if {[wait_for_job $test_job "RUNNING"] != 0} {
+			fail "Error waiting for job $test_job to start"
 		}
+		# Check that job that the job used the correct nodes
+		set batch_host [get_job_param $test_job "BatchHost"]
+		subtest {$batch_host == $expected_batch_node} "Job's batch node should be $expected_batch_node" "was $batch_host"
 	}
+	cancel_job $test_job
 }
 
-proc sub_job_or_paren {nnode fail_test} {
-	global exit_code sbatch test_part file_in nodes
-	global feat0 feat1 feat2 feat3 number scontrol re_word_str bin_bash
-	global bin_grep
+proc test_constrain_9546 {} {
+	global test_name feat0 feat1 bin_sleep test_part
 
-	set test_job 0
-	set fail_node_config 0
+	set job_id_1 [submit_job -fail  "--exclusive  -J $test_name -C $feat0 -p $test_part -o /dev/null --wrap '$bin_sleep 1000'" ]
+	set job_id_2 [submit_job -fail  "--exclusive  -J $test_name -C $feat0 -p $test_part -o /dev/null --wrap '$bin_sleep 1000'" ]
 
-    spawn $sbatch -C "($feat0|$feat1)" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-    expect {
-        -re "Submitted batch job ($number)" {
-            set test_job $expect_out(1,string)
-            exp_continue
-        }
-        -re "Requested node configuration is not available" {
-            log_error "Unexpected job submit failure"
-            set exit_code 1
-            exp_continue
-        }
-        timeout {
-            log_error "sbatch is not responding"
-            set exit_code 1
-        }
-        eof {
-            wait
-        }
-    }
-    # Check that nodes have the correct features
-    if {$test_job != 0} {
-        check_job $nnode $test_job
-    }
+	subtest {![wait_for_job $job_id_1 RUNNING]} "Job1 $job_id_1 with \"-C $feat0\" should be started"
+	subtest {![wait_for_job $job_id_2 RUNNING]} "Job2 $job_id_2 with \"-C $feat0\" should be started"
 
-    # (feat0|feat2)
-    set test_job 0
-    set nnode 3
-    spawn $sbatch -C "($feat0|$feat2)" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-    expect {
-        -re "Submitted batch job ($number)" {
-            set test_job $expect_out(1,string)
-            exp_continue
-        }
-        -re "Requested node configuration is not available" {
-            log_error "Unexpected job submit failure"
-            set exit_code 1
-            exp_continue
-        }
-        timeout {
-            log_error "sbatch is not responding"
-            set exit_code 1
-        }
-        eof {
-            wait
-        }
-    }
-    # Check that nodes have the correct features
-    if {$test_job != 0} {
-        check_job_nodes $test_job $nodes(0) 1
-        check_job_nodes $test_job $nodes(1) 0
-        check_job_nodes $test_job $nodes(2) 1
-        check_job_nodes $test_job $nodes(3) 1
-        check_job $nnode $test_job
-    }
+	set job_id_3 [submit_job -fail  "--exclusive  -J $test_name -C \'\[$feat1|$feat0\]\' -p $test_part -o /dev/null --wrap 'exit 0'" ]
+	set job_id_4 [submit_job -fail  "--exclusive  -J $test_name -C \'\[$feat1|$feat0\]\' -p $test_part -o /dev/null --wrap 'exit 0'" ]
 
-    # (feat1|feat3)
-    set test_job 0
-    set nnode 2
-    spawn $sbatch -C "($feat1|$feat3)" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-    expect {
-        -re "Submitted batch job ($number)" {
-            set test_job $expect_out(1,string)
-            exp_continue
-        }
-        -re "Requested node configuration is not available" {
-            log_error "Unexpected job submit failure"
-            set exit_code 1
-            exp_continue
-        }
-        timeout {
-            log_error "sbatch is not responding"
-            set exit_code 1
-        }
-        eof {
-            wait
-        }
-    }
-    # Check that nodes have the correct features
-    if {$test_job != 0} {
-        check_job_nodes $test_job $nodes(0) 0
-        check_job_nodes $test_job $nodes(1) 1
-        check_job_nodes $test_job $nodes(2) 0
-        check_job_nodes $test_job $nodes(3) 1
-        check_job $nnode $test_job
-    }
+	subtest {![wait_for_job $job_id_3 DONE]} "Job3 $job_id_3 with \"-C '\[$feat1|$feat0\]'\" should be completed"
+	subtest {![wait_for_job $job_id_4 DONE]} "Job4 $job_id_4 with \"-C '\[$feat1|$feat0\]'\" should be completed"
 
-    # feat0&(feat2|feat3)
-    set test_job 0
-    set nnode 2
-    spawn $sbatch -C "feat0&(feat2|feat3)" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-    expect {
-        -re "Submitted batch job ($number)" {
-            set test_job $expect_out(1,string)
-            exp_continue
-        }
-        -re "Requested node configuration is not available" {
-            log_error "Unexpected job submit failure"
-            set exit_code 1
-            exp_continue
-        }
-        timeout {
-            log_error "sbatch is not responding"
-            set exit_code 1
-        }
-        eof {
-            wait
-        }
-    }
-    # Check that nodes have the correct features
-    if {$test_job != 0} {
-        check_job_nodes $test_job $nodes(0) 0
-        check_job_nodes $test_job $nodes(1) 0
-        check_job_nodes $test_job $nodes(2) 1
-        check_job_nodes $test_job $nodes(3) 1
-        check_job $nnode $test_job
-    }
-}
+	set job_id_3 [submit_job -fail  "--exclusive  -J $test_name -C \'\[$feat0|$feat1\]\' -p $test_part -o /dev/null --wrap 'exit 0'" ]
+	set job_id_4 [submit_job -fail  "--exclusive  -J $test_name -C \'\[$feat0|$feat1\]\' -p $test_part -o /dev/null --wrap 'exit 0'" ]
 
-proc sub_job_xand {nnode fail_test} {
-	global exit_code sbatch test_part file_in nodes
-	global feat0 feat1 feat2 feat3 number scontrol re_word_str bin_bash
-	global bin_grep
-
-	set test_job 0
-	set fail_node_config 0
-
-	if {$fail_test} {
-		spawn $sbatch -C "\[($feat0&$feat3)*2&$feat1*2\]" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				set fail_node_config 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
+	subtest {![wait_for_job $job_id_3 DONE]} "Job3 $job_id_3 with \"-C '\[$feat0|$feat1\]'\" should be completed"
+	subtest {![wait_for_job $job_id_4 DONE]} "Job4 $job_id_4 with \"-C '\[$feat0|$feat1\]'\" should be completed"
 
-		if {$fail_node_config == $fail_test} {
-			log_debug "This error is expected, no worries"
-		}
-		if {$test_job != 0} {
-			log_error "Job should have been rejected, but was not"
-			cancel_job $test_job
-			set exit_code 1
-		}
-	} else {
-		spawn $sbatch -C "\[($feat0&$feat2)*2&$feat1*1\]" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				log_error "Unexpected job submit failure"
-				set exit_code 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
+	cancel_job [list $job_id_1 $job_id_2]
 
-		# Check that nodes have the correct features
-		if {$test_job == 0} {
-			log_error "Job submit failure"
-			set exit_code 1
-		} else {
-#			Make sure nodes(1, 2 and 3) included in allocation
-			check_job_nodes $test_job $nodes(1) 1
-			check_job_nodes $test_job $nodes(2) 1
-			check_job_nodes $test_job $nodes(3) 1
-			check_job $nnode $test_job
-		}
-	}
-}
+	set job_id_1 [submit_job -fail  "--exclusive  -J $test_name -C $feat1 -p $test_part -o /dev/null --wrap '$bin_sleep 1000'" ]
+	set job_id_2 [submit_job -fail  "--exclusive  -J $test_name -C $feat1 -p $test_part -o /dev/null --wrap '$bin_sleep 1000'" ]
 
-proc sub_job_xor {nnode fail_test} {
-	global exit_code sbatch test_part file_in nodes
-	global feat0 feat1 feat2 feat3 number scontrol re_word_str bin_bash
-	global bin_grep
+	subtest {![wait_for_job $job_id_1 RUNNING]} "Job1 $job_id_1 with \"-C $feat1\" should be started"
+	subtest {![wait_for_job $job_id_2 RUNNING]} "Job2 $job_id_2 with \"-C $feat1\" should be started"
 
-	set test_job 0
-	set fail_node_config 0
+	set job_id_3 [submit_job -fail  "--exclusive  -J $test_name -C \'\[$feat1|$feat0\]\' -p $test_part -o /dev/null --wrap 'exit 0'" ]
+	set job_id_4 [submit_job -fail  "--exclusive  -J $test_name -C \'\[$feat1|$feat0\]\' -p $test_part -o /dev/null --wrap 'exit 0'" ]
 
-	if {$fail_test} {
-		spawn $sbatch -C "\[$feat0|$feat1\]" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				set fail_node_config 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
+	subtest {![wait_for_job $job_id_3 DONE]} "Job3 $job_id_3 with \"-C '\[$feat1|$feat0\]'\" should be completed"
+	subtest {![wait_for_job $job_id_4 DONE]} "Job4 $job_id_4 with \"-C '\[$feat1|$feat0\]'\" should be completed"
 
-		if {$fail_node_config == $fail_test} {
-			log_debug "This error is expected, no worries"
-		}
-		if {$test_job != 0} {
-			log_error "Job should have been rejected, but was not"
-			cancel_job $test_job
-			set exit_code 1
-		}
-	} else {
-		spawn $sbatch -C "\[$feat0|$feat1\]" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				log_error "Unexpected job submit failure"
-				set exit_code 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
+	set job_id_3 [submit_job -fail  "--exclusive  -J $test_name -C \'\[$feat0|$feat1\]\' -p $test_part -o /dev/null --wrap 'exit 0'" ]
+	set job_id_4 [submit_job -fail  "--exclusive  -J $test_name -C \'\[$feat0|$feat1\]\' -p $test_part -o /dev/null --wrap 'exit 0'" ]
 
-		# Check that nodes have the correct features
-		if {$test_job == 0} {
-			log_error "Job submit failure"
-			set exit_code 1
-		} else {
-#			Make sure nodes(1) not included in allocation
-			check_job_nodes $test_job $nodes(1) 0
-			check_job $nnode $test_job
-		}
-	}
+	subtest {![wait_for_job $job_id_3 DONE]} "Job3 $job_id_3 with \"-C '\[$feat0|$feat1\]'\" should be completed"
+	subtest {![wait_for_job $job_id_4 DONE]} "Job4 $job_id_4 with \"-C '\[$feat0|$feat1\]'\" should be completed"
 }
 
-proc sub_job_and_xor {nnode fail_test} {
-	global sbatch scontrol number
-	global exit_code test_part file_in nodes
-	global feat0 feat1 feat2 feat3 feat4
-
-	set test_job 0
-	set fail_node_config 0
-
-	if {$fail_test} {
-		spawn $sbatch -C "$feat4&\[$feat1|$feat0\]" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				set fail_node_config 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
+proc set_node_feature {node_name new_feature} {
+	global scontrol
+	run_command -fail "$scontrol update node=$node_name  AvailableFeatures=$new_feature ActiveFeatures=$new_feature"
+}
 
-		if {$fail_node_config == $fail_test} {
-			log_info "This error is expected, no worries"
-		}
-		if {$test_job != 0} {
-			log_error "Job should have been rejected, but was not"
-			cancel_job $test_job
-			set exit_code 1
-		}
-	} else {
-		spawn $sbatch -C "$feat4&\[$feat1|$feat0\]" -p$test_part -N$nnode -t1 -o /dev/null $file_in
-		expect {
-			-re "Submitted batch job ($number)" {
-				set test_job $expect_out(1,string)
-				exp_continue
-			}
-			-re "Requested node configuration is not available" {
-				log_error "Unexpected job submit failure"
-				set exit_code 1
-				exp_continue
-			}
-			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
 
-		# Check that nodes have the correct features
-		if {$test_job == 0} {
-			log_error "Job submit failure"
-			set exit_code 1
-		} else {
-			# Make sure nodes(1) not included in allocation
-			check_job_nodes $test_job $nodes(1) 0
-			check_job $nnode $test_job
-		}
-	}
-}
+proc setup_4_features {} {
+	global scontrol test_part
+	global nodes nodelist feat0 feat1 feat2 feat3 feat4
 
-proc set_node_feature {node_name new_feature} {
-	global scontrol exit_code
+	log_info "Setup partition $test_part with 4 nodes with 4 features"
+	set_node_feature $nodes(0) $feat0
+	set_node_feature $nodes(1) $feat1
+	set_node_feature $nodes(2) $feat0,$feat2,$feat4
+	set_node_feature $nodes(3) $feat0,$feat2,$feat3,$feat4
 
-	spawn $scontrol update node=$node_name AvailableFeatures=$new_feature ActiveFeatures=$new_feature
-	expect {
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
+	run_command -fail "$scontrol create partition=$test_part nodes=[join $nodelist ,]"
 }
+proc setup_2_features {} {
+	global scontrol test_part
+	global nodes nodelist feat0 feat1 feat2 feat3 feat4
 
-proc clean_up {} {
-	global test_part scontrol def_active_node_feat def_avail_node_feat nodes exit_code
+	log_info "Setup partition $test_part with 4 nodes with 2 features"
+	set_node_feature $nodes(0) $feat0
+	set_node_feature $nodes(1) $feat0
+	set_node_feature $nodes(2) $feat1
+	set_node_feature $nodes(3) $feat1
 
-	spawn $scontrol delete partition=$test_part
-	expect {
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-
-	# Reset nodes back to normal
-	foreach option [array names nodes] {
-		set node $nodes($option)
-		spawn $scontrol update node=$node AvailableFeatures=$def_avail_node_feat($node) ActiveFeatures=$def_active_node_feat($node)
-		expect {
-			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
-			}
-			eof {
-				wait
-			}
-		}
-	}
+	run_command -fail "$scontrol create partition=$test_part nodes=[join $nodelist ,]"
 }
 
 #
-# Delete left-over input script
-# Build input script file
+# Main setup of 4 features on 4 nodes
 #
-exec $bin_rm -f $file_in
-make_bash_script $file_in "
-  $bin_sleep 5
-"
+setup_4_features
 
 #
-# Submit a job with invalid constraint requirement
+# Main/Generic testprocs
 #
-log_info "==========Test invalid constraints=========="
-set err_msg     0
-set timeout $max_job_delay
-spawn $sbatch -N1 --constraint=invalid,constraint -t1 -o /dev/null $file_in
-expect {
-	-re "error:.*Invalid feature specification" {
-		log_debug "This error is expected, no worries"
-		set err_msg 1
-		exp_continue
-	}
-	-re "Submitted batch job ($number)" {
-		log_error "sbatch job submitted with invalid constraint"
-		cancel_job $expect_out(1,string)
-		set exit_code 1
-		exp_continue
-	}
-	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
-	}
-	eof {
-		wait
-	}
-}
-if {$err_msg != 1} {
-	log_error "Job failed to report required error"
-	set exit_code   1
-}
-
-# Must be root and no NodeFeaturesPlugin to proceed */
-if {![is_super_user] || [get_config_param "NodeFeaturesPlugins"] ne "(null)"} {
-	exec $bin_rm -f $file_in
-	skip "Configuration not compatible with additional tests"
-}
-
-#
-# Run job to get available nodes
-#
-log_user 0
-set job_id 0
-set srun_pid [spawn $srun -N1-4 -t1 -l printenv SLURM_JOB_ID]
-expect {
-	-re "\[0-3\]: ($number)" {
-#		set nodes($i) $expect_out(1,string)
-		set job_id $expect_out(1,string)
-		exp_continue
-	}
-	timeout {
-		log_error "srun is not responding"
-		slow_kill $srun_pid
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-if {$job_id == 0} {
-	log_user 1
-	fail "Job submission failed"
-}
-
-set nodelist ""
-spawn $scontrol show job $job_id
-expect {
-	-re " NodeList=($re_word_str)" {
-		set nodelist $expect_out(1,string)
-		exp_continue
-	}
-	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-
-set i 0
-spawn $scontrol show hostnames $nodelist
-expect {
-	-re "($re_word_str)" {
-		set nodes($i) $expect_out(1,string)
-		incr i
-		exp_continue
-	}
-	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-log_user 1
-if {$i != 4} {
-	exec $bin_rm -f $file_in
-	skip "There are not enough nodes to run the remaining tests ($i != 4)"
-}
-
-set node_save 0
-foreach option [array names nodes] {
-	# Save the original features that are on the node.
-	log_user 0
-	set node $nodes($option)
-	set def_active_node_feat($node) ""
-	set def_avail_node_feat($node)  ""
-	spawn $bin_bash -c "$scontrol show node $node | $bin_grep Features"
-	expect {
-		-re "AvailableFeatures=($re_word_str)" {
-			set def_avail_node_feat($node) $expect_out(1,string)
-			incr node_save
-			exp_continue
-		}
-		-re "ActiveFeatures=($re_word_str)" {
-			set def_active_node_feat($node) $expect_out(1,string)
-			incr node_save
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
-}
-
-# Set node features for testing
-log_info "==========Set node features to test-specific values for testing=========="
-set_node_feature $nodes(0) $feat0
-set_node_feature $nodes(1) $feat1
-set_node_feature $nodes(2) $feat0,$feat2,$feat4
-set_node_feature $nodes(3) $feat0,$feat2,$feat3,$feat4
-
-# Create a test partition
-spawn $scontrol create partition=$test_part \
-    nodes=$nodes(0)\,$nodes(1)\,$nodes(2)\,$nodes(3)
-expect {
-	-re "Error" {
-		log_error "scontrol returned an error when creating a partition"
-		set exit_code 1
-	}
-	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
 
 # Test feature count logic with 2 nodes
-log_info "==========Test feature count 2 nodes=========="
-sub_job_count 2 0
+testproc test_constrain 2 $feat2*2 [list $nodes(2) $nodes(3)]
 
 # Test feature count logic with 3 nodes
-log_info "==========Test feature count 3 nodes=========="
-sub_job_count 3 0
+testproc test_constrain 3 $feat2*2 [list $nodes(2) $nodes(3)] [list $nodes(0) $nodes(1)]
 
 # Test feature count logic with 3 nodes (This is expected to fail)
-log_info "==========Test feature count 3 nodes with failure=========="
-sub_job_count 3 1
+testproc test_constrain 3 $feat2*3 [list]
 
 # Test AND with 1 node
-log_info "==========Test AND 1 node=========="
-sub_job_and 1 0
+testproc test_constrain 1 $feat2&$feat3 [list $nodes(3)]
 
 # Test AND with 1 node (This is expected to fail)
-log_info "==========Test AND 1 node with failure=========="
-sub_job_and 1 1
+testproc test_constrain 1 $feat1&$feat3 [list]
 
 # Test eXclusive AND (XAND) with 3 nodes
-log_info "==========Test XAND 3 nodes=========="
-sub_job_xand 3 0
+testproc test_constrain 3 "\[($feat0&$feat2)*2&$feat1*1\]" [list $nodes(1) $nodes(2) $nodes(3)]
 
 # Test eXclusive AND (XAND) with 3 nodes (This is expected to fail)
-log_info "==========Test XAND 3 nodes with failure=========="
-sub_job_xand 3 1
+testproc test_constrain 3 "\[($feat0&$feat3)*2&$feat1*2\]" [list]
 
 # Test eXclusive OR (XOR) with 2 nodes
-log_info "==========Test XOR 2 nodes=========="
-sub_job_xor 2 0
+testproc test_constrain 2 "\[$feat0|$feat1\]" "" [list $nodes(0) $nodes(2) $nodes(3)] [list $nodes(1)]
+# testproc sub_job_xor 2 0
 
 # Test eXclusive OR (XOR) with 3 nodes
-log_info "==========Test XOR 3 nodes=========="
-sub_job_xor 3 0
+testproc test_constrain 3 "\[$feat0|$feat1\]" "" [list $nodes(0) $nodes(2) $nodes(3)] [list $nodes(1)]
 
 # Test eXclusive OR (XOR) with 4 nodes (This is expected to fail)
-log_info "==========Test XOR 4 nodes with failure=========="
-sub_job_xor 4 1
+testproc test_constrain 4 "\[$feat0|$feat1\]" [list]
 
 # Test OR with 4 nodes
-log_info "==========Test OR 4 nodes=========="
-sub_job_or 4 0
+testproc test_constrain 4 "$feat0|$feat1" [list $nodes(0) $nodes(1) $nodes(2) $nodes(3)]
 
 # Test OR within parenthesis
-log_info "==========Test OR within parenthesis=========="
-sub_job_or_paren 4 0
+testproc test_constrain 4 "($feat0|$feat1)" "" [list $nodes(0) $nodes(1) $nodes(2) $nodes(3)]
+testproc test_constrain 3 "($feat0|$feat2)" [list $nodes(0) $nodes(2) $nodes(3)] [list $nodes(1)]
+testproc test_constrain 2 "($feat1|$feat3)" [list $nodes(1) $nodes(3)] [list $nodes(0) $nodes(2)]
+testproc test_constrain 2 "$feat0&($feat2|$feat3)" [list $nodes(2) $nodes(3)] [list $nodes(0) $nodes(1)]
 
 # Test mixed AND and XOR with 2 nodes
-log_info "==========Test mix of AND and XOR=========="
-sub_job_and_xor 2 0
+testproc test_constrain 2 "$feat4&\[$feat1|$feat0\]" "" [list $nodes(0) $nodes(2) $nodes(3)] [list $nodes(1)]
 
 # Test mixed AND and XOR with 3 nodes (This is expected to fail)
-log_info "==========Test mix of AND and XOR=========="
-sub_job_and_xor 3 1
+testproc test_constrain 3 "$feat4&\[$feat1|$feat0\]" [list]
 
-# Test batch host
-if {[get_config_param "FrontendName"] eq "MISSING"} {
-	log_info "==========Test batch host=========="
-	sub_batch_host 3
+#
+# Special testprocs
+#
+# Specific test for batch host
+if {[get_config_param "FrontendName"] ne "MISSING"} {
+	skip_following_testprocs "Test incompatible with front-end"
 }
+testproc test_constrain_batch 3 "$feat0|$feat3" $feat3 [list $nodes(3)]
+run_following_testprocs
 
-# Reset node features and remove test part
-log_debug "==========Clean Up=========="
-clean_up
+# Specific test invalid constraint requirement
+testproc test_constrain_invalid 1 "invalid,constraint"
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
+# Specific test for bug 9546 about xor/xand (with specific setup)
+cleanup
+setup_2_features
+testproc test_constrain_9546
diff --git a/testsuite/expect/test17.13 b/testsuite/expect/test17.13
index 1983cc9381..db1416dcc4 100755
--- a/testsuite/expect/test17.13
+++ b/testsuite/expect/test17.13
@@ -33,6 +33,12 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set matches     0
 
+proc cleanup {} {
+	global file_in file_out
+
+	file delete $file_in $file_out
+}
+
 # These are the variables for which we are checking existence.
 # If the number following a variable name is 1, then we check to make
 # certain that the value of the env variable is greater than 0
@@ -70,8 +76,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -127,8 +132,6 @@ if {$good < $total} {
 	fail "Only $good of $total Slurm environment variables set"
 }
 
-if {$exit_code == 0} {
-	file delete $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.14 b/testsuite/expect/test17.14
index 9004869580..b76e55ed7c 100755
--- a/testsuite/expect/test17.14
+++ b/testsuite/expect/test17.14
@@ -35,6 +35,12 @@ set file_in         "test$test_id.input"
 set file_out        "test$test_id.output"
 set job_id           0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 global env
 set env($test_env_name) $test_env_val
 
@@ -58,9 +64,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -117,9 +121,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -173,9 +175,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -229,9 +229,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -272,8 +270,6 @@ if {$matches != 0} {
 	fail "Environment variables were propagated ($matches != 0)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.15 b/testsuite/expect/test17.15
index 1e1acb2f44..9680d56d37 100755
--- a/testsuite/expect/test17.15
+++ b/testsuite/expect/test17.15
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code        0
 set file_err         "test$test_id.error"
 set file_in          "test$test_id.input"
 set file_out         "test$test_id.output"
@@ -41,6 +40,12 @@ set limit_nproc      1230
 set limit_stack      2021
 set matches          0
 
+proc cleanup {} {
+	global bin_rm file_err file_in file_prog_get file_out
+
+	exec $bin_rm -f $file_err $file_in $file_prog_get $file_out
+}
+
 #
 # Delete left-over programs and rebuild them.
 # We use our own program to get ulimit values since the output
@@ -206,8 +211,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sort not responding"
-		set exit_code 1
+		fail "sort not responding"
 	}
 	eof {
 		wait
@@ -218,9 +222,3 @@ set target 5
 if {$matches != $target} {
 	fail "User limits not propagated got $matches of $target matches. Check PropagateResourceLimits configuration parameter. Check $file_err for errors. A long running slurmd could cause a file size limit error. slurmd could have been started with limits lower than user launching the task"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_err $file_in $file_prog_get $file_out
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test17.16 b/testsuite/expect/test17.16
index 05f82b7989..43fd375cab 100755
--- a/testsuite/expect/test17.16
+++ b/testsuite/expect/test17.16
@@ -32,6 +32,12 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set file_err    "test$test_id.error"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 set arg1        "arg_one"
 set arg2        "arg_two"
 set arg_match   0
@@ -56,9 +62,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -97,8 +102,6 @@ if {$arg_match == 0} {
 	fail "Failed to pass script arguments"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.17 b/testsuite/expect/test17.17
index 3144dc28ed..43231b28a3 100755
--- a/testsuite/expect/test17.17
+++ b/testsuite/expect/test17.17
@@ -39,6 +39,12 @@ set nodelist_name ""
 set gpu_tot      0
 set job_tres_cnt 0
 
+proc cleanup {} {
+	global bin_rm file_err file_in file_out
+
+	exec $bin_rm -f $file_err $file_in $file_out
+}
+
 set timeout $max_job_delay
 
 set node_name [get_nodes_by_request "--gres=gpu:2 -n1 -t1"]
@@ -68,9 +74,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -161,8 +166,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding\n"
-		set exit_code 1
+		fail "sbatch not responding\n"
 	}
 	eof {
 		wait
@@ -196,8 +200,6 @@ dict for {gres_name gres_count} $gres_dict_node {
 cancel_job $job_id2
 
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_err $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.18 b/testsuite/expect/test17.18
index 2a6ebf7a9e..f615826e8e 100755
--- a/testsuite/expect/test17.18
+++ b/testsuite/expect/test17.18
@@ -35,6 +35,12 @@ set exit_code   0
 set job_id1     0
 set job_id2     0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 #
 # Build input script file
 #
@@ -52,9 +58,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -101,8 +105,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -189,9 +192,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
-		exp_continue
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -206,9 +207,7 @@ if {$match != 2} {
 spawn $scontrol update JobId=$job_id1 StartTime=now
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
-		exp_continue
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -232,9 +231,7 @@ while { $delayed < $max_job_delay } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
-			exp_continue
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -259,8 +256,6 @@ if {$purged_job == 1} {
 }
 
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.19 b/testsuite/expect/test17.19
index 63bd29bbfc..6f331efbab 100755
--- a/testsuite/expect/test17.19
+++ b/testsuite/expect/test17.19
@@ -32,6 +32,12 @@ source ./globals
 set exit_code   0
 set file_in     "test$test_id.input"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 #
 # Delete left-over stdin/out/err files
 # Build stdin file
@@ -66,9 +72,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -86,9 +90,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
-		exp_continue
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -122,9 +124,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -168,9 +168,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -196,9 +194,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
-		exp_continue
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -211,8 +207,6 @@ if {[cancel_job $job_id] != 0} {
 	fail "Unable to cancel job ($job_id)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.2 b/testsuite/expect/test17.2
index 7d2da647fd..078c97e8b0 100755
--- a/testsuite/expect/test17.2
+++ b/testsuite/expect/test17.2
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -45,8 +44,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -54,9 +52,5 @@ expect {
 }
 
 if {$matches != 2} {
-	log_error "sbatch failed to report help message ($matches != 2)"
-	set exit_code 1
-}
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+	fail "sbatch failed to report help message ($matches != 2)"
 }
diff --git a/testsuite/expect/test17.20 b/testsuite/expect/test17.20
index b8ed8166c9..de1a2dbf80 100755
--- a/testsuite/expect/test17.20
+++ b/testsuite/expect/test17.20
@@ -28,12 +28,17 @@
 ############################################################################
 source ./globals
 
-set exit_code            0
 set file_in              "test$test_id.input"
 set file_out             "test$test_id.input"
 set got_job_grps         0
 set got_login_grps       0
 
+proc cleanup {} {
+	global file_in file_out
+
+	file delete $file_in $file_out
+}
+
 if {[get_config_param "FrontendName"] ne "MISSING" && ![is_super_user]} {
 	skip "This test is incompatible with front-end systems"
 }
@@ -95,9 +100,3 @@ expect {
 if {$got_job_grps == 0} {
 	fail "Did not get user info from slurm job"
 }
-
-if {$exit_code == 0} {
-	file delete $file_in $file_out
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test17.21 b/testsuite/expect/test17.21
index 8e3b11ba75..1a5c907869 100755
--- a/testsuite/expect/test17.21
+++ b/testsuite/expect/test17.21
@@ -35,6 +35,12 @@ set file_out    "test$test_id.output"
 set job_name    "TEST_NAME"
 set delay       10
 
+proc cleanup {} {
+	global file_in file_out
+
+	file delete $file_in $file_out
+}
+
 if {[get_config_param "EnforcePartLimits"] eq "NO"} {
 	skip "This test is incompatible with EnforcePartLimits = NO"
 }
@@ -67,9 +73,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
-		exp_continue
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -101,10 +105,8 @@ expect {
 		fail "Test B was supposed to fail submission"
 	}
 	timeout {
-		log_error "sbatch not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -133,10 +135,8 @@ expect {
 		cancel_job $job_id
 	}
 	timeout {
-		log_error "sbatch not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -146,8 +146,6 @@ expect {
 #
 # Post-processing
 #
-if {$exit_code == 0} {
-	file delete $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.22 b/testsuite/expect/test17.22
index 1d2759e0a7..bb3a21bd40 100755
--- a/testsuite/expect/test17.22
+++ b/testsuite/expect/test17.22
@@ -47,9 +47,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test17.23 b/testsuite/expect/test17.23
index 37588f0259..f79a4e8e7e 100755
--- a/testsuite/expect/test17.23
+++ b/testsuite/expect/test17.23
@@ -52,8 +52,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -70,8 +69,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -89,8 +87,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -114,8 +111,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -128,8 +124,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -142,8 +137,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test17.24 b/testsuite/expect/test17.24
index b43f0477e8..91def9dab8 100755
--- a/testsuite/expect/test17.24
+++ b/testsuite/expect/test17.24
@@ -31,6 +31,12 @@ source ./globals
 set exit_code   0
 set file_in     "test$test_id.input"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 #
 # Delete left-over stdin/out/err files
 # Build stdin file
@@ -54,9 +60,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -90,9 +94,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -103,8 +105,6 @@ if { $matches != 2 } {
 }
 
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.25 b/testsuite/expect/test17.25
index a98dd11884..03146a4186 100755
--- a/testsuite/expect/test17.25
+++ b/testsuite/expect/test17.25
@@ -29,12 +29,17 @@
 ############################################################################
 source ./globals
 
-set exit_code        0
 set file_in          "test$test_id.input"
 set job_id           0
 set timeout          $max_job_delay
 set account	     "dummy_acct"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if [param_contains [get_config_param "AccountingStorageEnforce"] "associations"] {
 	log_warn "Using user's default account instead of $account since associations are enforced"
 	set account [get_default_acct 0]
@@ -78,8 +83,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -93,9 +97,3 @@ if {$matches != 3} {
 	fail "Processed $matches of 3 environment variables"
 }
 cancel_job $job_id
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test17.26 b/testsuite/expect/test17.26
index 26ad06b11d..9d67ab5b57 100755
--- a/testsuite/expect/test17.26
+++ b/testsuite/expect/test17.26
@@ -35,6 +35,12 @@ set file_script      "test$test_id.sh"
 set job_id           0
 set timeout          $max_job_delay
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_script
+
+	exec $bin_rm -f $file_in $file_out $file_script
+}
+
 #
 # Build input script file
 #
@@ -55,8 +61,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -82,8 +87,6 @@ if {$matches != 1} {
 	fail "Sbatch failed to process --input"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.27 b/testsuite/expect/test17.27
index 25be97a046..7a486e15f2 100755
--- a/testsuite/expect/test17.27
+++ b/testsuite/expect/test17.27
@@ -34,6 +34,12 @@ set file_in          "test$test_id.input"
 set file_out         "test$test_id.output"
 set job_id           0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 #
 # Submit a 3+ node job
 #
@@ -43,7 +49,7 @@ set host_2      ""
 set host_3      ""
 set node_cnt 3
 
-set available [available_nodes]
+set available [llength [get_nodes_by_state idle,alloc,comp]]
 if {$available < $node_cnt} {
     skip "Not enough nodes currently available ($available avail, $node_cnt needed)"
 }
@@ -70,8 +76,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -164,8 +169,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -238,8 +242,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -286,8 +289,6 @@ if {$dup_hostname == 0} {
 	fail "Allocation lacked an included node"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.28 b/testsuite/expect/test17.28
index 275eaa40cb..8a5f1b49e7 100755
--- a/testsuite/expect/test17.28
+++ b/testsuite/expect/test17.28
@@ -35,6 +35,12 @@ set file_out    "test$test_id.output"
 set job_name    "TEST_NAME"
 set delay       1
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {[get_config_param "EnforcePartLimits"] eq "NO"} {
 	skip "This test is incompatible EnforcePartLimits = NO"
 }
@@ -53,8 +59,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -71,9 +76,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
-		exp_continue
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -113,9 +116,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -149,9 +150,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -170,8 +169,6 @@ if {[wait_for_job $job_id DONE] != 0} {
 #
 # Post-processing
 #
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.29 b/testsuite/expect/test17.29
index d2a43d33ba..60cc7f2021 100755
--- a/testsuite/expect/test17.29
+++ b/testsuite/expect/test17.29
@@ -32,6 +32,12 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set file_err    "test$test_id.error"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 set arg1        "arg_one"
 set arg2        "arg_two"
 set arg_match   0
@@ -56,8 +62,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -97,8 +102,6 @@ if {$arg_match == 0} {
 	fail "Failed to pass script arguments"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.3 b/testsuite/expect/test17.3
index 51e03d8a18..60fa871cb8 100755
--- a/testsuite/expect/test17.3
+++ b/testsuite/expect/test17.3
@@ -29,7 +29,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set version     0
 
 #
@@ -42,9 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -54,6 +51,3 @@ expect {
 if {$version != 1} {
 	fail "Did not get proper sbatch version number"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test17.31 b/testsuite/expect/test17.31
index e400936dd6..fc3b94d4ad 100755
--- a/testsuite/expect/test17.31
+++ b/testsuite/expect/test17.31
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set delay       1
@@ -40,19 +39,13 @@ global env
 set env_pbs_ignore "SBATCH_IGNORE_PBS"
 set env($env_pbs_ignore) 0
 
-proc end_it { exit_code } {
-        global job_id test_id
-        if {$job_id != 0} {
-                cancel_job $job_id
-        }
+proc cleanup {} {
+	global job_id test_id
 
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
+	cancel_job $job_id
 }
 
-set available [available_nodes]
+set available [llength [get_nodes_by_state idle,alloc,comp]]
 if {$available < $node_cnt} {
 	skip "Not enough nodes currently available ($available avail, $node_cnt needed)"
 }
@@ -73,17 +66,12 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
 		slow_kill $scontrol_pid
-		exp_continue
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
-        if {$exit_code != 0} {
-                end_it $exit_code
-        }
 }
 log_user 1
 log_debug "Actual configuration: min_cpus=$ppn_cnt  min_mem=$min_mem"
@@ -100,8 +88,7 @@ proc pbs_ignore_expects {} {
                 -re "mem$whitespace: ($number)G" {
                         set mem $expect_out(1,string)
                         if { $mem * 1024 != $min_mem } {
-                                log_error "Min memory is different ($mem) than requested ($min_mem)"
-                                end_it 1
+                                fail "Min memory is different ($mem) than requested ($min_mem)"
                         } else {
                                 incr matches
                         }
@@ -110,8 +97,7 @@ proc pbs_ignore_expects {} {
                 -re "mem$whitespace: ($number)" {
                         set mem $expect_out(1,string)
                         if { $mem != $min_mem } {
-                                log_error "Min memory is different ($mem) than requested ($min_mem)"
-                                end_it 1
+                                fail "Min memory is different ($mem) than requested ($min_mem)"
                         } else {
                                 incr matches
                         }
@@ -120,8 +106,7 @@ proc pbs_ignore_expects {} {
                 -re "nodes$whitespace: ($number)" {
                         set nodes $expect_out(1,string)
                         if { $nodes != $node_cnt } {
-                                log_error "Bad node count allocated"
-                                end_it 1
+                                fail "Bad node count allocated"
                         } else {
                                 incr matches
                         }
@@ -131,8 +116,7 @@ proc pbs_ignore_expects {} {
                         set cpu_count $expect_out(1,string)
                         set cpus_per_node [expr $cpu_count / $node_cnt]
                         if { $cpus_per_node != $ppn_cnt } {
-                                log_error "PPN count not sent correctly asked for $ppn_cnt but got $cpus_per_node"
-                                end_it 1
+                                fail "PPN count not sent correctly asked for $ppn_cnt but got $cpus_per_node"
                         } else {
                                 incr matches
                         }
@@ -148,9 +132,8 @@ proc pbs_ignore_expects {} {
                 }
 
                 timeout {
-                        log_error "sbatch not responding"
                         slow_kill $sbatch_pid
-                        end_it 1
+                        fail "sbatch not responding"
                 }
                 eof {
                         wait
@@ -177,8 +160,7 @@ $bin_sleep $delay
 set sbatch_pid [spawn $sbatch -vv -o $file_out $file_in]
 set matches [pbs_ignore_expects]
 if {$matches != 3} {
-        log_error "sbatch didn't read the correct options from batch file ($matches of 3)"
-        end_it 1
+        fail "sbatch didn't read the correct options from batch file ($matches of 3)"
 }
 log_info "#PBS batch command processed correctly"
 
@@ -192,8 +174,7 @@ $bin_sleep $delay
 set sbatch_pid [spawn $sbatch -vv -o $file_out $file_in]
 set matches [pbs_ignore_expects]
 if {$matches != 0} {
-        log_error "#SBATCH --ignore-pbs was not processed"
-        end_it 1
+        fail "#SBATCH --ignore-pbs was not processed"
 }
 log_info "#SBATCH --ignore-pbs processed correctly"
 
@@ -206,8 +187,7 @@ $bin_sleep $delay
 set sbatch_pid [spawn $sbatch --ignore-pbs -vv -o $file_out $file_in]
 set matches [pbs_ignore_expects]
 if {$matches != 0} {
-        log_error "command line arg --ignore-pbs was not processed"
-        end_it 1
+        fail "command line arg --ignore-pbs was not processed"
 }
 log_info "command line arg --ignore-pbs processed correctly"
 
@@ -221,10 +201,7 @@ set env($env_pbs_ignore) 1
 set sbatch_pid [spawn $sbatch -vv -o $file_out $file_in ]
 set matches [pbs_ignore_expects]
 if {$matches != 0} {
-        log_error "SBATCH_IGNORE_PBS=1 environment variable was not processed"
-        end_it 1
+        fail "SBATCH_IGNORE_PBS=1 environment variable was not processed"
 }
 set env($env_pbs_ignore) 0
 log_info "BATCH_IGNORE_PBS=1 environment variable processed correctly"
-
-end_it 0
diff --git a/testsuite/expect/test17.32 b/testsuite/expect/test17.32
index ae5f54d5eb..d05d5fc0f5 100755
--- a/testsuite/expect/test17.32
+++ b/testsuite/expect/test17.32
@@ -33,6 +33,12 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set job_id      0
 
+proc cleanup {} {
+	global file_in file_out
+
+	file delete $file_in $file_out
+}
+
 #
 # Submit a slurm job that will print slurm env vars and execute 'id'
 #
@@ -57,8 +63,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -103,8 +108,6 @@ if {$tasks != $task_cnt} {
 	fail "Did not get proper number of tasks: ($tasks != $task_cnt)"
 }
 
-if {$exit_code == 0} {
-	file delete $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.34 b/testsuite/expect/test17.34
index e5f41e53bd..ed5788359b 100755
--- a/testsuite/expect/test17.34
+++ b/testsuite/expect/test17.34
@@ -33,6 +33,12 @@ set file_out   "test$test_id\.out"
 set spec_in    "spec_core_script\.in"
 set exit_code  0
 
+proc cleanup {} {
+	global bin_rm file_in file_out spec_in
+
+	exec $bin_rm -f $file_in $file_out $spec_in
+}
+
 #############################################################################
 #
 # Checks that the node uses the correct number of specialized cores
@@ -78,8 +84,7 @@ proc core_spec_job {task node core_spec exp_nodes} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -112,8 +117,7 @@ proc core_spec_job {task node core_spec exp_nodes} {
 				exp_continue
 			}
 			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
+				fail "scontrol is not responding"
 			}
 			eof {
 				wait
@@ -185,8 +189,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -229,8 +232,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "cat is not responding"
-		set exit_code 1
+		fail "cat is not responding"
 	}
 	eof {
 		wait
@@ -266,8 +268,6 @@ log_info "Fail by trying to use more cores than exist"
 core_spec_job 1 $first_node [expr $core_cnt + 5] -1
 core_spec_job 1 $first_node [expr $core_cnt + 7] -1
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $spec_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.35 b/testsuite/expect/test17.35
index 6bc7a74bcb..8e62dcdb50 100755
--- a/testsuite/expect/test17.35
+++ b/testsuite/expect/test17.35
@@ -31,6 +31,12 @@ set exit_code  0
 set job_cnt    100
 set target     200
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {[get_config_param "SwitchType"] eq "switch/cray"} {
 	set target 65
 }
@@ -73,8 +79,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -88,8 +93,7 @@ if {$match != $job_cnt} {
 spawn $scancel --name=$file_in
 expect {
 	timeout {
-		log_error "scancel is not responding"
-		set exit_code 1
+		fail "scancel is not responding"
 	}
 	eof {
 		wait
@@ -106,8 +110,6 @@ if {$rate < $target} {
 	fail "Job submit rate of $rate below target of $target. This may be due to use of NFS rather than local storage for logs or state information"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.36 b/testsuite/expect/test17.36
index 43323bf06f..2d9364206f 100755
--- a/testsuite/expect/test17.36
+++ b/testsuite/expect/test17.36
@@ -42,6 +42,12 @@ set job_id        0
 set node_name     ""
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {[check_config_select "linear"]} {
 	skip "Test is not compatible with a config of SelectType=select/linear"
 }
@@ -109,8 +115,7 @@ proc cr_core_cpu { node } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -131,7 +136,7 @@ proc cr_core_cpu { node } {
 
 # Get default_queue_depth to see how many jobs will start at one time
 proc default_queue_depth { } {
-	global scontrol exit_coode number
+	global scontrol number
 
 	set depth 100
 	log_user 0
@@ -142,8 +147,7 @@ proc default_queue_depth { } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -156,35 +160,19 @@ proc default_queue_depth { } {
 
 proc create_part {part oversubscribe node} {
 
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol create partitionname=$part OverSubscribe=$oversubscribe nodes=$node
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
 		}
 	}
-
 }
 
-proc delete_part {part} {
-	global scontrol exit_code
-
-	spawn $scontrol delete partitionname=$part
-	expect {
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-}
 
 proc sub_job { job oversubscribe part } {
 	global sbatch file_in number job_id exit_code job_mem_opt
@@ -198,8 +186,7 @@ proc sub_job { job oversubscribe part } {
 				exp_continue
 			}
 			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
+				fail "sbatch is not responding"
 			}
 			eof {
 				wait
@@ -213,8 +200,7 @@ proc sub_job { job oversubscribe part } {
 				exp_continue
 			}
 			timeout {
-				log_error "sbatch is not responding"
-				set exit_code 1
+				fail "sbatch is not responding"
 			}
 			eof {
 				wait
@@ -225,7 +211,6 @@ proc sub_job { job oversubscribe part } {
 		log_error "sbatch did not submit job"
 		set exit_code 1
 	}
-
 }
 
 proc check_job { exp_num_jobs } {
@@ -255,7 +240,7 @@ proc check_job { exp_num_jobs } {
 }
 
 proc check_part { } {
-	global scontrol test_part_1 test_part_2 test_part_3 exit_code
+	global scontrol test_part_1 test_part_2 test_part_3
 
 	set found     0
 	set part_name ""
@@ -268,8 +253,7 @@ proc check_part { } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -372,8 +356,6 @@ check_job 1
 cancel_job $job_id
 delete_part $test_part_3
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test17.37 b/testsuite/expect/test17.37
index fdab303d2e..13f10b6862 100755
--- a/testsuite/expect/test17.37
+++ b/testsuite/expect/test17.37
@@ -31,6 +31,12 @@ set job_id2       0
 set script        "test$test_id\_sc"
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm script
+
+	exec $bin_rm -f $script
+}
+
 make_bash_script $script "sleep 10"
 
 # Submit a job to depend on
@@ -41,8 +47,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -67,8 +72,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -94,8 +98,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -110,15 +113,14 @@ if { $match != 1 } {
 # Check that the job with dependency is in the correct state and has correct
 # reason
 set match 0
-if {[param_contains [get_config_param "SchedulerParameters"] "kill_invalid_depend"]} {
+if {[param_contains [get_config_param "DependencyParameters"] "kill_invalid_depend"]} {
 	spawn $scontrol show job $job_id2
 	expect {
 		-re "JobState=CANCELLED Reason=Dependency Dependency=afternotok:${job_id1}" {
 			incr match 1
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -137,8 +139,7 @@ if {[param_contains [get_config_param "SchedulerParameters"] "kill_invalid_depen
 			incr match 1
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -153,8 +154,6 @@ if {[param_contains [get_config_param "SchedulerParameters"] "kill_invalid_depen
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.38 b/testsuite/expect/test17.38
index 0d12df332c..318a5de5a7 100755
--- a/testsuite/expect/test17.38
+++ b/testsuite/expect/test17.38
@@ -33,6 +33,12 @@ set file_prog   "test$test_id.prog"
 set elps_time   0
 set job_id      0
 
+proc cleanup {} {
+	global file_prog file_in file_out
+
+	exec rm -f $file_prog $file_in $file_out
+}
+
 #
 # Cannot run the test if OverTimeLimit is set, since we test time limits.
 #
@@ -73,8 +79,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -104,8 +109,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "cat is not responding"
-		set exit_code 1
+		fail "cat is not responding"
 	}
 	eof {
 		wait
@@ -134,8 +138,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -156,8 +159,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -187,8 +189,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "cat is not responding"
-		set exit_code 1
+		fail "cat is not responding"
 	}
 	eof {
 		wait
@@ -218,16 +219,13 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec rm -f $file_prog $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.39 b/testsuite/expect/test17.39
index 9750144e10..b49535d999 100755
--- a/testsuite/expect/test17.39
+++ b/testsuite/expect/test17.39
@@ -32,7 +32,7 @@ set fast_id       0
 set dep_id        0
 set exit_code     0
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {[check_config_select "linear"]} {
 	if {$nb_nodes < 2} {
 		skip "This test is incompatible with select/linear and only one node"
@@ -51,8 +51,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not reponding"
-		set exit_code 1
+		fail "sbatch is not reponding"
 	}
 	eof {
 		wait
@@ -73,8 +72,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not reponding"
-		set exit_code 1
+		fail "sbatch is not reponding"
 	}
 	eof {
 		wait
@@ -92,8 +90,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not reponding"
-		set exit_code 1
+		fail "sbatch is not reponding"
 	}
 	eof {
 		wait
@@ -112,8 +109,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not reponding"
-		set exit_code 1
+		fail "squeue is not reponding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test17.4 b/testsuite/expect/test17.4
index ea3e7f8df7..fb1a869222 100755
--- a/testsuite/expect/test17.4
+++ b/testsuite/expect/test17.4
@@ -38,6 +38,12 @@ set job_grp_info         ""
 set got_job_grps         0
 set got_login_grps       0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 #
 # Execute 'id' to determine my user and group ID...
 #
@@ -59,9 +65,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -108,8 +112,6 @@ if {[string compare $login_grp_info $job_grp_info] != 0} {
 	fail "Login and sbatch user info mismatch"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.40 b/testsuite/expect/test17.40
index 3605b07c53..3b024dab41 100755
--- a/testsuite/expect/test17.40
+++ b/testsuite/expect/test17.40
@@ -33,6 +33,12 @@ set file_out   "test$test_id\.out"
 set spec_in    "spec_thread_script\.in"
 set exit_code  0
 
+proc cleanup {} {
+	global bin_rm file_in file_out spec_in
+
+	exec $bin_rm -f $file_in $file_out $spec_in
+}
+
 #############################################################################
 #
 # Checks that the node uses the correct number of specialized threads
@@ -72,8 +78,7 @@ proc thread_spec_job {task node thread_spec exp_nodes} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -106,8 +111,7 @@ proc thread_spec_job {task node thread_spec exp_nodes} {
 				exp_continue
 			}
 			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
+				fail "scontrol is not responding"
 			}
 			eof {
 				wait
@@ -180,8 +184,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -224,8 +227,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "cat is not responding"
-		set exit_code 1
+		fail "cat is not responding"
 	}
 	eof {
 		wait
@@ -261,8 +263,6 @@ log_info "Fail by trying to use more threads than exist"
 thread_spec_job 1 $first_node [expr $thread_cnt + 1] -1
 thread_spec_job 1 $first_node [expr $thread_cnt + 3] -1
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $spec_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.41 b/testsuite/expect/test17.41
index 81e0ad869d..0f3465723b 100755
--- a/testsuite/expect/test17.41
+++ b/testsuite/expect/test17.41
@@ -31,6 +31,12 @@ set part_inv       "$test_part\g"
 set file_in        "test$test_id\.sc"
 set exit_code      0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 make_bash_script $file_in "sleep 1"
 
 proc test_sbatch { part }  {
@@ -47,8 +53,7 @@ proc test_sbatch { part }  {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -68,8 +73,7 @@ proc test_sbatch { part }  {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -89,8 +93,7 @@ proc test_sbatch { part }  {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -105,8 +108,6 @@ proc test_sbatch { part }  {
 test_sbatch $test_part\g
 test_sbatch "$test_part\,$test_part\g"
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test17.42 b/testsuite/expect/test17.42
index 73f96c4706..1dd58e45db 100755
--- a/testsuite/expect/test17.42
+++ b/testsuite/expect/test17.42
@@ -30,6 +30,12 @@ set exit_code   0
 set file_in     "test$test_id.in"
 set job_id      0
 
+proc cleanup {} {
+	global file_in
+
+	exec rm -f $file_in
+}
+
 #
 # Submit simple "sleep" batch job with --wait option
 #
@@ -42,8 +48,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -64,8 +69,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -74,9 +78,3 @@ expect {
 if {$match != 1} {
 	fail "Job not in state COMPLETED. Could be due to small configured MinJobAge value"
 }
-
-if {$exit_code == 0} {
-	exec rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test17.43 b/testsuite/expect/test17.43
index 270183c106..ded947c6fc 100755
--- a/testsuite/expect/test17.43
+++ b/testsuite/expect/test17.43
@@ -34,6 +34,12 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set exit_code   0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 #
 # Delete left-over stdin/out/err files
 # Build stdin file
@@ -122,9 +128,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -165,8 +169,6 @@ if {[wait_for_file $file_out] != 0} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.44 b/testsuite/expect/test17.44
index fecc9eab2a..6be438ab22 100755
--- a/testsuite/expect/test17.44
+++ b/testsuite/expect/test17.44
@@ -35,6 +35,12 @@ set script1       "test$test_id\_sc1"
 set script2       "test$test_id\_sc2"
 set tasks         10
 
+proc cleanup {} {
+	global bin_rm script1 script2
+
+	exec $bin_rm -f $script1 $script2
+}
+
 for {set task_id 1} {$task_id <= $tasks} {incr task_id} {
 	set file_out_glob "${output_base}${task_id}"
 	exec $bin_rm -f $file_out_glob
@@ -50,8 +56,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -71,8 +76,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -112,10 +116,9 @@ for {set task_id 1} {$task_id <= $tasks} {incr task_id} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $script1 $script2
-} else {
+if {$exit_code != 0} {
 	cancel_job $job_id1
 	cancel_job $job_id2
+
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.45 b/testsuite/expect/test17.45
index 88a1c43b0d..c2ee4e0774 100755
--- a/testsuite/expect/test17.45
+++ b/testsuite/expect/test17.45
@@ -29,9 +29,14 @@ source ./globals
 set file_bbf    "test$test_id.bbf"
 set file_script "test$test_id.bash"
 set file_out    "test$test_id.output"
-
 set exit_code   0
 
+proc cleanup {} {
+	global bin_rm file_bbf file_script file_out
+
+	exec $bin_rm -f $file_bbf $file_script $file_out
+}
+
 #
 # Build job script
 #
@@ -62,9 +67,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -110,8 +113,6 @@ if {[wait_for_file $file_out] != 0} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_bbf $file_script $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.5 b/testsuite/expect/test17.5
index b6dd483650..22d6cd93d8 100755
--- a/testsuite/expect/test17.5
+++ b/testsuite/expect/test17.5
@@ -45,6 +45,12 @@ set file_out_u  "test$test_id.%u.output"
 set file_err_u  "test$test_id.%u.error"
 set exit_code   0
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 #
 # Delete left-over stdin/out/err files
 # Build stdin file
@@ -74,9 +80,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -135,9 +139,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -209,9 +211,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -256,9 +256,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -305,9 +303,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -354,9 +350,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -388,8 +382,6 @@ if { [file exists $file_err2] } {
 	fail "Found unexpected stderr file $file_err2"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.51 b/testsuite/expect/test17.51
index afb56bb1df..6229e0eca6 100755
--- a/testsuite/expect/test17.51
+++ b/testsuite/expect/test17.51
@@ -30,16 +30,26 @@ set exit_code    0
 set cwd          "[$bin_pwd]"
 set config_path  ""
 set tmp_job      "test$test_id\_tmp_job"
+set job_id       0
 
 if {![is_super_user]} {
 	skip "This test can't be run except as SlurmUser"
 }
 
 set config_path [get_conf_path]
-fail_on_error "Unable to get config path"
 set config_file $config_path/slurm.conf
 save_conf $config_file
 
+proc cleanup {} {
+	global job_id config_file bin_rm tmp_job
+
+	# Clean up vestigial files, jobs and restore original slurm.conf file
+	cancel_job $job_id
+	restore_conf $config_file
+	reconfigure
+	exec $bin_rm $tmp_job
+}
+
 log_info "---Checking sbatch uses mcs-label only for some jobs (ondemand,select mode)---"
 
 #
@@ -52,7 +62,7 @@ exec $bin_sed -i /^\[\t\s\]*PrivateData\[\t\s\]*=/Id $config_file
 exec $bin_echo -e "\nMCSPlugin=mcs/user" >> $config_file
 exec $bin_echo MCSParameters=ondemand,select,privatedata >> $config_file
 exec $bin_echo PrivateData=jobs,nodes >> $config_file
-reconfigure
+reconfigure -fail
 
 
 #
@@ -67,8 +77,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -104,7 +113,6 @@ expect {
 log_info "---Checking sbatch uses mcs-label=user---"
 
 make_bash_script $tmp_job "sleep 30"
-set job_id 0
 spawn $sbatch -N1 -o/dev/null --exclusive=mcs -t10 $tmp_job
 expect {
 	-re "Submitted batch job ($number)" {
@@ -112,8 +120,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -141,8 +148,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -165,8 +171,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -194,8 +199,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -217,8 +221,7 @@ if {[get_config_param "AccountingStorageType"] eq "accounting_storage/slurmdbd"}
 			exp_continue
 		}
 		timeout {
-			log_error "sacct is not responding"
-			set exit_code 1
+			fail "sacct is not responding"
 		}
 		eof {
 			wait
@@ -240,8 +243,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -265,8 +267,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -291,7 +292,7 @@ exec $bin_sed -i /^\[\t\s\]*PrivateData\[\t\s\]*=/Id $config_file
 exec $bin_echo -e "\nMCSPlugin=mcs/user" >> $config_file
 exec $bin_echo MCSParameters=enforced,noselect,privatedata >> $config_file
 exec $bin_echo PrivateData=jobs,nodes >> $config_file
-reconfigure
+reconfigure -fail
 
 
 ###### Check that sbatch uses mcs-label=user ######
@@ -306,8 +307,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -335,8 +335,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -358,8 +357,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -385,8 +383,7 @@ expect {
 		log_debug "No mcs_label for this node. It was expected"
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -406,7 +403,7 @@ exec $bin_sed -i /^\[\t\s\]*PrivateData\[\t\s\]*=/Id $config_file
 exec $bin_echo -e "\nMCSPlugin=mcs/user" >> $config_file
 exec $bin_echo MCSParameters=ondemand,noselect,privatedata >> $config_file
 exec $bin_echo PrivateData=jobs,nodes >> $config_file
-reconfigure
+reconfigure -fail
 
 ###### Check that sbatch uses mcs-label=user ######
 log_info "---Checking sbatch uses --exclusive=mcs ---"
@@ -420,8 +417,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 		}
 	eof {
 		wait
@@ -449,8 +445,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -472,8 +467,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -499,8 +493,7 @@ expect {
 		log_debug "No mcs_label for this node. It was expected"
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -521,8 +514,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -549,8 +541,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -579,7 +570,7 @@ exec $bin_sed -i /^\[\t\s\]*PrivateData\[\t\s\]*=/Id $config_file
 exec $bin_echo -e "\nMCSPlugin=mcs/user" >> $config_file
 exec $bin_echo MCSParameters=enforced,select,privatedata >> $config_file
 exec $bin_echo PrivateData=jobs,nodes >> $config_file
-reconfigure
+reconfigure -fail
 
 ###### Check that sbatch uses mcs-label=user ######
 log_info "---Checking sbatch with no --exclusive=mcs ---"
@@ -593,8 +584,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -620,8 +610,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -643,8 +632,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -669,8 +657,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -682,14 +669,6 @@ if {$found == 0} {
 	set exit_code 1
 }
 
-cancel_job $job_id
-
-# Clean up vestigial files and restore original slurm.conf file
-restore_conf $config_file
-reconfigure
-
-if {$exit_code == 0} {
-	exec $bin_rm $tmp_job
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.52 b/testsuite/expect/test17.52
index 6792c2ef9f..1371c148c4 100755
--- a/testsuite/expect/test17.52
+++ b/testsuite/expect/test17.52
@@ -32,16 +32,26 @@ set config_path  ""
 set tmp_job      "test$test_id\_tmp_job"
 set file_in	 "test${test_id}.in"
 set file_out     "test${test_id}.out"
+set job_id       0
 
 if {![is_super_user]} {
 	skip "This test can't be run except as SlurmUser"
 }
 
 set config_path [get_conf_path]
-fail_on_error "Unable to get config path"
 set config_file $config_path/slurm.conf
 save_conf $config_file
 
+proc cleanup {} {
+	global job_id config_file bin_rm tmp_job
+
+	# Clean up vestigial files, jobs and restore original slurm.conf file
+	cancel_job $job_id
+	restore_conf $config_file
+	reconfigure
+	exec $bin_rm $tmp_job
+}
+
 log_info "---Checking sbatch uses mcs-label only for some jobs (ondemand mode)---"
 
 #
@@ -65,7 +75,7 @@ exec $bin_sed -i /^\[\t\s\]*PrivateData\[\t\s\]*=/Id $config_file
 exec $bin_echo -e "\nMCSPlugin=mcs/group" >> $config_file
 exec $bin_echo MCSParameters=ondemand,select,privatedata:$groups_name >> $config_file
 exec $bin_echo PrivateData=jobs,nodes >> $config_file
-reconfigure
+reconfigure -fail
 
 
 #
@@ -80,8 +90,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -106,8 +115,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -119,7 +127,6 @@ expect {
 log_info "---Checking sbatch uses mcs-label=group---"
 
 make_bash_script $tmp_job "sleep 10"
-set job_id 0
 spawn $sbatch -N1 -o/dev/null --exclusive=mcs -t1 $tmp_job
 expect {
 	-re "Submitted batch job ($number)" {
@@ -127,8 +134,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -169,8 +175,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -193,8 +198,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -220,8 +224,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -242,8 +245,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -267,8 +269,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -292,7 +293,7 @@ exec $bin_sed -i /^\[\t\s\]*PrivateData\[\t\s\]*=/Id $config_file
 exec $bin_echo -e "\nMCSPlugin=mcs/group" >> $config_file
 exec $bin_echo MCSParameters=enforced,noselect,privatedata:$groups_name >> $config_file
 exec $bin_echo PrivateData=jobs,nodes >> $config_file
-reconfigure
+reconfigure -fail
 
 
 ###### Check that sbatch uses mcs-label=group ######
@@ -307,8 +308,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -335,8 +335,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -358,8 +357,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -384,22 +382,13 @@ expect {
 		log_debug "No mcs_label for this node. It was expected"
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-cancel_job $job_id
-
-# Clean up vestigial files and restore original slurm.conf file
-restore_conf $config_file
-reconfigure
-
-if {$exit_code == 0} {
-	exec $bin_rm $tmp_job
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.53 b/testsuite/expect/test17.53
index 67021006a4..605d07fcba 100755
--- a/testsuite/expect/test17.53
+++ b/testsuite/expect/test17.53
@@ -30,6 +30,12 @@ set file_in     "test$test_id.input"
 set exit_code   0
 set job_id      0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 #
 # Build input script file
 #
@@ -52,9 +58,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -65,8 +69,6 @@ if {$job_id != 0} {
 	fail "Batch submit with a deadline too old"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.54 b/testsuite/expect/test17.54
index bd11361976..ae3b7879c0 100755
--- a/testsuite/expect/test17.54
+++ b/testsuite/expect/test17.54
@@ -41,6 +41,14 @@ if {![is_super_user]} {
 	skip "You must be SlurmUser or root to run this test"
 }
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	# Restore partition MaxTime and DefaultTime.
+	reconfigure
+	exec $bin_rm -f $file_in
+}
+
 set default_part [default_partition]
 if { $default_part == "" } {
 	fail "Unable to get the default partition"
@@ -90,9 +98,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -123,23 +129,13 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
-		exp_continue
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-#
-# Restore partition MaxTime and DefaultTime.
-# reconfigure will set exit_code and log any errors if it fails.
-#
-reconfigure
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.55 b/testsuite/expect/test17.55
index 0ac597fa9e..002d3183e3 100755
--- a/testsuite/expect/test17.55
+++ b/testsuite/expect/test17.55
@@ -32,6 +32,12 @@ set exit_code      0
 set part_name      "QA_TEST"
 set file_in        "test$test_id.input"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {![is_super_user]} {
 	skip "Can not test more unless SlurmUser or root"
 }
@@ -52,8 +58,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -69,7 +74,7 @@ if {$found == 1} {
 #
 # Identify usable nodes in default partition
 #
-set def_node [get_idle_node_in_part]
+set def_node [lindex [get_nodes_by_state] 0]
 if {[string compare $def_node ""] == 0} {
 	fail "Default partition seems to have no nodes"
 }
@@ -85,8 +90,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -109,8 +113,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -142,9 +145,7 @@ if {[string compare $enforcepartlimits "NO"] == 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
-			exp_continue
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -163,9 +164,7 @@ if {[string compare $enforcepartlimits "NO"] == 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
-			exp_continue
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -189,8 +188,7 @@ if {[string compare $enforcepartlimits "NO"] == 0} {
                         exp_continue
                 }
                 timeout {
-                        log_error "sbatch not responding"
-                        set exit_code 1
+                        fail "sbatch not responding"
                 }
                 eof {
                         wait
@@ -206,8 +204,7 @@ cancel_job $job_id
 spawn $scontrol delete PartitionName=$part_name
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -230,8 +227,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -241,8 +237,6 @@ if {$found != 0} {
 	fail "Partition not deleted"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.56 b/testsuite/expect/test17.56
index ae4c4262e0..2c9059a549 100755
--- a/testsuite/expect/test17.56
+++ b/testsuite/expect/test17.56
@@ -30,6 +30,12 @@ set file_in     "test$test_id.input"
 set exit_code   0
 set job_id      0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 set default_time [get_partition_default_time_limit]
 if { $default_time != -1} {
 	skip "This test is not compatible with default partition having a default time limit ($default_time)"
@@ -57,9 +63,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -87,16 +91,13 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.57 b/testsuite/expect/test17.57
index 2e69ea0ab1..de831a512e 100755
--- a/testsuite/expect/test17.57
+++ b/testsuite/expect/test17.57
@@ -30,6 +30,12 @@ set file_in     "test$test_id.input"
 set exit_code   0
 set job_id      0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 #
 # Build input script file
 #
@@ -52,9 +58,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -65,8 +69,6 @@ if {$job_id != 0} {
 	fail "Batch submitted despite the deadline"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.58 b/testsuite/expect/test17.58
index 24026bf8fc..3231c6c3f1 100755
--- a/testsuite/expect/test17.58
+++ b/testsuite/expect/test17.58
@@ -31,19 +31,11 @@ set file_in     "test$test_id.input"
 set exit_code   0
 set job_id      0
 
-#
-# Since we make changes to configuration, call this function restore
-# configuration before exiting.
-#
-proc endit { } {
-	global exit_code bin_rm file_in
+proc cleanup {} {
+	global bin_rm file_in
+
 	reconfigure
-	if {$exit_code == 0} {
-		exec $bin_rm -f $file_in
-		pass
-	} else {
-		fail "Exiting with exit code $exit_code"
-	}
+	exec $bin_rm -f $file_in
 }
 
 #
@@ -58,9 +50,8 @@ if {![is_super_user]} {
 # Ensure that MaxTime is UNLIMITED so this test won't fail due to trying to set
 # time limits greater than MaxTime.
 #
-set exit_code [set_partition_maximum_time_limit "" -1]
-if { $exit_code != 0 } {
-	endit
+if [set_partition_maximum_time_limit "" -1] {
+	fail "Unable to clear partition maximum time limit"
 }
 
 #
@@ -85,8 +76,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -94,9 +84,7 @@ expect {
 }
 
 if {$job_id == 0} {
-	log_error "Batch not submitted"
-	set exit_code 1
-	endit
+	fail "Batch not submitted"
 }
 
 #
@@ -104,9 +92,7 @@ if {$job_id == 0} {
 #
 if {[wait_for_job $job_id DONE] != 0} {
 	cancel_job $job_id
-	log_error "Job failed to run to completion. This can be due to QOS or account time limit <120 minutes"
-	set exit_code 1
-	endit
+	fail "Job failed to run to completion. This can be due to QOS or account time limit <120 minutes"
 }
 spawn $scontrol show job $job_id
 expect {
@@ -124,12 +110,13 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-endit
+if {$exit_code != 0} {
+        fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+}
diff --git a/testsuite/expect/test17.59 b/testsuite/expect/test17.59
index dccbb91e0c..326b53b887 100755
--- a/testsuite/expect/test17.59
+++ b/testsuite/expect/test17.59
@@ -31,6 +31,12 @@ set file_in     "test$test_id.input"
 set exit_code   0
 set job_id      0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 #
 # Build input script file
 #
@@ -57,8 +63,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -69,8 +74,6 @@ if {$job_id != 0} {
 	fail "Batch submitted with a deadline too short"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.6 b/testsuite/expect/test17.6
index 24c9fb7b0a..54513d6ecd 100755
--- a/testsuite/expect/test17.6
+++ b/testsuite/expect/test17.6
@@ -33,9 +33,14 @@ set exit_code   0
 set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set tasks       0
-
 set task_cnt    2
 
+proc cleanup {} {
+	global file_in file_out
+
+	file delete $file_in $file_out
+}
+
 #
 # Submit a slurm job that will execute 'id' on $task_cnt tasks (or try anyway)
 #
@@ -55,8 +60,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -70,8 +74,7 @@ if {$job_id != 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -115,8 +118,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -150,8 +152,6 @@ if {$task_cnt != $tasks} {
 	set exit_code 1
 }
 
-if {$exit_code == 0} {
-	file delete $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.60 b/testsuite/expect/test17.60
index 716c80b430..738a957d4c 100755
--- a/testsuite/expect/test17.60
+++ b/testsuite/expect/test17.60
@@ -3,6 +3,9 @@
 # Purpose: Test of Slurm functionality
 #          Test of --deadline and --begin option and --time_min too long
 ############################################################################
+# Copyright (C) 2020 SchedMD LLC.
+# Written by Albert Gil <albert.gil@schedmd.com>
+#
 # Copyright (C) 2015 CEA/DAM/DIF
 # Written by Aline Roy <aline.roy@cea.fr>
 #
@@ -26,109 +29,61 @@
 ############################################################################
 source ./globals
 
-set file_in     "test$test_id.input"
-set exit_code   0
-set job_id      0
+set job_list ""
+
+proc cleanup {} {
+	global job_list
+	cancel_job $job_list
+}
 
 #
-# Build input script file
+# Get the node to use
 #
-exec $bin_rm -f $file_in
-make_bash_script $file_in "$bin_sleep 5"
+set node [get_nodes_by_request "-N1 -t 5"]
+if {[llength $node] != 1} {
+	skip "This test needs to be able to submit a job with '-N1 -t 5'"
+}
 
 #
-# Spawn a batch job with a deadline and no time
+# Submit a blocking job
 #
-set timeout [expr $max_job_delay + 60]
-spawn $sbatch --output=/dev/null --error=/dev/null --begin now+60 --deadline now+600 --time-min 10 $file_in
-expect {
-	-re "Requested time limit is invalid (missing or exceeds some limit)" {
-		set exit_code 1
-		exp_continue
-	}
-	-re "Incompatible begin and deadline time specification" {
-		set exit_code 1
-		exp_continue
-	}
-	-re "Submitted batch job ($number)" {
-		set job_id $expect_out(1,string)
-		set exit_code 0
-		exp_continue
-	}
-	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-if {$job_id == 0} {
-	fail "Batch not submitted with a deadline too short"
-}
+set job_block [submit_job -fail "-w $node --exclusive -t 5 --wrap '$bin_sleep 300' -J $test_name -o /dev/null -e /dev/null"]
+lappend job_list $job_block
+wait_for_job $job_block "RUNNING"
 
 #
-# test status deadline in scontrol and sacct
+# Submit a job with deadline that will rest pending until deadlines
 #
-if {[wait_for_job $job_id DONE] != 0} {
-	fail "Job failed to run to completion"
-}
+set job_id [submit_job -fail "-w $node --begin=now+5 --deadline=now+75 --time-min=1 --wrap '$bin_sleep 60' -J $test_name -o /dev/null -e /dev/null"]
+lappend job_list $job_id
 
-spawn $scontrol show job $job_id
-expect {
-	-re "JobState=DEADLINE" {
-		exp_continue
-	}
-	-re "JobState=" {
-		log_error "Invalid job state"
-		set exit_code 1
-		exp_continue
-	}
-	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
-		exp_continue
-	}
-	eof {
-		wait
-	}
+#
+# Check that job goes from PENDING with reason BeginTime to finally
+# end with DEADLINE.
+#
+set state  ""
+set reason ""
+wait_for -timeout 10 {$state == "PENDING" && $reason == "BeginTime"} {
+	set state  [get_job_param $job_id "JobState"]
+	set reason [get_job_param $job_id "Reason"]
 }
+subtest {$state == "PENDING" && $reason == "BeginTime"} "Job should be PENDING with reason BeginTime" "JobState=$state Reason=$reason"
 
-set cycle_count 8
-set not_support 0
-for {set inx 0} {$inx < $cycle_count} {incr inx} {
-	spawn $sacct  -n -P -X -j $job_id -o State
-	expect {
-		-re "Slurm accounting storage is disabled" {
-			set not_support 1
-			exp_continue
-		}
-		-re "DEADLINE" {
-			break
-		}
-		-re "COMPLETED" {
-			set exit_code 1
-			break
-		}
-		timeout {
-			log_error "sacct not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	sleep 10
+wait_for -timeout 60 {$state == "DEADLINE" && $reason == "DeadLine"} {
+	set state  [get_job_param $job_id "JobState"]
+	set reason [get_job_param $job_id "Reason"]
 }
-if {$not_support != 0} {
+subtest {$state == "DEADLINE" && $reason == "DeadLine"} "Job should end with state DEADLINE and reason DeadLine" "JobState=$state Reason=$reason"
+
+#
+# Test that the state is accounted properly
+#
+if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "Can not test without accounting enabled"
 }
 
-if {$exit_code == 1} {
-	fail "Batch submitted with a deadline too short"
-} else {
-	exec $bin_rm -f $file_in
-}
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+set sacct_state ""
+wait_for -timeout 30 {[regexp "DEADLINE" $sacct_state]} {
+	set sacct_state [run_command_output -fail "$sacct  -n -P -X -j $job_id -o State"]
 }
+subtest {[regexp "DEADLINE" $sacct_state]} "Job should be accounted with state DEADLINE" "$sacct_state != DEADLINE"
diff --git a/testsuite/expect/test17.61 b/testsuite/expect/test17.61
index 159b9db82e..fbcf901136 100755
--- a/testsuite/expect/test17.61
+++ b/testsuite/expect/test17.61
@@ -30,6 +30,15 @@ set file_in     "test$test_id.input"
 set exit_code   0
 set job_id      0
 
+#
+# Ensure that default partition has a DefaultTime big enough
+#
+run_command -fail "$scontrol update partitionname=[default_partition] DefaultTime=10"
+
+proc cleanup {} {
+	# Restore DefaultTime
+	reconfigure
+}
 #
 # Build input script file
 #
diff --git a/testsuite/expect/test17.62 b/testsuite/expect/test17.62
index a149b5ca40..9833769beb 100755
--- a/testsuite/expect/test17.62
+++ b/testsuite/expect/test17.62
@@ -34,7 +34,14 @@ set job_time      1
 set stdout        "/dev/null"
 set stderr        "/tmp/err"
 set job_id        0
-set node_list     [get_idle_node_in_part $partition]
+set node_list     [lindex [get_nodes_by_state] 0]
+
+proc cleanup {} {
+	global job_id bin_rm file_in
+
+	cancel_job $job_id
+	exec $bin_rm -fr $file_in
+}
 
 if {[param_contains [get_config_param "SelectTypeParameters"] "CR_*MEMORY"]} {
 	set job_mem  100
@@ -68,8 +75,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -104,8 +110,7 @@ foreach option [array names check_list] {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -120,9 +125,6 @@ foreach option [array names check_list] {
 	}
 }
 
-cancel_job $job_id
-if {$exit_code == 0} {
-	exec $bin_rm -fr $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.63 b/testsuite/expect/test17.63
index 8b56b84d9e..a6d09c027b 100755
--- a/testsuite/expect/test17.63
+++ b/testsuite/expect/test17.63
@@ -35,6 +35,12 @@ set needed_nodes 2
 set matches 0
 set ncpus ""
 
+proc cleanup {} {
+	global bin_rm file_in file_script file_out file_err
+
+	exec $bin_rm -f $file_in $file_script $file_out $file_err
+}
+
 if {[param_contains [get_config_param "SelectTypeParameters"] "CR_ONE_TASK_PER_CORE"]} {
 	skip "This test is incompatible SelectTypeParameters=CR_ONE_TASK_PER_CORE"
 }
@@ -52,8 +58,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -93,9 +98,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -137,8 +140,6 @@ if {[wait_for_file $file_out] == 0} {
 	fail "Job didn't produce the expected $file_out output file"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_script $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.64 b/testsuite/expect/test17.64
index 3588b842ba..f574eb1206 100755
--- a/testsuite/expect/test17.64
+++ b/testsuite/expect/test17.64
@@ -30,6 +30,7 @@ set exit_code    0
 set cwd          "[$bin_pwd]"
 set config_path  ""
 set tmp_job      "test$test_id\.bash"
+set job_id       0
 
 if {![is_super_user]} {
 	skip "This test can't be run except as SlurmUser"
@@ -40,10 +41,19 @@ if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"}
 }
 
 set config_path [get_conf_path]
-fail_on_error "Unable to get config path"
 set config_file $config_path/slurm.conf
 save_conf $config_file
 
+proc cleanup {} {
+	global job_id config_file bin_rm tmp_job
+
+	# Clean up vestigial files, jobs and restore original slurm.conf file
+	cancel_job $job_id
+	restore_conf $config_file
+	reconfigure
+	exec $bin_rm -f $tmp_job
+}
+
 log_info "---Checking sbatch uses mcs-label only for some jobs (ondemand mode)---"
 
 #
@@ -55,7 +65,7 @@ exec $bin_sed -i /^\[\t\s\]*PrivateData\[\t\s\]*=/Id $config_file
 exec $bin_echo -e "\nMCSPlugin=mcs/account" >> $config_file
 exec $bin_echo MCSParameters=ondemand,select,privatedata >> $config_file
 exec $bin_echo PrivateData=jobs,nodes >> $config_file
-reconfigure
+reconfigure -fail
 
 #
 # verify slurm conf parameters MCS
@@ -69,8 +79,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -86,7 +95,6 @@ log_info "---Checking sbatch fails with a bad mcs-label ---"
 
 set timeout $max_job_delay
 make_bash_script $tmp_job "sleep 10"
-set job_id 0
 spawn $sbatch -N1 --mcs-label=foo -t1 $tmp_job
 expect {
 	-re "Batch job submission failed: Invalid mcs_label specified" {
@@ -98,8 +106,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -121,8 +128,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -144,8 +150,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -165,8 +170,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -188,8 +192,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -215,8 +218,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -237,8 +239,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -262,8 +263,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -287,7 +287,7 @@ exec $bin_sed -i /^\[\t\s\]*PrivateData\[\t\s\]*=/Id $config_file
 exec $bin_echo -e "\nMCSPlugin=mcs/account" >> $config_file
 exec $bin_echo MCSParameters=enforced,noselect,privatedata >> $config_file
 exec $bin_echo PrivateData=jobs,nodes >> $config_file
-reconfigure
+reconfigure -fail
 
 ###### Check that sbatch uses mcs-label=account ######
 log_info "---Checking sbatch uses mcs-label=account---"
@@ -299,8 +299,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -327,8 +326,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -350,8 +348,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -377,22 +374,13 @@ expect {
 		log_debug "No mcs_label for this node. It was expected"
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-cancel_job $job_id
-
-# Clean up vestigial files and restore original slurm.conf file
-restore_conf $config_file
-reconfigure
-
-if {$exit_code == 0} {
-	exec $bin_rm $tmp_job
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test17.8 b/testsuite/expect/test17.8
index 4cb55a8a91..4eb1415119 100755
--- a/testsuite/expect/test17.8
+++ b/testsuite/expect/test17.8
@@ -33,21 +33,7 @@ set exit_code   0
 set file_in     "test$test_id.input"
 set time_set    13
 set time_get    0
-
-#
-# Since we make changes to configuration, call this function restore
-# configuration before exiting.
-#
-proc endit { } {
-	global exit_code bin_rm file_in
-	reconfigure
-	if {$exit_code == 0} {
-		exec $bin_rm -f $file_in
-		pass
-	} else {
-		fail "Exiting with exit code $exit_code"
-	}
-}
+set job_id      0
 
 #
 # We must be SlurmUser or root in order to change the partition MaxTime limit,
@@ -57,13 +43,24 @@ if {![is_super_user]} {
 	skip "You must be SlurmUser or root to run this test"
 }
 
+#
+# Since we make changes to configuration, define a cleanup function to restore
+# the configuration before exiting.
+#
+proc cleanup {} {
+	global job_id bin_rm file_in
+
+	cancel_job $job_id
+	reconfigure
+	exec $bin_rm -f $file_in
+}
+
 #
 # Ensure that MaxTime is UNLIMITED so this test won't fail due to trying to set
 # time limits greater than MaxTime.
 #
-set exit_code [set_partition_maximum_time_limit "" -1]
-if { $exit_code != 0 } {
-	endit
+if [set_partition_maximum_time_limit "" -1] {
+	fail "Unable to reset partition MaxTime to UNLIMITED"
 }
 
 #
@@ -80,7 +77,6 @@ make_bash_script $file_in "
 # Use scontrol to confirm time limit
 # Time format is "minutes"
 #
-set job_id 0
 spawn $sbatch -N1 --output=none --error=none --time=$time_set $file_in
 expect {
 	-re "Submitted batch job ($number)" {
@@ -88,18 +84,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 if { $job_id == 0 } {
-	log_error "Failed to submit job"
-	set exit_code 1
-	endit
+	fail "Failed to submit job"
 }
 
 spawn $scontrol show job $job_id
@@ -133,23 +125,19 @@ expect {
 		exp_continue
 	}
 	-re "time limit exceeds" {
-		reconfigure
+		incr exit_code [reconfigure]
 		log_warn "Unable to fully test time limits"
 		pass
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 if { $job_id == 0 } {
-	log_error "Failed to submit job"
-	set exit_code 1
-	endit
+	fail "Failed to submit job"
 }
 
 spawn $scontrol show job $job_id
@@ -183,18 +171,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 if { $job_id == 0 } {
-	log_error "Failed to submit job"
-	set exit_code 1
-	endit
+	fail "Failed to submit job"
 }
 
 spawn $scontrol show job $job_id
@@ -211,10 +195,7 @@ if {$time_get != 1500} {
 	log_error "sbatch failed to set time limit ($time_get != 1500)"
 	set exit_code 1
 }
-set rc [cancel_job $job_id]
-if { $rc != 0 } {
-	log_error "Unable to cancel job $job_id."
-	incr exit_code
-}
 
-endit
+if {$exit_code != 0} {
+        fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+}
diff --git a/testsuite/expect/test17.9 b/testsuite/expect/test17.9
index e239dafc2b..e336f388ce 100755
--- a/testsuite/expect/test17.9
+++ b/testsuite/expect/test17.9
@@ -28,9 +28,16 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.input"
 set name_set    "my_name"
+set job_id	0
+
+proc cleanup {} {
+	global job_id bin_rm file_in
+
+	cancel_job $job_id
+	exec $bin_rm -f $file_in
+}
 
 #
 # Delete left-over stdin/out/err files
@@ -45,7 +52,6 @@ make_bash_script $file_in "
 # Submit a slurm job that will execute 'sleep'
 # Use scontrol to confirm time limit
 #
-set job_id 0
 spawn $sbatch -N1 --output=none --error=none --job-name=$name_set $file_in
 expect {
 	-re "Submitted batch job ($number)" {
@@ -53,9 +59,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -79,10 +83,3 @@ expect {
 if {$matches != 1} {
 	fail "sbatch failed to set job name"
 }
-cancel_job $job_id
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test19.1 b/testsuite/expect/test19.1
index 9b6c3497f3..6d910c1338 100755
--- a/testsuite/expect/test19.1
+++ b/testsuite/expect/test19.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 spawn $strigger --help
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$matches < 2} {
 	fail "strigger failed to report help message"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test19.2 b/testsuite/expect/test19.2
index da1161db97..e3e144fb1d 100755
--- a/testsuite/expect/test19.2
+++ b/testsuite/expect/test19.2
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 spawn $strigger --usage
@@ -38,8 +37,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -49,6 +47,3 @@ expect {
 if {$matches < 1} {
 	fail "strigger failed to report usage message"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test19.3 b/testsuite/expect/test19.3
index 77b7eb3aec..d0f3545271 100755
--- a/testsuite/expect/test19.3
+++ b/testsuite/expect/test19.3
@@ -32,11 +32,19 @@ set exit_code    0
 set file_in      "test$test_id.input"
 set file_out     "test$test_id.output"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 #
 # get my uid and clear any vestigial triggers
 #
-
-set uid [stop_root_user]
+set uid [get_my_uid]
+if {$uid == 0} {
+	skip "This test can't be run as user root"
+}
 
 exec $strigger --clear --quiet --user=$uid
 
@@ -60,9 +68,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -84,9 +91,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -100,18 +106,15 @@ if {$matches != 1} {
 set strigger_pid [spawn $strigger --clear -v --user=$uid]
 expect {
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
 
diff --git a/testsuite/expect/test19.4 b/testsuite/expect/test19.4
index a81d4b77db..63f378d297 100755
--- a/testsuite/expect/test19.4
+++ b/testsuite/expect/test19.4
@@ -28,129 +28,50 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
 set file_in      "test$test_id.input"
 set file_out     "test$test_id.output"
 
-#
-# get my uid and clear any vestigial triggers
-#
-set uid [stop_root_user]
-
-exec $strigger --clear --quiet --user=$uid
+set uid [get_my_uid]
+set user [get_my_user_name]
+if {![regexp "${user}\\($number\\)" [get_config_param "SlurmUser"]] || $user eq "root"} {
+	skip "This test must run as the SlurmUser but this user cannot be root"
+}
 
 #
 # Build input script file
 #
 set cwd "[$bin_pwd]"
 exec $bin_rm -f $file_in $file_out
-make_bash_script $file_in "$bin_echo RECONFIG >$cwd/$file_out"
+make_bash_script $file_in "$bin_echo JOB COMPLETED >$cwd/$file_out"
 
-set disabled 0
-set matches  0
-set strigger_pid [spawn $strigger --set -v -offset=0 --reconfig --program=$cwd/$file_in]
-expect {
-	-re "permission denied" {
-		set disabled 1
-		exp_continue
-	}
-	-re "trigger set" {
-		incr matches
-		exp_continue
-	}
-	timeout {
-		log_error "strigger not responding"
-		slow_kill $strigger_pid
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-if {$disabled == 1} {
-	exec $bin_rm -f $file_in
-	skip "Current configuration prevents setting triggers. Need to run as SlurmUser or make SlurmUser=root"
-}
-if {$matches == 0} {
-	fail "Trigger creation failure"
-}
+proc cleanup {} {
+	global bin_rm file_in file_out strigger uid
 
-set matches 0
-set strigger_pid [spawn $strigger --get -v --reconfig --user=$uid]
-expect {
-	-re "$file_in" {
-		incr matches
-		exp_continue
-	}
-	timeout {
-		log_error "strigger not responding"
-		slow_kill $strigger_pid
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-if {$matches == 0} {
-	log_error "Trigger get failure"
-	set exit_code 1
+	run_command -none -nolog "$strigger --clear --reconfig --user=$uid --quiet"
+	exec $bin_rm -f $file_in $file_out
 }
 
-#
-# Try to trigger event
-#
-set invalid 0
-spawn $scontrol reconfig
-expect {
-	-re "Invalid user" {
-		set invalid 1
-		exp_continue
-	}
-	eof {
-		wait
-	}
-}
-if {$invalid == 0} {
-#	Add delay for slurmctld to process triggers (every 15 secs)
-	exec sleep 15
+run_command -fail "$strigger --clear --quiet --user=$uid"
 
-#	Plus time for cross-platform NSF delays
-	if {[wait_for_file $file_out] != 0} {
-		log_error "File $file_out is missing"
-		set exit_code 1
-	} else {
-		set reconfig 0
-		spawn $bin_cat $file_out
-		expect {
-			-re "RECONFIG" {
-				set reconfig 1
-				exp_continue
-			}
-			eof {
-				wait
-			}
-		}
-		if {$reconfig == 0} {
-			log_error "File $file_out contents are bad"
-			set exit_code 1
-		}
-	}
+# Submit a job and create a trigger on a job completion event
+set job_id [submit_job -fail "--wrap \"$bin_sleep 60\""]
+wait_for_job -fail $job_id "RUNNING"
+if {![regexp "trigger set" [run_command_output -fail "$strigger --set -v --jobid=$job_id --fini --program=$cwd/$file_in"]]} {
+	fail "Trigger creation failure"
 }
 
-set strigger_pid [spawn $strigger --clear -v --reconfig --user=$uid]
-expect {
-	timeout {
-		log_error "strigger not responding"
-		slow_kill $strigger_pid
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
+# Verify that the trigger has been created
+if {![regexp "$file_in" [run_command_output -fail "$strigger --get -v --jobid=$job_id --fini --user=$uid"]]} {
+	fail "Trigger get failure"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+#
+# Cancel the job to trigger a job completion event
+#
+run_command -fail "$scancel $job_id"
+# Triggers are only processed once every 15 seconds by default
+if [wait_for_file -timeout 30 $file_out] {
+	fail "Expected trigger output file ($file_out) did not appear within the expected timeframe (30s)"
+} elseif {![regexp "JOB COMPLETED" [run_command_output -fail "$bin_cat $file_out"]]} {
+	fail "Trigger output file ($file_out) does not contain the expected contents"
 }
diff --git a/testsuite/expect/test19.5 b/testsuite/expect/test19.5
index fc5c402198..952a63331c 100755
--- a/testsuite/expect/test19.5
+++ b/testsuite/expect/test19.5
@@ -34,11 +34,22 @@ set file_in_fini  "test$test_id.fini_input"
 set file_in_time  "test$test_id.time_input"
 set file_out_fini "test$test_id.fini_output"
 set file_out_time "test$test_id.time_output"
+set job_id 0
+
+proc cleanup {} {
+	global bin_rm file_in file_in_fini file_in_time job_id
+
+	cancel_job $job_id
+	exec $bin_rm -f $file_in $file_in_fini $file_in_time
+}
 
 #
 # get my uid and clear any vestigial triggers
 #
-set uid [stop_root_user]
+set uid [get_my_uid]
+if {$uid == 0} {
+	skip "This test can't be run as user root"
+}
 exec $strigger --clear --quiet --user=$uid
 
 #
@@ -46,7 +57,6 @@ exec $strigger --clear --quiet --user=$uid
 #
 make_bash_script $file_in "$srun sleep 60"
 
-set job_id 0
 spawn $sbatch --output=/dev/null -t2 $file_in
 expect {
 	-re "Submitted batch job ($number)" {
@@ -89,9 +99,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -115,9 +124,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -136,9 +144,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -222,11 +229,7 @@ if {[wait_for_file $file_out_fini] != 0} {
 	}
 }
 
-cancel_job $job_id
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_in_fini $file_in_time
-	exec $bin_rm -f $file_out_fini $file_out_time
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
 
diff --git a/testsuite/expect/test19.6 b/testsuite/expect/test19.6
index ec8faedf67..4d0f57b0d9 100755
--- a/testsuite/expect/test19.6
+++ b/testsuite/expect/test19.6
@@ -35,11 +35,23 @@ set file_in_time     "test$test_id.time_input"
 set file_in_up       "test$test_id.up_input"
 set file_in_down     "test$test_id.down_input"
 set file_in_reconfig "test$test_id.reconfig_input"
+set job_id           0
+
+proc cleanup {} {
+	global bin_rm file_in file_in_fini file_in_time file_in_up file_in_down
+	global file_in_reconfig job_id
+
+	cancel_job $job_id
+	exec $bin_rm -f $file_in $file_in_fini $file_in_time $file_in_up $file_in_down $file_in_reconfig
+}
 
 #
 # get my uid and clear any vestigial triggers
 #
-set uid [stop_root_user]
+set uid [get_my_uid]
+if {$uid == 0} {
+	skip "This test can't be run as user root"
+}
 exec $strigger --clear --quiet --user=$uid
 
 #
@@ -53,7 +65,6 @@ make_bash_script $file_in_up       "sleep 1"
 make_bash_script $file_in_down     "sleep 1"
 make_bash_script $file_in_reconfig "sleep 1"
 
-set job_id 0
 spawn $sbatch --output=/dev/null -t1 $file_in
 expect {
 	-re "Submitted batch job ($number)" {
@@ -88,9 +99,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -114,9 +124,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -135,9 +144,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -159,9 +167,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -180,9 +187,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -200,9 +206,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -224,9 +229,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -248,9 +252,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -279,9 +282,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -307,9 +309,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -335,9 +336,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -358,9 +358,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -382,9 +381,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -395,10 +393,7 @@ if {$node_matches != 0} {
 	set exit_code 1
 }
 
-cancel_job $job_id
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_in_fini $file_in_time $file_in_up $file_in_down $file_in_reconfig
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
 
diff --git a/testsuite/expect/test19.7 b/testsuite/expect/test19.7
index a8c73d66cd..2eef29e2b1 100755
--- a/testsuite/expect/test19.7
+++ b/testsuite/expect/test19.7
@@ -36,7 +36,19 @@ set file_out         "test$test_id.output"
 #
 # get my uid and clear any vestigial triggers
 #
-set uid [stop_root_user]
+set uid [get_my_uid]
+if {$uid == 0} {
+	skip "This test can't be run as user root"
+}
+
+proc cleanup {} {
+	global bin_rm file_in file_in_idle file_out strigger uid
+
+	exec $bin_rm -f $file_in $file_in_idle $file_out
+
+	# clear any vestigial triggers
+	exec $strigger --clear --quiet --user=$uid
+}
 
 exec $strigger --clear --quiet --user=$uid
 
@@ -83,9 +95,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -112,9 +123,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -159,9 +169,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger not responding"
 		slow_kill $strigger_pid
-		set exit_code 1
+		fail "strigger not responding"
 	}
 	eof {
 		wait
@@ -172,11 +181,6 @@ if {$idle_matches != 0} {
 	set exit_code 1
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_in_idle $file_out
-}
-# clear any vestigial triggers
-exec $strigger --clear --quiet --user=$uid
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test19.8 b/testsuite/expect/test19.8
index ee76c89ffd..bd1f9a8bf4 100755
--- a/testsuite/expect/test19.8
+++ b/testsuite/expect/test19.8
@@ -32,11 +32,19 @@ set cwd               "[$bin_pwd]"
 set permission        0
 set exit_code         0
 
+proc cleanup {} {
+	global bin_rm trigger_file_in trigger_file_out
+
+	exec $bin_rm -f $trigger_file_in $trigger_file_out
+}
+
 #
 # get my uid and clear any vestigial triggers
 #
-
-set uid [stop_root_user]
+set uid [get_my_uid]
+if {$uid == 0} {
+	skip "This test can't be run as user root"
+}
 
 exec $strigger --clear --quiet --user=$uid
 
@@ -58,8 +66,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger is not responding"
-		set exit_code 1
+		fail "strigger is not responding"
 	}
 	eof {
 		wait
@@ -82,8 +89,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger is not responding"
-		set exit_code 1
+		fail "strigger is not responding"
 	}
 	eof {
 		wait
@@ -102,8 +108,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger is not responding"
-		set exit_code 1
+		fail "strigger is not responding"
 	}
 	eof {
 		wait
@@ -118,16 +123,13 @@ set match 0
 spawn $strigger --clear -v --user=$uid
 expect {
 	timeout {
-		log_error "strigger is not responding"
-		set exit_code 1
+		fail "strigger is not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $trigger_file_in $trigger_file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test19.9 b/testsuite/expect/test19.9
index 0734e781e4..d95265d52c 100755
--- a/testsuite/expect/test19.9
+++ b/testsuite/expect/test19.9
@@ -32,10 +32,19 @@ set cwd               "[$bin_pwd]"
 set permission        0
 set exit_code         0
 
+proc cleanup {} {
+	global bin_rm trigger_file_out trigger_file_in
+
+	exec $bin_rm -f $trigger_file_out $trigger_file_in
+}
+
 #
 # get my uid and clear any vestigial triggers
 #
-set uid [stop_root_user]
+set uid [get_my_uid]
+if {$uid == 0} {
+	skip "This test can't be run as user root"
+}
 
 exec $strigger --clear --quiet --user=$uid
 
@@ -57,8 +66,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger is not responding\b"
-		set exit_code 1
+		fail "strigger is not responding\b"
 	}
 	eof {
 		wait
@@ -82,8 +90,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "strigger is not responding"
-		set exit_code 1
+		fail "strigger is not responding"
 	}
 	eof {
 		wait
@@ -98,16 +105,13 @@ set match 0
 spawn $strigger --clear -v --user=$uid
 expect {
 	timeout {
-		log_error "strigger is not responding"
-		set exit_code 1
+		fail "strigger is not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $trigger_file_out $trigger_file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test2.1 b/testsuite/expect/test2.1
index 8d5aa59d0f..f6104b877b 100755
--- a/testsuite/expect/test2.1
+++ b/testsuite/expect/test2.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set version     0
 
 #
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$version != 1} {
 	fail "Did not get proper scontrol version number"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test2.10 b/testsuite/expect/test2.10
index fef0b26605..d1342f9ee8 100755
--- a/testsuite/expect/test2.10
+++ b/testsuite/expect/test2.10
@@ -28,8 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 #
 # Report all slurm nodes, multi-line (default) mode
 #
@@ -41,16 +39,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "scontrol show node command failed"
-	set exit_code 1
+	fail "scontrol show node command failed"
 }
 
 #
@@ -64,8 +60,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -74,7 +69,3 @@ expect {
 if {$matches != 0} {
 	fail "scontrol --oneliner mode failed"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test2.11 b/testsuite/expect/test2.11
index e2317f46c3..28e62e38d9 100755
--- a/testsuite/expect/test2.11
+++ b/testsuite/expect/test2.11
@@ -28,13 +28,18 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set job_id      0
 set step_id	0
 set scontrol_id 0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 # Delete left-over stdout file
 file delete $file_out
 
@@ -59,9 +64,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -104,9 +108,3 @@ if {[wait_for_file $file_out] == 0} {
 if {$matches != 3} {
 	fail "scontrol listpids output error"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test2.12 b/testsuite/expect/test2.12
index 899a6a0907..5c25b08378 100755
--- a/testsuite/expect/test2.12
+++ b/testsuite/expect/test2.12
@@ -28,8 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 # test if running with Topology/Tree
 set topology_tree 0
 log_user 0
@@ -62,8 +60,7 @@ expect {
 		incr matches
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -85,8 +82,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -95,7 +91,3 @@ expect {
 if {$matches != 1} {
 	fail "scontrol topology with switch name filter failed"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test2.13 b/testsuite/expect/test2.13
index 77d048859f..a90a4bb157 100755
--- a/testsuite/expect/test2.13
+++ b/testsuite/expect/test2.13
@@ -36,6 +36,12 @@ set step_id       0
 set orig_time     0
 set new_time      0
 
+proc cleanup {} {
+	global bin_rm file_in1 file_in2 file_out
+
+	exec $bin_rm -f $file_in1 $file_in2 $file_out
+}
+
 #
 # Build input batch file
 #
@@ -67,9 +73,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -96,8 +101,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -114,8 +118,7 @@ if {$orig_time != 5} {
 spawn $scontrol update StepId=$job_id TimeLimit=1
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -132,8 +135,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -167,9 +169,6 @@ expect {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2 $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
-
diff --git a/testsuite/expect/test2.14 b/testsuite/expect/test2.14
index 089baf4d82..f883b5a6c2 100755
--- a/testsuite/expect/test2.14
+++ b/testsuite/expect/test2.14
@@ -35,11 +35,17 @@ set file_out2        "test$test_id.output2"
 set job_id           0
 set node_cnt         2
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_out2
+
+	exec $bin_rm -f $file_in $file_out $file_out2
+}
+
 if {[get_config_param "FrontendName"] ne "MISSING"} {
     skip "This test is incompatible with front-end systems"
 }
 
-set available [available_nodes]
+set available [llength [get_nodes_by_state idle,alloc,comp]]
 if {$available < $node_cnt} {
     skip "Not enough nodes currently available ($available avail, $node_cnt needed)"
 }
@@ -69,8 +75,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -141,8 +146,6 @@ if {$node_count != 3} {
 	fail "Invalid node count ($node_count != 3)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_out2
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test2.15 b/testsuite/expect/test2.15
index 9824214507..b6a4333119 100755
--- a/testsuite/expect/test2.15
+++ b/testsuite/expect/test2.15
@@ -28,10 +28,15 @@
 ############################################################################
 source ./globals
 
-set exit_code        0
 set file_in          "test$test_id.bash"
 set job_id           0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 } elseif {[get_config_param "KillOnBadExit"] == 1} {
@@ -41,7 +46,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 }
 
 set node_cnt 2
-set available [available_nodes]
+set available [llength [get_nodes_by_state idle,alloc,comp]]
 if {$available < $node_cnt} {
 	skip "Not enough nodes currently available ($available avail, $node_cnt needed)"
 }
@@ -89,9 +94,8 @@ expect {
 		}
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -105,8 +109,7 @@ spawn $scontrol update jobid=$job_id nodelist=$host
 set scontrol_id $spawn_id
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -126,9 +129,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -137,9 +139,3 @@ expect {
 if {$matches != 1} {
 	fail "Task 0 did not run to completion after other tasks killed"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test2.16 b/testsuite/expect/test2.16
index 0c9766ce96..123c9f6f19 100755
--- a/testsuite/expect/test2.16
+++ b/testsuite/expect/test2.16
@@ -51,8 +51,7 @@ proc set_part_val {part_type part_val} {
 			set exit_code 1
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -72,8 +71,7 @@ proc check_part {part_type part_val} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -98,8 +96,7 @@ proc delete_part { } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -114,8 +111,7 @@ proc delete_part { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -129,6 +125,13 @@ proc delete_part { } {
 
 }
 
+proc cleanup {} {
+	#
+	# Delete the partition and the Account
+	#
+	delete_part
+}
+
 spawn $scontrol create partition=$part_name
 expect {
 	-re "error" {
@@ -136,8 +139,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol is not reponding"
-		set exit_code 1
+		fail "scontrol is not reponding"
 	}
 	eof {
 		wait
@@ -152,8 +154,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -204,11 +205,6 @@ set_part_val denyaccount none
 #
 check_part DenyAccounts none
 
-#
-# Delete the partition and the Account
-#
-delete_part
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test2.17 b/testsuite/expect/test2.17
index df792072be..06a0779f70 100755
--- a/testsuite/expect/test2.17
+++ b/testsuite/expect/test2.17
@@ -51,8 +51,7 @@ proc set_part_val {part_type part_val} {
 			set exit_code 1
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -72,8 +71,7 @@ proc check_part {part_type part_val} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -99,8 +97,7 @@ proc delete_part { } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -115,8 +112,7 @@ proc delete_part { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -130,6 +126,14 @@ proc delete_part { } {
 
 }
 
+proc cleanup {} {
+
+	#
+	# Delete partition and Qos
+	#
+	delete_part
+}
+
 spawn $scontrol create partition=$part_name
 expect {
 	-re "error" {
@@ -137,8 +141,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol is not reponding"
-		set exit_code 1
+		fail "scontrol is not reponding"
 	}
 	eof {
 		wait
@@ -153,8 +156,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -206,11 +208,6 @@ set_part_val DenyQos none
 #
 check_part DenyQos none
 
-#
-# Delete partition and Qos
-#
-delete_part
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test2.18 b/testsuite/expect/test2.18
index 1165ebeb05..10c8a5ebed 100755
--- a/testsuite/expect/test2.18
+++ b/testsuite/expect/test2.18
@@ -54,8 +54,7 @@ proc set_part_val {part_type part_val} {
 			set exit_code 1
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -127,8 +126,7 @@ proc create_acct { acct } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -138,8 +136,7 @@ proc create_acct { acct } {
 	spawn $sacctmgr -i create user $user_name account=$acct cluster=$cluster_name
 	expect {
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -173,8 +170,7 @@ proc test_part { acct part acct_con } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun is not responding"
-			set exit_code 1
+			fail "srun is not responding"
 		}
 		eof {
 			wait
@@ -188,7 +184,7 @@ proc test_part { acct part acct_con } {
 cleanup
 
 set user_name [get_my_user_name]
-set node_name [get_idle_node_in_part]
+set node_name [lindex [get_nodes_by_state] 0]
 set cluster_name [get_config_param "ClusterName"]
 
 # NOTE: acct_good should always work and
@@ -212,8 +208,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol is not reponding"
-		set exit_code 1
+		fail "scontrol is not reponding"
 	}
 	eof {
 		wait
@@ -264,11 +259,8 @@ test_part $acct_good $part_name 0
 test_part $acct_bad $part_name 1
 
 
+# Sleep before automatically calling cleanup
 sleep 5
-# Delete partition and accounts
-if {[cleanup] != 1} {
-	fail "Account was not deleted"
-}
 
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
diff --git a/testsuite/expect/test2.19 b/testsuite/expect/test2.19
index fc2a4549ec..ae0f8412b7 100755
--- a/testsuite/expect/test2.19
+++ b/testsuite/expect/test2.19
@@ -57,8 +57,7 @@ proc set_part_val {part_type part_val} {
 			set exit_code 1
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -144,8 +143,7 @@ proc create_qos { acct qos } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -160,8 +158,7 @@ proc create_qos { acct qos } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -172,8 +169,7 @@ proc create_qos { acct qos } {
 	spawn $sacctmgr -i create user $user_name account=$acct cluster=$cluster_name
 	expect {
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -204,8 +200,7 @@ proc test_part {acct qos part qos_con } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun is not responding"
-			set exit_code 1
+			fail "srun is not responding"
 		}
 		eof {
 			wait
@@ -218,7 +213,7 @@ cleanup
 
 # Setup
 set user_name [get_my_user_name]
-set node_name [get_idle_node_in_part]
+set node_name [lindex [get_nodes_by_state] 0]
 set cluster_name [get_config_param "ClusterName"]
 
 # NOTE: qos_good should always work and
@@ -243,8 +238,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol is not reponding"
-		set exit_code 1
+		fail "scontrol is not reponding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test2.2 b/testsuite/expect/test2.2
index a5479a1126..660c73bd7d 100755
--- a/testsuite/expect/test2.2
+++ b/testsuite/expect/test2.2
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -50,8 +49,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -61,6 +59,3 @@ expect {
 if {$matches != 3} {
 	fail "scontrol help message not as expected"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test2.20 b/testsuite/expect/test2.20
index 0e22aba154..16d5dea95e 100755
--- a/testsuite/expect/test2.20
+++ b/testsuite/expect/test2.20
@@ -51,8 +51,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -86,8 +85,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -137,8 +135,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test2.21 b/testsuite/expect/test2.21
index 4c7612a915..2eb6634176 100755
--- a/testsuite/expect/test2.21
+++ b/testsuite/expect/test2.21
@@ -31,6 +31,12 @@ set fail_script        "test$test_id\.fail"
 set job_id             0
 set exit_code          0
 
+proc cleanup {} {
+	global bin_rm complete_script fail_script
+
+	exec $bin_rm -f $complete_script $fail_script
+}
+
 regexp "($number)" [get_config_param "MinJobAge"] {} min_age
 if {$min_age < 10} {
 	skip "MinJobAge too low for this test ($min_age < 10)"
@@ -44,14 +50,12 @@ make_bash_script $complete_script "$bin_sleep 20"
 make_bash_script $fail_script "BadCommand"
 
 proc requeue_job { id } {
-
 	global scontrol exit_code
 
 	spawn $scontrol requeue $id
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -69,8 +73,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -110,8 +113,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -140,8 +142,6 @@ if {![check_job_state $job_id PENDING|RUNNING]} {
 
 cancel_job $job_id
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $complete_script $fail_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test2.22 b/testsuite/expect/test2.22
index a885b831dc..19f3478003 100755
--- a/testsuite/expect/test2.22
+++ b/testsuite/expect/test2.22
@@ -30,6 +30,13 @@ set script             "test$test_id.bash"
 set job_id             0
 set exit_code          0
 
+proc cleanup {} {
+	global bin_rm script job_id
+
+	cancel_job $job_id
+	exec $bin_rm -f $script
+}
+
 regexp "($number)" [get_config_param "MinJobAge"] {} min_age
 if {$min_age < 10} {
 	skip "MinJobAge too low for this test ($min_age < 10)"
@@ -41,7 +48,6 @@ exec $bin_rm -f $script
 make_bash_script $script "$bin_sleep 20"
 
 proc check_hold { job } {
-
 	global scontrol exit_code
 
 	set hold 0
@@ -52,8 +58,7 @@ proc check_hold { job } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -67,7 +72,6 @@ proc check_hold { job } {
 }
 
 proc check_release { job } {
-
 	global scontrol number exit_code
 
 	set priority 0
@@ -78,8 +82,7 @@ proc check_release { job } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -99,8 +102,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1get_min_job_age
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -120,8 +122,7 @@ if {[wait_for_job $job_id "DONE"] != 0} {
 spawn $scontrol requeuehold $job_id
 expect {
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -140,8 +141,7 @@ if {![check_job_state $job_id PENDING]} {
 spawn $scontrol release $job_id
 expect {
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -150,10 +150,6 @@ expect {
 
 check_release $job_id
 
-cancel_job $job_id
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test2.23 b/testsuite/expect/test2.23
index 96a02e5029..60cb59fee5 100755
--- a/testsuite/expect/test2.23
+++ b/testsuite/expect/test2.23
@@ -30,6 +30,13 @@ set script             "test$test_id\.bash"
 set job_id             0
 set exit_code          0
 
+proc cleanup {} {
+	global bin_rm script job_id
+
+	cancel_job $job_id
+	exec $bin_rm -f $script
+}
+
 regexp "($number)" [get_config_param "MinJobAge"] {} min_age
 if {$min_age < 10} {
 	skip "MinJobAge too low for this test ($min_age < 10)"
@@ -52,8 +59,7 @@ proc check_release { job } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -64,7 +70,6 @@ proc check_release { job } {
 		log_error "Priority was not set to a non zero value after it was released"
 		set exit_code 1
 	}
-
 }
 
 spawn $sbatch -N1 -t1 -o /dev/null -e /dev/null $script
@@ -74,8 +79,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -95,8 +99,7 @@ if {[wait_for_job $job_id "DONE"] != 0} {
 spawn $scontrol requeuehold State=SpecialExit $job_id
 expect {
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -111,8 +114,7 @@ if {![check_job_state $job_id SPECIAL_EXIT]} {
 spawn $scontrol release $job_id
 expect {
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -121,10 +123,6 @@ expect {
 
 check_release $job_id
 
-cancel_job $job_id
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test2.24 b/testsuite/expect/test2.24
index 0ea0dc83e7..f078c513d3 100755
--- a/testsuite/expect/test2.24
+++ b/testsuite/expect/test2.24
@@ -84,8 +84,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -119,8 +118,7 @@ foreach opt [array names conf_val] {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test2.25 b/testsuite/expect/test2.25
index 2dd8565756..bce015098d 100755
--- a/testsuite/expect/test2.25
+++ b/testsuite/expect/test2.25
@@ -38,7 +38,7 @@ if {![is_super_user]} {
 }
 
 proc mod_assoc_vals { } {
-	global sacctmgr test_acct test_user exit_code
+	global sacctmgr test_acct test_user
 
 	set modified 0
 	spawn $sacctmgr mod -i account $test_acct where user=$test_user set \
@@ -49,8 +49,7 @@ proc mod_assoc_vals { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -63,7 +62,7 @@ proc mod_assoc_vals { } {
 }
 
 proc clear_assoc_vals { } {
-	global sacctmgr test_acct test_user exit_code
+	global sacctmgr test_acct test_user
 
 	set modified 0
 	spawn $sacctmgr mod -i account $test_acct where user=$test_user set \
@@ -74,8 +73,7 @@ proc clear_assoc_vals { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -88,7 +86,7 @@ proc clear_assoc_vals { } {
 }
 
 proc delete_test_acct { } {
-	global test_acct sacctmgr exit_code
+	global test_acct sacctmgr
 
 	set deleted 0
 	spawn $sacctmgr delete -i account $test_acct
@@ -98,8 +96,7 @@ proc delete_test_acct { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -124,8 +121,7 @@ if {[get_config_param "AccountingStorageType"] eq "accounting_storage/slurmdbd"}
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -145,8 +141,7 @@ if {[get_config_param "AccountingStorageType"] eq "accounting_storage/slurmdbd"}
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not reponding"
-			set exit_code 1
+			fail "sacctmgr is not reponding"
 		}
 		eof {
 			wait
@@ -181,8 +176,7 @@ if {[get_config_param "AccountingStorageType"] eq "accounting_storage/slurmdbd"}
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -225,8 +219,7 @@ if {[get_config_param "AccountingStorageType"] eq "accounting_storage/slurmdbd"}
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -270,8 +263,7 @@ if {[get_config_param "AccountingStorageType"] eq "accounting_storage/slurmdbd"}
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -307,8 +299,7 @@ if {[get_config_param "AccountingStorageType"] eq "accounting_storage/slurmdbd"}
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test2.26 b/testsuite/expect/test2.26
index 2333bf1b46..da2b23a207 100755
--- a/testsuite/expect/test2.26
+++ b/testsuite/expect/test2.26
@@ -42,9 +42,7 @@ proc top_enabled { } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
-			exp_continue
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -65,9 +63,7 @@ proc submit_job { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
-			exp_continue
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -96,9 +92,7 @@ proc load_job_prio { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
-			exp_continue
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test2.27 b/testsuite/expect/test2.27
index 539dc5798e..9f6600591a 100755
--- a/testsuite/expect/test2.27
+++ b/testsuite/expect/test2.27
@@ -26,7 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code        0
 set job_id           0
 set node_cnt         1
 set user             [get_my_user_name]
@@ -37,7 +36,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
 
-set available [available_nodes]
+set available [llength [get_nodes_by_state idle,alloc,comp]]
 if {$available < $node_cnt} {
 	skip "Not enough nodes currently available ($available avail, $node_cnt needed)"
 }
@@ -129,8 +128,6 @@ proc update { job_id args regex } {
 }
 
 set config_path [get_conf_path]
-fail_on_error "Unable to determine configuration path"
-
 save_conf $config_path/slurm.conf
 
 proc test_it {} {
@@ -179,7 +176,7 @@ proc test_it {} {
 # Test w/out MailDomain
 set domain ""
 exec $bin_sed -i "s/^\\(MailDomain.*\\)/#\\1/Ig" $config_path/slurm.conf
-reconfigure
+reconfigure -fail
 test_it
 
 
@@ -189,5 +186,5 @@ set mail_conf "
 MailDomain = $domain
 "
 exec $bin_echo $mail_conf >> $config_path/slurm.conf
-reconfigure
+reconfigure -fail
 test_it
diff --git a/testsuite/expect/test2.3 b/testsuite/expect/test2.3
index e5e0dca457..c0fdd700a0 100755
--- a/testsuite/expect/test2.3
+++ b/testsuite/expect/test2.3
@@ -29,7 +29,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -46,8 +45,7 @@ expect {
 		}
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -57,6 +55,3 @@ expect {
 if {$matches != 1} {
 	fail "scontrol ping output error ($matches != 1)"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test2.4 b/testsuite/expect/test2.4
index 9a93d9eee0..af855107ef 100755
--- a/testsuite/expect/test2.4
+++ b/testsuite/expect/test2.4
@@ -61,8 +61,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -100,8 +99,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -147,8 +145,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test2.5 b/testsuite/expect/test2.5
index 17ab6e27d2..875af64c87 100755
--- a/testsuite/expect/test2.5
+++ b/testsuite/expect/test2.5
@@ -51,8 +51,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -81,8 +80,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -106,8 +104,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -131,8 +128,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -154,8 +150,7 @@ if {$matches < 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -180,8 +175,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -205,8 +199,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -232,8 +225,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test2.6 b/testsuite/expect/test2.6
index bfce36d95a..a34e2843e1 100755
--- a/testsuite/expect/test2.6
+++ b/testsuite/expect/test2.6
@@ -45,8 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -73,8 +72,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test2.7 b/testsuite/expect/test2.7
index 9f322c9946..e6e8d49759 100755
--- a/testsuite/expect/test2.7
+++ b/testsuite/expect/test2.7
@@ -35,6 +35,12 @@ set file_err    "test$test_id.error"
 set job_id      0
 set scontrol_id 0
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 # Delete left-over stdout/err files
 file delete $file_out $file_err
 
@@ -53,9 +59,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -123,8 +128,6 @@ if {[wait_for_file $file_err] == 0} {
 if {$job_id != $scontrol_id} {
 	fail "scontrol pidinfo error"
 }
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test2.8 b/testsuite/expect/test2.8
index ec65cae0ff..d3ad74f576 100755
--- a/testsuite/expect/test2.8
+++ b/testsuite/expect/test2.8
@@ -34,7 +34,7 @@ set job_id1     0
 set job_id2     0
 set step_id	0
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {[check_config_select "linear"]} {
 	if {$nb_nodes < 2} {
 		skip "This test is incompatible with select/linear and only one node"
@@ -45,20 +45,12 @@ if {[check_config_select "linear"]} {
 	}
 }
 
-proc end_it {code} {
+proc cleanup {} {
 	global job_id1 job_id2 bin_rm test_id exit_code
 
-	if {$job_id1} {
-		cancel_job $job_id1
-	}
-	if {$job_id2} {
-		cancel_job $job_id2
-	}
+	cancel_job $job_id1
+	cancel_job $job_id2
 	exec $bin_rm -f slurm-$job_id1.sh $test_id.sh
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
 }
 
 #
@@ -134,8 +126,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -153,16 +144,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 2} {
-	log_error "scontrol failed to find matching job ($matches != 2)"
-	end_it 1
+	fail "scontrol failed to find matching job ($matches != 2)"
 }
 
 #
@@ -181,8 +170,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -200,8 +188,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -210,8 +197,7 @@ expect {
 }
 set match_target 4
 if {$matches != $match_target} {
-	log_error "scontrol failed to find matching job ($matches != $match_target)"
-	end_it 1
+	fail "scontrol failed to find matching job ($matches != $match_target)"
 }
 
 #
@@ -230,8 +216,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -249,8 +234,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -260,8 +244,7 @@ expect {
 
 set match_target 4
 if {$matches != $match_target} {
-	log_error "scontrol failed to find matching job ($matches != $match_target)"
-	end_it 1
+	fail "scontrol failed to find matching job ($matches != $match_target)"
 }
 
 #
@@ -275,21 +258,17 @@ expect {
 		exp_continue
 	}
 	-re "JobId=" {
-		log_error "scontrol filter by job id"
-		end_it 1
-		exp_continue
+		fail "scontrol filter by job id"
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "scontrol failed to find requested job"
-	end_it 1
+	fail "scontrol failed to find requested job"
 }
 
 #
@@ -308,16 +287,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "scontrol failed to find job step $job_id1.$step_id"
-	end_it 1
+	fail "scontrol failed to find job step $job_id1.$step_id"
 }
 
 #
@@ -331,21 +308,17 @@ expect {
 		exp_continue
 	}
 	-re "StepId=" {
-		log_error "scontrol filter by step id"
-		end_it 1
-		exp_continue
+		fail "scontrol filter by step id"
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "scontrol failed to specific job step"
-	end_it 1
+	fail "scontrol failed to specific job step"
 }
 
 #
@@ -357,9 +330,7 @@ set job_id3 [expr $job_id1 + 10000]
 spawn $scontrol show step $job_id3.$step_id
 expect {
 	-re "StepId=$job_id3\\.$step_id " {
-		log_error "scontrol found unexpected job step"
-		end_it 1
-		exp_continue
+		fail "scontrol found unexpected job step"
 	}
 	-re "Invalid job id" {
 		log_debug "No worries, error expected"
@@ -367,21 +338,17 @@ expect {
 		exp_continue
 	}
 	-re "StepId=" {
-		log_error "scontrol filter by step id"
-		end_it 1
-		exp_continue
+		fail "scontrol filter by step id"
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "scontrol found unexpected job step"
-	end_it 1
+	fail "scontrol found unexpected job step"
 }
 
 
@@ -396,16 +363,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "scontrol failed to write batch script"
-	end_it 1
+	fail "scontrol failed to write batch script"
 }
 
 set matches 0
@@ -416,62 +381,54 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "scontrol failed to write batch script"
-	end_it 1
+	fail "scontrol failed to write batch script"
 }
 
 set matches 0
 spawn ls slurm-$job_id1.sh
 expect {
 	-re "ls: cannot access" {
-		end_it 1
+		fail "ls failure"
 	}
 	-re "slurm-$job_id1\\.sh" {
 		incr matches
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "Could not find file"
-	end_it 1
+	fail "Could not find file"
 }
 
 set matches 0
 spawn ls $test_id.sh
 expect {
 	-re "ls: cannot access" {
-		end_it 1
+		fail "ls failure"
 	}
 	-re "$test_id\\.sh" {
 		incr matches
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "Could not find file"
-	end_it 1
+	fail "Could not find file"
 }
-
-end_it 0
diff --git a/testsuite/expect/test2.9 b/testsuite/expect/test2.9
index be04711178..dee632b62e 100755
--- a/testsuite/expect/test2.9
+++ b/testsuite/expect/test2.9
@@ -28,8 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 #
 # Unless a job is hung in completing state, there is typically no output
 #
@@ -37,8 +35,7 @@ set exit_code   0
 spawn $scontrol completing
 expect {
 	-re "invalid keyword" {
-		log_error "scontrol did not recognize \'completing\' command"
-		set exit_code 1
+		fail "scontrol did not recognize \'completing\' command"
 	}
 	-re "Unable to contact" {
 		fail "Slurm appears to be down"
@@ -47,7 +44,3 @@ expect {
 		wait
 	}
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test20.1 b/testsuite/expect/test20.1
index 595f5a0e01..a7eb025736 100755
--- a/testsuite/expect/test20.1
+++ b/testsuite/expect/test20.1
@@ -33,6 +33,12 @@ set file_err	"test$test_id.error"
 set file_in	"test$test_id.input"
 set file_out	"test$test_id.output"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 if {[file executable $qsub] == 0} {
 	skip "$qsub not found"
 }
@@ -47,8 +53,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -98,8 +103,6 @@ if {$matches != 1} {
 	fail "Unexpected qsub error file contents"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test20.10 b/testsuite/expect/test20.10
index b7cc143385..761af243e1 100755
--- a/testsuite/expect/test20.10
+++ b/testsuite/expect/test20.10
@@ -26,8 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code  0
-
 if {[file executable $qrerun] == 0} {
 	skip "qrerun was not found"
 }
@@ -40,8 +38,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qrerun is not responding"
-		set exit_code 1
+		fail "qrerun is not responding"
 	}
 	eof {
 		wait
@@ -50,7 +47,3 @@ expect {
 if {$found != 1} {
 	fail "qrerun --help option failed"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test20.11 b/testsuite/expect/test20.11
index 291856ea38..201a8616ad 100755
--- a/testsuite/expect/test20.11
+++ b/testsuite/expect/test20.11
@@ -28,7 +28,12 @@ source ./globals
 
 set file_in    "test$test_id.input"
 set file_out   "test$test_id.output"
-set exit_code  0
+
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
 
 if {[file executable $qrerun] == 0} {
 	skip "qrerun was not found"
@@ -69,9 +74,3 @@ expect {
 if {$matches != 1} {
 	fail "qrerun did not return the man pages ($matches != 1)"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test20.12 b/testsuite/expect/test20.12
index 5a0cfefc34..9c72775c08 100755
--- a/testsuite/expect/test20.12
+++ b/testsuite/expect/test20.12
@@ -64,8 +64,7 @@ proc run_qsub { variable1_name variable1_expect_val variable2_name
 			exp_continue
 		}
 		timeout {
-			log_error "qsub not responding"
-			set exit_code 1
+			fail "qsub not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test20.13 b/testsuite/expect/test20.13
index c0c3e08942..2f54e3565c 100755
--- a/testsuite/expect/test20.13
+++ b/testsuite/expect/test20.13
@@ -31,6 +31,12 @@ set file_err	"test$test_id.error"
 set file_in	"test$test_id.input"
 set file_out	"test$test_id.output"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 if {[file executable $qsub] == 0} {
 	skip "$qsub not found"
 }
@@ -47,8 +53,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -70,8 +75,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -93,8 +97,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -110,8 +113,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -128,8 +130,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -153,8 +154,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -176,8 +176,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -199,8 +198,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -211,8 +209,6 @@ if {$matches != 1} {
 	fail "qsub -l h_vmem option did not set up correctly"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test20.15 b/testsuite/expect/test20.15
new file mode 100755
index 0000000000..ad23ed1f08
--- /dev/null
+++ b/testsuite/expect/test20.15
@@ -0,0 +1,60 @@
+#!/usr/bin/env expect
+############################################################################
+# Purpose: Test of Slurm functionality
+#          Test for seff
+############################################################################
+# Copyright (C) 2020 SchedMD LLC
+# Written by Marcin Stolarek <cinek@schedmd.com>
+#
+# This file is part of Slurm, a resource management program.
+# For details, see <https://slurm.schedmd.com/>.
+# Please also read the included file: DISCLAIMER.
+#
+# Slurm is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# Slurm is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+# details.
+#
+# You should have received a copy of the GNU General Public License along
+# with Slurm; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+############################################################################
+source ./globals
+
+if {[file executable $seff] == 0} {
+	skip "seff was not found"
+}
+
+set out [run_command_output -fail -xfail "$seff -h"]
+subtest {[regexp "Usage:" $out]} "seff -h should return Usage:"
+
+set job_id [submit_job -fail "-H --wrap=\"sleep 10\" -o /dev/null -e /dev/null"]
+wait_for_command_match "$sacct -n -j $job_id" "PENDING"
+set out [run_command_output -fail "$seff $job_id" ]
+subtest {[regexp "State: PENDING" $out]} "Job should be returned as in PENDING state by seff"
+subtest {[regexp "Cores: 1" $out]} "Job should be reported as 1 core"
+subtest {[regexp "Efficiency not available for jobs in the PENDING state." $out]} "Job should be reported as efficiency not available for PENDING state"
+
+run_command -fail "$scontrol release $job_id"
+wait_for_command_match  "$sacct -X -n -j $job_id" "RUNNING"
+
+set out [run_command_output -fail "$seff $job_id"]
+subtest {[regexp "State: RUNNING"  $out]} "Job should be reported as RUNNING by seff"
+subtest {[regexp "WARNING: Efficiency statistics may be misleading for RUNNING jobs." $out]} "seff output should contain warning about staistics for RUNNING job"
+
+wait_for_command_match "$sacct -X -n -j $job_id" "COMPLETED"
+set out [run_command_output -fail "$seff $job_id"]
+subtest {[regexp "State: COMPLETED"  $out]} "Job should be reported as COMPLETED by seff"
+subtest {[regexp "Cores: \(\\d+\)" $out {} cores] || \
+         [regexp "Cores per node: \(\\d+\)" $out {} cores]} "seff should report the number of cores (per node) based on the configuration"
+# On select/linear or other configs, cores could be > 1
+if {$cores > 5} {
+	subskip "Not subtesting CPU Efficency if Cores ($cores) > 5"
+} else {
+	subtest {[regexp -line "CPU Efficiency: 0.00% of 00:00:$cores\\d core-walltime" $out]} "Job efficiency should be 0.00% of >=10s*Cores core-walltime"
+}
diff --git a/testsuite/expect/test20.2 b/testsuite/expect/test20.2
index 468dd3b774..8ec0019328 100755
--- a/testsuite/expect/test20.2
+++ b/testsuite/expect/test20.2
@@ -28,12 +28,17 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in	"test$test_id.input"
 set file_out	"test$test_id.output"
 set file_err	"test$test_id.error"
 set job_name	"test$test_id"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 if {[file executable $qsub] == 0} {
 	skip "$qsub does not exists"
 }
@@ -53,8 +58,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -72,8 +76,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qstat not responding"
-		set exit_code 1
+		fail "qstat not responding"
 	}
 	eof {
 		wait
@@ -83,9 +86,3 @@ if {$matches != 1} {
 	fail "qstat failed to report job"
 }
 catch {exec $qdel $job_id}
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test20.3 b/testsuite/expect/test20.3
index 4331a6af0c..6def97ee97 100755
--- a/testsuite/expect/test20.3
+++ b/testsuite/expect/test20.3
@@ -33,6 +33,12 @@ set file_in	"test$test_id.input"
 set file_out	"test$test_id.output"
 set file_err	"test$test_id.error"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 if {[file executable $qsub] == 0} {
 	skip "$qsub does not exists"
 }
@@ -49,8 +55,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub not responding"
-		set exit_code 1
+		fail "qsub not responding"
 	}
 	eof {
 		wait
@@ -69,8 +74,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qdel not responding"
-		set exit_code 1
+		fail "qdel not responding"
 	}
 	eof {
 		catch wait reason
@@ -93,8 +97,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qdel not responding"
-		set exit_code 1
+		fail "qdel not responding"
 	}
 	eof {
 		catch wait reason
@@ -107,8 +110,6 @@ if {($matches != 0) || ($status == 0)} {
 	fail "No error on attempt to cancel terminated job"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test20.4 b/testsuite/expect/test20.4
index 04293011ab..30ae8815a4 100755
--- a/testsuite/expect/test20.4
+++ b/testsuite/expect/test20.4
@@ -28,8 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 if {[file executable $pbsnodes] == 0} {
 	skip "$pbsnodes does not exists"
 }
@@ -42,8 +40,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "pbsnodes not responding"
-		set exit_code 1
+		fail "pbsnodes not responding"
 	}
 	eof {
 		wait
@@ -52,7 +49,3 @@ expect {
 if {$matches == 0} {
 	fail "pbsnodes output failure"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test20.5 b/testsuite/expect/test20.5
index 4fcbce288f..da6419c1ef 100755
--- a/testsuite/expect/test20.5
+++ b/testsuite/expect/test20.5
@@ -26,8 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
-
 if {[file executable $qalter] == 0} {
 	skip "$qalter does not exist"
 }
@@ -40,8 +38,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qalter is not responding"
-		set exit_code 1
+		fail "qalter is not responding"
 	}
 	eof {
 		wait
@@ -50,7 +47,3 @@ expect {
 if {$found != 1} {
 	fail "qalter's help option did not work"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test20.6 b/testsuite/expect/test20.6
index 5b8d9812ab..c45b8c8815 100755
--- a/testsuite/expect/test20.6
+++ b/testsuite/expect/test20.6
@@ -30,6 +30,12 @@ set file_in      "test$test_id\.input"
 set job_id       0
 set exit_code    0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {[file executable $qalter] == 0} {
 	skip "$qalter does not exits"
 }
@@ -53,8 +59,7 @@ proc check_rerun { arg job_id } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -73,8 +78,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub is not responding"
-		set exit_code 1
+		fail "qsub is not responding"
 	}
 	eof {
 		wait
@@ -88,8 +92,7 @@ if {$job_id == 0} {
 spawn $qalter -r y $job_id
 expect {
 	timeout {
-		log_error "qalter is not responding"
-		set exit_code 1
+		fail "qalter is not responding"
 	}
 	eof {
 		wait
@@ -102,8 +105,7 @@ check_rerun 1 $job_id
 spawn $qalter -r n $job_id
 expect {
 	timeout {
-		log_error "qalter is not responding"
-		set exit_code 1
+		fail "qalter is not responding"
 	}
 	eof {
 		wait
@@ -117,8 +119,6 @@ if {[cancel_job $job_id] != 0} {
 	fail "Unable to cancel job ($job_id)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test20.7 b/testsuite/expect/test20.7
index 7be4ecb06b..4374453788 100755
--- a/testsuite/expect/test20.7
+++ b/testsuite/expect/test20.7
@@ -31,6 +31,12 @@ set job_id       0
 set out_path     "/tmp/null"
 set exit_code    0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {[file executable $qalter] == 0} {
 	skip "$qalter does not exist"
 }
@@ -58,8 +64,7 @@ proc check_output { path job_id } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -79,8 +84,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub is not responding"
-		set exit_code 1
+		fail "qsub is not responding"
 	}
 	eof {
 		wait
@@ -95,8 +99,7 @@ set found 0
 spawn $qalter -o $out_path $job_id
 expect {
 	timeout {
-		log_error "qalter is not responding"
-		set exit_code 1
+		fail "qalter is not responding"
 	}
 	eof {
 		wait
@@ -109,8 +112,6 @@ if {[cancel_job $job_id] != 0} {
 	fail "Unable to cancel job ($job_id)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test20.8 b/testsuite/expect/test20.8
index 08a2a1e1e0..cecd696bc5 100755
--- a/testsuite/expect/test20.8
+++ b/testsuite/expect/test20.8
@@ -31,6 +31,12 @@ set job_name    "test$test_id\.newname"
 set job_id      0
 set exit_code   0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {[file executable $qalter] == 0} {
 	skip "$qalter does not exist"
 }
@@ -55,8 +61,7 @@ proc check_name { job_id name } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -75,8 +80,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "qsub is not responding"
-		set exit_code 1
+		fail "qsub is not responding"
 	}
 	eof {
 		wait
@@ -90,8 +94,7 @@ if {$job_id == 0} {
 spawn $qalter -N $job_name $job_id
 expect {
 	timeout {
-		log_error "qalter is not responding"
-		set exit_code 1
+		fail "qalter is not responding"
 	}
 	eof {
 		wait
@@ -103,8 +106,6 @@ if {[cancel_job $job_id] != 0} {
 	fail "Unable to cancel job ($job_id)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test20.9 b/testsuite/expect/test20.9
index 33763d890e..89bbdb4044 100755
--- a/testsuite/expect/test20.9
+++ b/testsuite/expect/test20.9
@@ -28,7 +28,12 @@ source ./globals
 
 set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
-set exit_code   0
+
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
 
 if {[file executable $qalter] == 0} {
 	skip "$qalter does not exist"
@@ -69,9 +74,3 @@ expect {
 if {$matches != 1} {
 	fail "qalter did not return the man pages ($matches != 1)"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test21.1 b/testsuite/expect/test21.1
index 9925d6c4d8..9a4d326fc8 100755
--- a/testsuite/expect/test21.1
+++ b/testsuite/expect/test21.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 set not_support 0
 
@@ -51,8 +50,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr not responding"
-		set exit_code 1
+		fail "sacctmgr not responding"
 	}
 	eof {
 		wait
@@ -62,7 +60,3 @@ expect {
 if {$matches != 3} {
 	fail "sacctmgr --usage failed ($matches)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test21.10 b/testsuite/expect/test21.10
index 050b095990..60c25257f1 100755
--- a/testsuite/expect/test21.10
+++ b/testsuite/expect/test21.10
@@ -113,9 +113,8 @@ set my_pid [spawn $sacctmgr -i delete cluster $tc1]
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr delete not responding"
 			slow_kill $my_pid
-			incr exit_code 1
+			fail "sacctmgr delete not responding"
 		}
 		eof {
 			wait
@@ -171,9 +170,8 @@ set my_pid [spawn $sacctmgr -i delete cluster $tc1]
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr add not responding"
 			slow_kill $my_pid
-			incr exit_code 1
+			fail "sacctmgr add not responding"
 		}
 		eof {
 			wait
@@ -206,9 +204,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $sadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -238,9 +235,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -263,8 +259,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -284,7 +279,10 @@ add_acct $ta1 [array get acct]
 #
 # Use sacctmgr to list and check the test associations
 #
-check_assoc_limit 2 account $ta1 [array get acct]
+if {![check_assoc_limit 2 account $ta1 [array get acct]]} {
+	log_error "The association limits for account $ta1 are incorrect"
+	set exit_code 1
+}
 
 if {![check_acct_associations]} {
 	log_error "Our associations don't line up"
@@ -301,9 +299,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -330,9 +327,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -356,9 +352,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -381,8 +376,8 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_debug "Test associations delete verified"
 		slow_kill $as2_list_pid
+		log_error "Test associations delete verified"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test21.11 b/testsuite/expect/test21.11
index bccd2dd84d..f009be22a2 100755
--- a/testsuite/expect/test21.11
+++ b/testsuite/expect/test21.11
@@ -114,8 +114,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -155,9 +154,8 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding"
 		slow_kill $as_list_pid
-		set exit_code 1
+		fail "sacctmgr list associations not responding"
 	}
 	eof {
 		wait
@@ -169,9 +167,14 @@ if {$almatches != 2} {
 	set exit_code 1
 }
 # Check that the Association was set correctly
-check_assoc_limit 2 account $ta1 [array get acct]
-
-check_assoc_limit 2 account $ta2 [array get acct]
+if {![check_assoc_limit 2 account $ta1 [array get acct]]} {
+	log_error "The association limits for account $ta1 were not set correctly"
+	set exit_code 1
+}
+if {![check_assoc_limit 2 account $ta2 [array get acct]]} {
+	log_error "The association limits for account $ta2 were not set correctly"
+	set exit_code 1
+}
 
 if {![check_acct_associations]} {
 	log_error "Our associations don't line up"
@@ -188,9 +191,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -217,9 +219,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -242,9 +243,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -272,8 +272,8 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_debug "Test associations delete verified"
 		slow_kill $as2_list_pid
+		log_debug "Test associations delete verified"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test21.12 b/testsuite/expect/test21.12
index 357f9632e0..040174f1a9 100755
--- a/testsuite/expect/test21.12
+++ b/testsuite/expect/test21.12
@@ -116,9 +116,8 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding"
 		slow_kill $as_list_pid
-		set exit_code 1
+		fail "sacctmgr list associations not responding"
 	}
 	eof {
 		wait
@@ -149,9 +148,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding"
 		slow_kill $ac_list_pid
-		set exit_code 1
+		fail "sacctmgr list associations not responding"
 	}
 	eof {
 		wait
@@ -173,9 +171,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -202,9 +199,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test21.15 b/testsuite/expect/test21.15
index fe5b589fd6..c38a31289a 100755
--- a/testsuite/expect/test21.15
+++ b/testsuite/expect/test21.15
@@ -187,7 +187,10 @@ if { $exit_code } {
 	fail "Unable to add user ($tu2)"
 }
 
-check_assoc_limit 3 user $tu2 [array get user_req2]
+if {![check_assoc_limit 3 user $tu2 [array get user_req2]]} {
+	log_error "The association limits for user $tu2 are incorrect"
+	set exit_code 1
+}
 
 # This is the end below here
 
diff --git a/testsuite/expect/test21.16 b/testsuite/expect/test21.16
index 2a8095473a..a7d9fe2f61 100755
--- a/testsuite/expect/test21.16
+++ b/testsuite/expect/test21.16
@@ -180,8 +180,14 @@ if { $exit_code } {
 incr exit_code [add_user "$tu4,$tu5" [array get user_req2]]
 if { $exit_code == 0} {
 	# Check Limits of both users
-	check_assoc_limit 3 user $tu4 [array get user_req2]
-	check_assoc_limit 3 user $tu5 [array get user_req2]
+	if {![check_assoc_limit 3 user $tu4 [array get user_req2]]} {
+		log_error "The association limits for user $tu4 are incorrect"
+		set exit_code 1
+	}
+	if {![check_assoc_limit 3 user $tu5 [array get user_req2]]} {
+		log_error "The association limits for user $tu5 are incorrect"
+		set exit_code 1
+	}
 }
 
 incr exit_code [remove_user "" "" "$tu4,$tu5"]
diff --git a/testsuite/expect/test21.2 b/testsuite/expect/test21.2
index 512af26e7c..4922df33df 100755
--- a/testsuite/expect/test21.2
+++ b/testsuite/expect/test21.2
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 set not_support 0
 
@@ -51,8 +50,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr not responding"
-		set exit_code 1
+		fail "sacctmgr not responding"
 	}
 	eof {
 		wait
@@ -62,7 +60,3 @@ expect {
 if {$matches != 3} {
 	fail "sacctmgr --help failed ($matches)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test21.21 b/testsuite/expect/test21.21
index c155b3bfcd..1ad0d96378 100755
--- a/testsuite/expect/test21.21
+++ b/testsuite/expect/test21.21
@@ -31,7 +31,6 @@ source ./globals
 source ./globals_accounting
 source ./inc21.21_tests
 
-set exit_code   0
 set test_qos    "test$test_id\_qos"
 set file_in     "test.$test_id.input"
 set ta		"test$test_id-account.1"
@@ -82,7 +81,7 @@ array set acct_mod_assoc_test_vals {
 #
 # Check test requirements
 #
-if { [string compare [priority_type] multifactor] } {
+if {[get_config_param "PriorityType"] ne "priority/multifactor"} {
 	skip "This test is only compatible with priority/multifactor plugin"
 }
 
@@ -95,7 +94,7 @@ if {[string compare [get_admin_level] "Administrator"]} {
 }
 
 if {[check_config_select "linear"]} {
-	set nb_nodes [get_node_cnt_in_part]
+	set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 	if {$nb_nodes < 2} {
 		skip "This test is incompatible with select/linear and only one node"
 	}
@@ -116,7 +115,7 @@ if {[param_contains $select_type_parameters "CR_ONE_TASK_PER_CORE"]} {
 
 # Define global cleanup routine so it can be called on exit
 proc cleanup { } {
-	global bin_rm file_in sacctmgr ta test_qos job_id exit_code
+	global bin_rm file_in sacctmgr ta test_qos job_id
 
 	# First wait for the job to complete
 	if { $job_id } {
@@ -135,8 +134,7 @@ proc cleanup { } {
 		}
 		timeout {
 			slow_kill $sadel_pid
-			log_error "sacctmgr delete not responding"
-			set exit_code 1
+			fail "sacctmgr delete not responding"
 		}
 		eof {
 			wait
@@ -157,8 +155,7 @@ proc cleanup { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr delete not responding"
-			set exit_code 1
+			fail "sacctmgr delete not responding"
 		}
 		eof {
 			wait
@@ -206,13 +203,13 @@ if {$totcpus == 0} {
 
 proc assoc_setup { limit_type limit_val } {
 
-	global acct_mod_assoc_test_vals exit_code
+	global acct_mod_assoc_test_vals
 	global acct_mod_desc acct_mod_acct_vals acct_mod_assoc_vals ta
 
 	set new_limit [lindex $limit_val 1]
 	set acct_mod_assoc_test_vals($limit_type) $new_limit
 
-	set exit_code [mod_acct $ta [array get acct_mod_desc] [array get acct_mod_assoc_test_vals] [array get acct_mod_acct_vals]]
+	return [mod_acct $ta [array get acct_mod_desc] [array get acct_mod_assoc_test_vals] [array get acct_mod_acct_vals]]
 }
 
 proc _test_limits { } {
@@ -224,8 +221,9 @@ proc _test_limits { } {
 		log_info "Setting up association limit $option..."
 		if { [string compare $option "maxjobsub"] &&
 		     [string compare $option "grpjobsub"] } {
-			assoc_setup $option $acct_mod_assoc_vals($option)
-			fail_on_error "Unable to modify account $ta"
+			if [assoc_setup $option $acct_mod_assoc_vals($option)] {
+				fail "Unable to modify account $ta"
+			}
 
 			if { ![string compare $option "maxcpumins"] && $one_task_pc } {
 				set acct_mod_assoc_vals(maxcpumins) "-n [expr [lindex $acct_mod_assoc_vals(maxcpumins) 1] / $nthreads]"
@@ -282,7 +280,6 @@ expect {
 # Test Fixture
 #
 cleanup
-fail_on_error "Initial test cleanup/fixture failed"
 
 #
 # Use sacctmgr to add an account
@@ -390,42 +387,25 @@ if {$job_id == 0} {
 # Spawn a job via sbatch using this account
 #
 make_bash_script $file_in "$bin_id"
-set job_id 0
-spawn $sbatch -N1 --account=$ta --output=none $file_in
+set job_id [submit_job -fail "-N1 --account=$ta --output=none $file_in"]
+set matches 0
+spawn $scontrol show job $job_id
 expect {
-	-re "Submitted batch job ($number)" {
-		set job_id $expect_out(1,string)
+	-re "Account=$ta" {
+		incr matches
 		exp_continue
 	}
 	timeout {
-		fail "sbatch not responding"
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$job_id == 0} {
-	fail "did not get sbatch job_id"
-} else {
-	set matches 0
-	spawn $scontrol show job $job_id
-	expect {
-		-re "Account=$ta" {
-			incr matches
-			exp_continue
-		}
-		timeout {
-			fail "scontrol not responding"
-		}
-		eof {
-			wait
-		}
-	}
-	if {$matches != 1} {
-		fail "sbatch failed to use specified account"
-	}
-	cancel_job $job_id
+if {$matches != 1} {
+	fail "sbatch failed to use specified account"
 }
+cancel_job $job_id
 
 #
 # Spawn a job via srun using this account
diff --git a/testsuite/expect/test21.22 b/testsuite/expect/test21.22
index 034ee44988..55932dc150 100755
--- a/testsuite/expect/test21.22
+++ b/testsuite/expect/test21.22
@@ -479,6 +479,21 @@ proc _remove_user { acct user } {
 	return $exit_code
 }
 
+proc cleanup {} {
+	global tu1 tu2 tu3 tu4 ta1 ta2 ta3 ta4 tc1 file_in file_in2 file_in3
+
+	_remove_user "" "$tu1,$tu2,$tu3,$tu4"
+	_remove_acct "" "$ta1,$ta2,$ta3,$ta4"
+	_remove_cluster "$tc1"
+
+	#
+	# Delete left-over input script files
+	#
+	exec $bin_rm -f $file_in
+	exec $bin_rm -f $file_in2
+	exec $bin_rm -f $file_in3
+}
+
 #make sure we have a clean system and permission to do this work
 _remove_user "" "$tu1,$tu2,$tu3,$tu4"
 _remove_acct "" "$ta1,$ta2,$ta3,$ta4"
@@ -511,9 +526,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding 1"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding 1"
 	}
 	eof {
 		wait
@@ -564,9 +578,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding 2"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding 2"
 	}
 	eof {
 		wait
@@ -597,9 +610,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding 3"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding 3"
 	}
 	eof {
 		wait
@@ -636,9 +648,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr load not responding 4"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr load not responding 4"
 	}
 	eof {
 		wait
@@ -711,9 +722,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding 5"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding 5"
 	}
 	eof {
 		wait
@@ -748,9 +758,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding 6"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding 6"
 	}
 	eof {
 		wait
@@ -786,9 +795,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding 7"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding 7"
 	}
 	eof {
 		wait
@@ -852,9 +860,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding 8"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding 8"
 	}
 	eof {
 		wait
@@ -889,9 +896,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding 9"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding 9"
 	}
 	eof {
 		wait
@@ -903,19 +909,6 @@ if {$matches != 3} {
 	incr exit_code 1
 }
 
-# This is the end below here
-
-incr exit_code [_remove_user "" "$tu1,$tu2,$tu3,$tu4"]
-incr exit_code [_remove_acct "" "$ta1,$ta2,$ta3,$ta4"]
-incr exit_code [_remove_cluster "$tc1"]
-
-#
-# Delete left-over input script files
-#
-exec $bin_rm -f $file_in
-exec $bin_rm -f $file_in2
-exec $bin_rm -f $file_in3
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test21.23 b/testsuite/expect/test21.23
index f061edf033..f47bbe8ccb 100755
--- a/testsuite/expect/test21.23
+++ b/testsuite/expect/test21.23
@@ -36,11 +36,21 @@ set wk          "test$test_id-wckey"
 set wk2         "test$test_id-wckey2"
 set wk3         "test$test_id-wckey3"
 set timeout 60
-
+set reconfigured false
 set config_path [get_conf_path]
-fail_on_error "Error getting config path"
 set config_file $config_path/slurm.conf
 
+proc cleanup {} {
+	global reconfigured config_file bin_rm file_in
+
+	if {$reconfigured} {
+		restore_conf $config_file
+		reconfigure
+	}
+
+	exec $bin_rm -f $file_in
+}
+
 #
 # Check accounting config and bail if not found.
 #
@@ -93,9 +103,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $sadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -111,9 +120,8 @@ if {$aamatches != 1} {
 set sadd_pid [spawn $sacctmgr -i create user name=$user_name account=$ta cluster=$cn wckeys=$wk]
 expect {
 	 timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $sadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -123,7 +131,6 @@ expect {
 #
 # Enable TrackWCKey
 #
-set reconfigured false
 if {[get_config_param "TrackWCKey"] ne "Yes"} {
 	log_info "Enabling TrackWCKey..."
 
@@ -131,7 +138,7 @@ if {[get_config_param "TrackWCKey"] ne "Yes"} {
 
 	exec $bin_sed -i /^\[\t\s\]*TrackWCKey\[\t\s\]*=/Id $config_file
 	exec $bin_echo TrackWCKey=Yes >> $config_file
-	reconfigure
+	reconfigure -fail
 	set reconfigured true
 }
 
@@ -154,8 +161,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -173,8 +179,7 @@ spawn $sacct -p -j $job_id --format=wckey
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -200,8 +205,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -219,8 +223,7 @@ if {$job_id == 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -237,8 +240,7 @@ if {$job_id == 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -261,8 +263,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -280,8 +281,7 @@ if {$job_id == 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -299,8 +299,7 @@ if {$job_id == 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -323,9 +322,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -352,9 +350,8 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $saadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -386,9 +383,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list not responding"
 		slow_kill $salist_pid
-		set exit_code 1
+		fail "sacctmgr list not responding"
 	}
 	eof {
 		wait
@@ -411,9 +407,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -438,22 +433,14 @@ expect {
 		log_error "WCKey = $wk3 should be deleted, but was not"
 	}
 	timeout {
-		log_error "sacctmgr list not responding"
 		slow_kill $salist_pid
-		set exit_code 1
+		fail "sacctmgr list not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$reconfigured} {
-	restore_conf $config_file
-	reconfigure
-}
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test21.25 b/testsuite/expect/test21.25
index bfb382f4cf..a62eb321e4 100755
--- a/testsuite/expect/test21.25
+++ b/testsuite/expect/test21.25
@@ -28,8 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 #
 # Use sacctmgr to create a cluster
 #
@@ -64,8 +62,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -77,7 +74,3 @@ if {$slurm_conf_matches != 2} {
 if {$slurmdbd_conf_matches != 2} {
 	fail "sacctmgr failed to show slurmdbd configuration"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test21.27 b/testsuite/expect/test21.27
index d6fb3e6ed9..68ecfb7a95 100755
--- a/testsuite/expect/test21.27
+++ b/testsuite/expect/test21.27
@@ -57,8 +57,7 @@ if {[string compare [get_admin_level] "Administrator"]} {
 spawn $sacctmgr -i delete user $tu1,$tu2,$tu3
 expect {
 	timeout {
-		log_error "sacctmgr delete user not responding"
-		set exit_code 1
+		fail "sacctmgr delete user not responding"
 	}
 	eof {
 		wait
@@ -68,8 +67,7 @@ expect {
 spawn $sacctmgr -i delete account $ta1,$ta2,$ta3
 expect {
 	 timeout {
-		log_error "sacctmgr delete account not responding"
-		set exit_code 1
+		fail "sacctmgr delete account not responding"
 	}
 	eof {
 		wait
@@ -79,8 +77,7 @@ expect {
 spawn $sacctmgr -i delete cluster $tc1,$tc2
 expect {
 	 timeout {
-		log_error "sacctmgr delete cluster not responding"
-		set exit_code 1
+		fail "sacctmgr delete cluster not responding"
 	}
 	eof {
 		wait
@@ -94,8 +91,7 @@ expect {
 spawn $sacctmgr -i add cluster $tc1
 expect {
 	 timeout {
-		log_error "sacctmgr add cluster not responding"
-		set exit_code 1
+		fail "sacctmgr add cluster not responding"
 	}
 	eof {
 		wait
@@ -105,8 +101,7 @@ expect {
 spawn $sacctmgr -i add account $ta1 cluster=$tc1
 expect {
 	 timeout {
-		log_error "sacctmgr add account $ta1 not responding"
-		set exit_code 1
+		fail "sacctmgr add account $ta1 not responding"
 	}
 	eof {
 		wait
@@ -116,8 +111,7 @@ expect {
 spawn $sacctmgr -i add account $ta2 parent=$ta1 cluster=$tc1
 expect {
 	 timeout {
-		log_error "sacctmgr add account $ta2 not responding"
-		set exit_code 1
+		fail "sacctmgr add account $ta2 not responding"
 	}
 	eof {
 		wait
@@ -127,8 +121,7 @@ expect {
 spawn $sacctmgr -i add user $tu1 account=$ta1 cluster=$tc1
 expect {
 	 timeout {
-		log_error "sacctmgr add user $tu1 not responding"
-		set exit_code 1
+		fail "sacctmgr add user $tu1 not responding"
 	}
 	eof {
 		wait
@@ -138,8 +131,7 @@ expect {
 spawn $sacctmgr -i add user $tu2 account=$ta1 cluster=$tc1
 expect {
 	 timeout {
-		log_error "sacctmgr add user $tu2 not responding"
-		set exit_code 1
+		fail "sacctmgr add user $tu2 not responding"
 	}
 	eof {
 		wait
@@ -149,8 +141,7 @@ expect {
 spawn $sacctmgr -i add user $tu3 account=$ta2 cluster=$tc1
 expect {
 	 timeout {
-		log_error "sacctmgr add user $tu3 not responding"
-		set exit_code 1
+		fail "sacctmgr add user $tu3 not responding"
 	}
 	eof {
 		wait
@@ -160,8 +151,7 @@ expect {
 spawn $sacctmgr -i delete cluster $tc1
 expect {
 	 timeout {
-		log_error "sacctmgr delete cluster $tc1  not responding"
-		set exit_code 1
+		fail "sacctmgr delete cluster $tc1  not responding"
 	}
 	eof {
 		wait
@@ -171,8 +161,7 @@ expect {
 spawn $sacctmgr -i add cluster $tc2
 expect {
 	 timeout {
-		log_error "sacctmgr add cluster $tc2  not responding"
-		set exit_code 1
+		fail "sacctmgr add cluster $tc2  not responding"
 	}
 	eof {
 		wait
@@ -182,8 +171,7 @@ expect {
 spawn $sacctmgr -i add account $ta3 cluster=$tc2
 expect {
 	 timeout {
-		log_error "sacctmgr add account $ta3  not responding"
-		set exit_code 1
+		fail "sacctmgr add account $ta3  not responding"
 	}
 	eof {
 		wait
@@ -193,8 +181,7 @@ expect {
 spawn $sacctmgr show problem
 expect {
 	 timeout {
-		log_error "sacctmgr show problem  not responding"
-		set exit_code 1
+		fail "sacctmgr show problem  not responding"
 	}
 	eof {
 		wait
@@ -237,9 +224,8 @@ expect {
 		}
 
 		timeout {
-			log_error "sacctmgr show not responding"
 			slow_kill $my_pid
-			incr exit_code 1
+			fail "sacctmgr show not responding"
 		}
 		eof {
 			wait
@@ -258,8 +244,7 @@ expect {
 spawn $sacctmgr -i delete user $tu1,$tu2,$tu3
 expect {
 	 timeout {
-		log_error "sacctmgr delete users not responding"
-		set exit_code 1
+		fail "sacctmgr delete users not responding"
 	}
 	eof {
 		wait
@@ -268,8 +253,7 @@ expect {
 spawn $sacctmgr -i delete account $ta1,$ta2,$ta3
 expect {
 	 timeout {
-		log_error "sacctmgr delete accounts not responding"
-		set exit_code 1
+		fail "sacctmgr delete accounts not responding"
 	}
 	eof {
 		wait
@@ -278,8 +262,7 @@ expect {
 spawn $sacctmgr -i delete cluster $tc1,$tc2
 expect {
 	 timeout {
-		log_error "sacctmgr delete clusters not responding"
-		set exit_code 1
+		fail "sacctmgr delete clusters not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test21.29 b/testsuite/expect/test21.29
index e8f05cf5c2..98435f20a6 100755
--- a/testsuite/expect/test21.29
+++ b/testsuite/expect/test21.29
@@ -78,7 +78,7 @@ if {$access_err != 0} {
 add_qos $qos_name [array get qos]
 
 # Use sacctmgr list to verify the test qos fields
-set exit_code [check_qos_limits $qos_name  [array get qos]]
+incr exit_code [check_qos_limits $qos_name  [array get qos]]
 
 # Setup the qos array so that we clear all the limits
 foreach option [array name qos] {
@@ -92,10 +92,10 @@ set qos(Description) ""
 set qos(Priority) $priority_reset
 
 #modify qos
-set exit_code [mod_qos $qos_name [array get qos]]
+incr exit_code [mod_qos $qos_name [array get qos]]
 
 # Check that the modified QoS limits are correct
-set exit_code [check_qos_limits $qos_name [array get qos]]
+incr exit_code [check_qos_limits $qos_name [array get qos]]
 
 # Next is clean up and the end
 incr exit_code [remove_qos "$qos_name"]
diff --git a/testsuite/expect/test21.3 b/testsuite/expect/test21.3
index 43e035ec42..344d27d515 100755
--- a/testsuite/expect/test21.3
+++ b/testsuite/expect/test21.3
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 set not_support 0
 
@@ -43,8 +42,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr not responding"
-		set exit_code 1
+		fail "sacctmgr not responding"
 	}
 	eof {
 		wait
@@ -54,7 +52,3 @@ expect {
 if {$matches != 1} {
 	fail "sacctmgr -V failed ($matches)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test21.30 b/testsuite/expect/test21.30
index 7a00043a58..48f1d34d44 100755
--- a/testsuite/expect/test21.30
+++ b/testsuite/expect/test21.30
@@ -147,8 +147,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -158,7 +157,7 @@ if {$tmpc == 0 || $tmpn == 0} {
 	skip "Not enough Nodes and/or CPUs"
 }
 
-if { ![string compare [priority_type] "multifactor"] } {
+if {[get_config_param "PriorityType"] eq "priority/multifactor"} {
 	set prio_multifactor 1
 } else {
 	set prio_multifactor 0
@@ -185,8 +184,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -215,7 +213,7 @@ if {$totcpus == 0} {
 # Get the number of nodes in the default partition, minus one.
 # $maxnode_num is used as MaxNodes in QOS and we will test requests of
 # $maxnode_num + 1. If not EnforcePartLimits could interfere.
-set num_nodes [expr [available_nodes "idle"] -1]
+set num_nodes [expr [llength [get_nodes_by_state]] -1]
 
 if {$num_nodes == 0} {
 	fail "No cpus were found"
@@ -227,9 +225,10 @@ if {$num_nodes == 0} {
 }
 
 
-proc endit { } {
-	global sacctmgr qostest acct test_id exit_code skips
+proc cleanup {} {
+	global sacctmgr qostest acct test_id skips
 	global scontrol save_billing_weights partition
+
 	# delete qos
 	spawn $sacctmgr -i delete qos $qostest
 	expect {
@@ -255,11 +254,9 @@ proc endit { } {
 		}
 		-re "Error" {
 			log_error "account was not deleted"
-			set exit_code 1
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -271,26 +268,15 @@ proc endit { } {
 		expect {
 			-re "error" {
 				log_error "Failed to reset TRESBillingWeights"
-				set exit_code 1
 			}
 			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
+				fail "scontrol is not responding"
 			}
 			eof {
 				wait
 			}
 		}
 	}
-
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	if {$skips != 0} {
-		skip "Test was partially skipped (skips = $skips)"
-	}
-
-	pass
 }
 
 #
@@ -340,8 +326,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -361,8 +346,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr did not add QOS"
-		set exit_code 1
+		fail "sacctmgr did not add QOS"
 	}
 	eof {
 		wait
@@ -378,8 +362,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -409,7 +392,7 @@ mod_qos $qostest [array get mod_qos_vals]
 sleep $time_spacing
 inc21_30_1 "QOSGrpNodeLimit"
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing GrpNode limit"
 }
 # Reset the value to 0
 set mod_qos_vals(GrpNodes) "-1"
@@ -427,7 +410,7 @@ if { $one_task_pc } {
 
 inc21_30_2 "QOSGrpCpuLimit"
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing GrpCpus"
 }
 set mod_qos_vals(GrpCpus) "-1"
 
@@ -439,7 +422,7 @@ mod_qos $qostest [array get mod_qos_vals]
 sleep $time_spacing
 inc21_30_3 "QOSGrpJobsLimit"
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing GrpJob limits"
 }
 set mod_qos_vals(GrpJobs) "-1"
 
@@ -451,7 +434,7 @@ mod_qos $qostest [array get mod_qos_vals]
 sleep $time_spacing
 inc21_30_4
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing GrpSubmit"
 }
 set mod_qos_vals(GrpSubmit) "-1"
 
@@ -469,7 +452,7 @@ if { $one_task_pc } {
 
 inc21_30_5 "QOSMaxCpuPerJobLimit"
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing QOSMaxCpuPerJobLimit"
 }
 set mod_qos_vals(MaxCpus) "-1"
 
@@ -481,7 +464,7 @@ mod_qos $qostest [array get mod_qos_vals]
 sleep $time_spacing
 inc21_30_6 "QOSMaxNodePerJobLimit|PartitionConfig"
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing MaxNode limit"
 }
 set mod_qos_vals(MaxNodes) "-1"
 
@@ -493,7 +476,7 @@ mod_qos $qostest [array get mod_qos_vals]
 sleep $time_spacing
 inc21_30_7 "QOSMaxJobsPerUserLimit"
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing MaxJobs limit"
 }
 set mod_qos_vals(MaxJobs) "-1"
 
@@ -505,7 +488,7 @@ mod_qos $qostest [array get mod_qos_vals]
 sleep $time_spacing
 inc21_30_8
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing MaxJobsSubmits limit"
 }
 set mod_qos_vals(MaxSubmitJobs) "-1"
 
@@ -520,7 +503,7 @@ if { $one_task_pc } {
 }
 inc21_30_9 "QOSGrpCPUMinutesLimit"
 if {$exit_code != 0 } {
-	endit
+	fail "Failure testing GroupCPUMins"
 }
 set mod_qos_vals(GrpCpuMin) "-1"
 
@@ -537,7 +520,7 @@ if { $prio_multifactor != 0 } {
 	}
 	inc21_30_10 "QOSGrpCPURunMinutesLimit"
 	if {$exit_code != 0 } {
-		endit
+		fail "Failure testing GroupCPURunMins"
 	}
 	set mod_qos_vals(GrpCpuRunMin) "-1"
 }
@@ -550,7 +533,7 @@ mod_qos $qostest [array get mod_qos_vals]
 sleep $time_spacing
 inc21_30_11 "QOSGrpMemLimit"
 if {$exit_code != 0 } {
-	endit
+	fail "Failure testing Group Memory"
 }
 set mod_qos_vals(GrpMem) "-1"
 
@@ -564,7 +547,7 @@ if { $prio_multifactor != 0 } {
 	sleep $time_spacing
 	inc21_30_12
 	if {$exit_code != 0 } {
-		endit
+		fail "Failure testing Group wall"
 	}
 	set mod_qos_vals(GrpWall) "-1"
 }
@@ -580,7 +563,7 @@ if { $one_task_pc } {
 }
 inc21_30_13 "QOSMaxCpuMinutesPerJobLimit"
 if {$exit_code != 0 } {
-	endit
+	fail "Failure testing Max Cpu Mins"
 }
 set mod_qos_vals(MaxCpuMin) "-1"
 
@@ -592,7 +575,7 @@ mod_qos $qostest [array get mod_qos_vals]
 sleep $time_spacing
 inc21_30_14 "QOSMaxWallDurationPerJobLimit"
 if {$exit_code != 0 } {
-	endit
+	fail "Failure testing Max Wall"
 }
 set mod_qos_vals(MaxWall) "-1"
 
@@ -613,7 +596,7 @@ if { $one_task_pc } {
 }
 inc21_30_15 "QOSMaxCpuPerUserLimit"
 if {$exit_code != 0 } {
-	endit
+	fail "Failure testing QOSMaxCpuPerUserLimit"
 }
 set mod_qos_vals(MaxCpusPerUser) "-1"
 
@@ -625,7 +608,7 @@ mod_qos $qostest [array get mod_qos_vals]
 sleep $time_spacing
 inc21_30_16 "QOSMaxNodePerUserLimit|PartitionConfig"
 if {$exit_code != 0 } {
-	endit
+	fail "Failure testing MaxNodesPerUser"
 }
 set mod_qos_vals(MaxNodesPerUser) "-1"
 
@@ -638,7 +621,7 @@ mod_qos $qostest [array get mod_qos_vals]
 sleep $time_spacing
 inc21_30_17
 if {$exit_code != 0 } {
-	endit
+	fail "Failure testing MaxWall is used as job's timelimit if job was requested without --time option"
 }
 set mod_qos_vals(MaxWall) "-1"
 
@@ -652,15 +635,14 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing TRESBillingWeights"
 }
 
 #
@@ -676,7 +658,7 @@ if { $one_task_pc } {
 
 inc21_30_2 "QOSGrpBilling"
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing GrpTRES=billing"
 }
 set mod_qos_vals(GrpTRES=billing) "-1"
 
@@ -692,7 +674,7 @@ if { $one_task_pc } {
 }
 inc21_30_9 "QOSGrpBillingMinutes"
 if {$exit_code != 0 } {
-	endit
+	fail "Failure testing GrpTRESMins=billing"
 }
 set mod_qos_vals(GrpTRESMins=billing) "-1"
 
@@ -710,7 +692,7 @@ if { $prio_multifactor != 0 } {
 	}
 	inc21_30_10 "QOSGrpBillingRunMinutes"
 	if {$exit_code != 0 } {
-		endit
+		fail "Failure testing GroupTRESRunMins=billing"
 	}
 	set mod_qos_vals(GrpTRESRunMins=billing) "-1"
 }
@@ -729,7 +711,7 @@ if { $one_task_pc } {
 
 inc21_30_5 "QOSMaxBillingPerJob"
 if {$exit_code != 0} {
-	endit
+	fail "Failure testing GrpTRES=billing limits"
 }
 set mod_qos_vals(MaxTRESPerJob=billing) "-1"
 
@@ -744,7 +726,7 @@ if { $one_task_pc } {
 }
 inc21_30_13 "QOSMaxBillingMinutesPerJob"
 if {$exit_code != 0 } {
-	endit
+	fail "Failure testing MaxTRESMinsPerJob=billing"
 }
 set mod_qos_vals(MaxTRESMinsPerJob=billing) "-1"
 
@@ -765,9 +747,14 @@ if { $one_task_pc } {
 }
 inc21_30_15 "QOSMaxBillingPerUser"
 if {$exit_code != 0 } {
-	endit
+	fail "Failure testing QOSMaxBillingPerUser"
 }
 set mod_qos_vals(MaxTRESPerUser=billing) "-1"
 
+if {$exit_code != 0} {
+	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+}
 
-endit
+if {$skips != 0} {
+	skip "Test was partially skipped (skips = $skips)"
+}
diff --git a/testsuite/expect/test21.31 b/testsuite/expect/test21.31
index 4dd13656b9..de025ab856 100755
--- a/testsuite/expect/test21.31
+++ b/testsuite/expect/test21.31
@@ -100,6 +100,16 @@ if {![is_super_user]} {
 #	skip "This test can't be run without being an Accounting administrator.\nUse: sacctmgr mod user \$USER set admin=admin"
 #}
 
+proc cleanup {} {
+	global sr2 sr3 tc2
+
+	#
+	# Clean up and exit
+	#
+	remove_res $sr2,$sr3
+	remove_cluster $tc2
+}
+
 # verify a clean system and permission to do this work
 remove_cluster "$tc2"
 remove_res "$sr1"
@@ -149,8 +159,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -195,8 +204,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -223,8 +231,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -255,12 +262,6 @@ if {[check_resource_limits $sr3 [array get resource2_chck]] == 1} {
 	incr exit_code 1
 }
 
-#
-# Clean up and exit
-#
-incr exit_code [remove_res $sr2,$sr3]
-incr exit_code [remove_cluster $tc2]
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test21.32 b/testsuite/expect/test21.32
index c9e3539a66..78fd466307 100755
--- a/testsuite/expect/test21.32
+++ b/testsuite/expect/test21.32
@@ -46,7 +46,6 @@ foreach inx [array names qos_test] {
 }
 
 proc reset_qos { } {
-
 	global sacctmgr qos_main exit_code qos_test
 
 	set removed 0
@@ -57,8 +56,7 @@ proc reset_qos { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -73,7 +71,6 @@ proc reset_qos { } {
 }
 
 proc _local_mod_qos { preempt_qos } {
-
 	global sacctmgr exit_code qos_test
 
 	set mod 0
@@ -84,8 +81,7 @@ proc _local_mod_qos { preempt_qos } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -99,7 +95,6 @@ proc _local_mod_qos { preempt_qos } {
 }
 
 proc check_pre { preempt_qos } {
-
 	global sacctmgr exit_code re_word_str qos_test
 
 	set match 0
@@ -110,8 +105,7 @@ proc check_pre { preempt_qos } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test21.33 b/testsuite/expect/test21.33
index a69d8ccd21..a4fa4fa480 100755
--- a/testsuite/expect/test21.33
+++ b/testsuite/expect/test21.33
@@ -39,7 +39,6 @@ set res1(server)                     "test$test_id\_server1"
 set res1(servertype)                 "test$test_id\_server_type1"
 set res1(type)                       "license"
 
-
 array set res2 {}
 set res2(count)                      25
 set res2(server)                     "test$test_id\_server2"
@@ -51,23 +50,13 @@ set res1_cluster(cluster)            $test_cluster
 set res1_cluster(server)             "test$test_id\_server1"
 set res1_cluster(percentallowed)     25
 
-
 array set res2_cluster {}
 set res2_cluster(cluster)            $test_cluster
 set res2_cluster(server)             "test$test_id\_server2"
 set res2_cluster(percentallowed)     25
 
-proc clean_up { } {
-	global test_res1 test_res2 test_cluster
-
-	remove_res $test_res1
-	remove_res $test_res2
-	remove_cluster $test_cluster
-}
-
 proc check_val { res_name } {
-
-	global sacctmgr test_cluster exit_code
+	global sacctmgr test_cluster
 
 	set rc 0
 	spawn $sacctmgr -n show resource withcluster cluster=$test_cluster \
@@ -78,8 +67,7 @@ proc check_val { res_name } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -95,8 +83,16 @@ if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"}
     skip "This test can't be run without superuser permissions"
 }
 
+proc cleanup { } {
+	global test_res1 test_res2 test_cluster
+
+	remove_res $test_res1
+	remove_res $test_res2
+	remove_cluster $test_cluster
+}
+
 # Delete any vestigial data
-clean_up
+cleanup
 
 set added 0
 spawn $sacctmgr add -i cluster $test_cluster
@@ -106,8 +102,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -124,13 +119,13 @@ if {$added != 1} {
 add_resource $test_res1 [array get res1]
 if {[check_resource_limits $test_res1 [array get res1]]} {
 	log_error "$test_res1 has bad values"
-	clean_up
+	cleanup
 }
 
 add_resource $test_res2 [array get res2]
 if {[check_resource_limits $test_res2 [array get res2]]} {
 	log_error "$test_res2 has bad values"
-	clean_up
+	cleanup
 }
 
 #
@@ -165,8 +160,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -198,8 +192,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not reponding"
-		set exit_code 1
+		fail "sacctmgr is not reponding"
 	}
 	eof {
 		wait
@@ -211,8 +204,6 @@ if {$match != 0} {
 	set exit_code 1
 }
 
-remove_cluster $test_cluster
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test21.34 b/testsuite/expect/test21.34
index f9d160bf2b..a013fd8c83 100755
--- a/testsuite/expect/test21.34
+++ b/testsuite/expect/test21.34
@@ -146,7 +146,6 @@ if {$overtimelim != 0} {
 }
 
 proc cleanup { } {
-
 	global acct job_qos part_qos scontrol sacctmgr test_part def_part
 	global exit_code
 
@@ -159,8 +158,7 @@ proc cleanup { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -178,8 +176,7 @@ proc cleanup { } {
 			set exit_code 1
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -189,8 +186,7 @@ proc cleanup { } {
 	spawn $scontrol delete partitionname=$test_part
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -201,8 +197,7 @@ proc cleanup { } {
 		spawn $scontrol update partitionname=$def_part default=yes
 		expect {
 			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
+				fail "scontrol is not responding"
 			}
 			eof {
 				wait
@@ -232,7 +227,7 @@ if {[param_contains $select_type_parameters "CR_CORE_*"]} {
 	set selectparam 1
 }
 
-if { ![string compare [priority_type] "multifactor"] } {
+if {[get_config_param "PriorityType"] eq "priority/multifactor"} {
 	set prio_multifactor 1
 } else {
 	set prio_multifactor 0
@@ -255,8 +250,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -270,7 +264,7 @@ if {$tmpc == 0 || $tmpn == 0} {
 # Get the number of nodes in the default partition, minus one.
 # $maxnode_num is used as MaxNodes in QOS and we will test requests of
 # $maxnode_num + 1. If not EnforcePartLimits could interfere.
-set num_nodes [expr [available_nodes "idle"] -1]
+set num_nodes [expr [llength [get_nodes_by_state]] -1]
 
 if {$num_nodes == 0} {
 	fail "No cpus were found"
@@ -290,8 +284,7 @@ spawn $scontrol create partitionname=$test_part qos=$part_qos tresbillingweights
     nodes=ALL
 expect {
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -307,8 +300,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -344,8 +336,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -382,8 +373,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not resonding"
-		set exit_code 1
+		fail "sacctmgr is not resonding"
 	}
 	eof {
 		wait
@@ -394,8 +384,6 @@ expect {
 log_info "========== Run limit test on job's qos limits =========="
 qos_test
 
-cleanup
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test21.35 b/testsuite/expect/test21.35
index 865f2884cc..11f8d0454b 100755
--- a/testsuite/expect/test21.35
+++ b/testsuite/expect/test21.35
@@ -83,7 +83,6 @@ array set reset_assoc_val {
 }
 
 proc check_limit { type name } {
-
 	global sacctmgr sbatch lim_type_type i option max_tres_type
 	global job_id test_qos test_acct reset_qos_val reset_assoc_val
 	global file_in number exit_code tres_cpu_mult
@@ -101,8 +100,7 @@ proc check_limit { type name } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -138,8 +136,7 @@ proc check_limit { type name } {
 			set exit_code 1
 		}
 		timeout {
-			log_error "srun is not responding"
-			set exit_code 1
+			fail "srun is not responding"
 		}
 		eof {
 			wait
@@ -159,16 +156,14 @@ proc check_limit { type name } {
 
 
 proc cleanup { } {
-
 	global sacctmgr file_in bin_rm test_acct test_qos exit_code
-	global partition save_billing_weights scontrol
+	global partition save_billing_weights scontrol job_id
 
 	# Delete test account and qos
 	spawn $sacctmgr -i delete account $test_acct
 	expect {
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -178,8 +173,7 @@ proc cleanup { } {
 	spawn $sacctmgr -i delete qos $test_qos
 	expect {
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -194,8 +188,7 @@ proc cleanup { } {
 				set exit_code 1
 			}
 			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
+				fail "scontrol is not responding"
 			}
 			eof {
 				wait
@@ -203,9 +196,13 @@ proc cleanup { } {
 		}
 	}
 
+	# Cancel the submitted job
+	if {$job_id != 0} {
+		cancel_job $job_id
+	}
+
 	# Remove test script
 	exec $bin_rm -f $file_in
-
 }
 
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
@@ -235,8 +232,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -255,8 +251,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error"sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -270,8 +265,7 @@ if {$match != 1} {
 spawn $sacctmgr -i create user name=[get_my_user_name] account=$test_acct
 expect {
 	timeout {
-		log_error"sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -287,8 +281,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -302,8 +295,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -317,8 +309,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -328,7 +319,6 @@ if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
 
-
 for {set i 0} {$i < 3} {incr i} {
 
 	foreach option [array names max_tres_type] {
@@ -355,8 +345,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -380,8 +369,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -392,9 +380,6 @@ if {$match != 1 || $job_id} {
 	fail "Job should have been killed upon submission"
 }
 
-# Cancel the submitted job
-cancel_job $job_id
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test21.36 b/testsuite/expect/test21.36
index d4d10e476e..ace8d9b457 100755
--- a/testsuite/expect/test21.36
+++ b/testsuite/expect/test21.36
@@ -33,7 +33,6 @@ set cluster          [get_config_param "ClusterName"]
 set account          "test$test_id\_acct"
 set user             "test$test_id\_user"
 set config_dir       ""
-set exit_code        1
 set access_err       0
 
 # Cluster requirments
@@ -46,28 +45,6 @@ set acct_req(cluster) $cluster
 set user_req(account) $account
 set user_req(cluster) $cluster
 
-# Remove pre-existing items
-proc cleanup { } {
-	global cluster account user sql_query_rem
-	archive_load $sql_query_rem
-	remove_user "" "" $user
-	remove_acct "" $account
-}
-
-proc endit { } {
-	global exit_code bin_rm sql_query sql_query_rem
-	cleanup
-
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors"
-	}
-
-	exec $bin_rm -f $sql_query $sql_query_rem
-
-	pass
-}
-
-
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "This test can't be run without AccountStorageType=slurmdbd"
 }
@@ -75,6 +52,7 @@ if {[string compare [get_admin_level] "Administrator"]} {
 	skip "This test can't be run without being an Accounting administrator"
 }
 
+# Remove pre-existing items
 exec $bin_rm -f $sql_query $sql_query_rem
 
 # Make SQL file to remove the inserted job
@@ -83,17 +61,24 @@ set file [open $sql_query_rem "w"]
 puts $file "delete from job_table where alloc_nodes=\'test21.36_node\' cluster=\'$cluster\';"
 close $file
 
-# Remove pre-existing items
-cleanup
+proc cleanup { } {
+	global cluster account user bin_rm sql_query sql_query_rem
+
+	archive_load $sql_query_rem
+	remove_user "" "" $user
+	remove_acct "" $account
+
+	exec $bin_rm -f $sql_query $sql_query_rem
+}
 
 # Add Test Account
 if {[add_acct $account [array get acct_req]]} {
-	endit
+	fail "Unable to add test account ($account)"
 }
 
 # Add Test User
 if {[add_user $user [array get user_req]]} {
-	endit
+	fail "Unable to add test user ($user)"
 }
 
 set assoc_id [get_assoc_id $user $account $cluster]
@@ -124,7 +109,7 @@ set cwd "[$bin_pwd]"
 # Load a job to the database that has no end time.
 if {[archive_load $sql_query]} {
 	archive_load $sql_query_rem
-	endit
+	fail "Unable to load job to database"
 }
 
 # Test sacctmgr show runawayjobs
@@ -136,8 +121,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		endit
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -145,8 +129,7 @@ expect {
 }
 
 if {$list_job != 1} {
-	log_error "sacctmgr did not find any runaway jobs when it should have"
-	endit
+	fail "sacctmgr did not find any runaway jobs when it should have"
 }
 
 # Check that jobs were fixed
@@ -158,8 +141,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		endit
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -167,9 +149,5 @@ expect {
 }
 
 if {$list_job != 1} {
-	log_error "sacctmgr found runaway jobs when it should not have"
-	endit
+	fail "sacctmgr found runaway jobs when it should not have"
 }
-
-set exit_code 0
-endit
diff --git a/testsuite/expect/test21.37 b/testsuite/expect/test21.37
index 8267b0da9e..58276ea520 100755
--- a/testsuite/expect/test21.37
+++ b/testsuite/expect/test21.37
@@ -1,7 +1,7 @@
 #!/usr/bin/env expect
 ############################################################################
 # Purpose: Test of Slurm functionality
-#          sacctmgr show stats
+#          sacctmgr show and clear stats
 ############################################################################
 # Copyright (C) 2008-2010 Lawrence Livermore National Security.
 # Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
@@ -28,8 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "This test can't be run without AccountStorageType=slurmdbd"
 }
@@ -37,6 +35,9 @@ if {[string compare [get_admin_level] "Administrator"]} {
 	skip "This test can't be run without being an Accounting administrator.\nUse: sacctmgr mod user \$USER set admin=admin"
 }
 
+#
+# sacctmgr show stats
+#
 set matches 0
 set rpc_rec_cnt 0
 set as_pid [spawn $sacctmgr show stats]
@@ -62,9 +63,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr show stats not responding"
-		set exit_code 1
 		slow_kill $as_pid
+		fail "sacctmgr show stats not responding"
 	}
 	eof {
 		wait
@@ -76,6 +76,14 @@ if {$rpc_rec_cnt > 0} {
 }
 subtest {$matches == 5} "sacctmgr should show all expected sections" "($matches != 5)"
 
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
+#
+# sacctmgr clear stats
+#
+set time_stamp_before [run_command_output "$bin_date +%s"]
+set time_stamp_after  0
+
+run_command -subtest "$sacctmgr clear stats"
+set output [run_command_output -fail "$sacctmgr show stats"]
+regexp -line "Data since +(\\S+) (\\S+) (\\S+) (\\S+) (\\d+) \\((\\d+)\\)" $output - - - - - - time_stamp_after
+
+subtest {$time_stamp_before <= $time_stamp_after} "timestamp in show stats should be newer than before running clear stats" "$time_stamp_before > $time_stamp_after"
diff --git a/testsuite/expect/test21.39 b/testsuite/expect/test21.39
index e2c4444c12..d429d3c057 100755
--- a/testsuite/expect/test21.39
+++ b/testsuite/expect/test21.39
@@ -34,7 +34,6 @@ set ta2		"test$test_id-account.2"
 set tu1     [get_my_user_name]
 set tq1     "test$test_id-qos.1"
 set tq2     "test$test_id-qos.2"
-set exit_code	0
 
 # account options
 array set acct_1 {}
@@ -191,6 +190,8 @@ proc check_job_reason { job_id state why } {
 
 proc run_test { run_qos } {
 	global scontrol tq1 tq2 ta1 ta2 part_name
+	# TODO: Temporary globals for the extra debug info for bug10604
+	global squeue sinfo sacctmgr
 
 	if { $run_qos } {
 		set qos $tq1
@@ -206,7 +207,19 @@ proc run_test { run_qos } {
 
 	set job_id_1 [test_salloc $qos $acct 1]
 	set job_id_2 [test_salloc $qos $acct 1]
-	check_rc [wait_for_job $job_id_1 "RUNNING"]
+	# TODO Temporary debug to troubleshoot bug 10604 (revert once fixed)
+	#check_rc [wait_for_job $job_id_1 "RUNNING"]
+	set rc [wait_for_job $job_id_1 "RUNNING"]
+	if {$rc} {
+		log_warn "Job never started, extra debug information for bug10604 below before the actual fail:"
+		run_command "$squeue"
+		run_command "$sinfo"
+		run_command "$scontrol show job"
+		run_command "$scontrol show node"
+		run_command "$scontrol show partition"
+		run_command "$sacctmgr show qos -p"
+		fail "Subcommand failed with exit code $rc"
+	}
 
 	if { $run_qos } {
 		# remove test qos
@@ -249,7 +262,6 @@ create_accounts
 
 # Get the location of the slurm.conf file
 set config_dir [get_conf_path]
-fail_on_error "Unable to determine configuration path"
 set config_file $config_dir/slurm.conf
 
 #
@@ -260,7 +272,7 @@ save_conf $config_file
 # Comment out PrologFlags in the slurm.conf
 exec $bin_sed -i {s/^\(PrologFlags=\)/#\1/gI} $config_file
 
-reconfigure
+reconfigure -fail
 
 delete_part $part_name
 
diff --git a/testsuite/expect/test21.4 b/testsuite/expect/test21.4
index 3f51ff69bf..18a475f8da 100755
--- a/testsuite/expect/test21.4
+++ b/testsuite/expect/test21.4
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 set not_support 0
 
@@ -43,8 +42,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr not responding"
-		set exit_code 1
+		fail "sacctmgr not responding"
 	}
 	eof {
 		wait
@@ -54,7 +52,3 @@ expect {
 if {$matches != 1} {
 	fail "sacctmgr version failed ($matches)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test21.40 b/testsuite/expect/test21.40
index 302a41e097..0646a09ddb 100755
--- a/testsuite/expect/test21.40
+++ b/testsuite/expect/test21.40
@@ -36,14 +36,13 @@ set part_qos         "test$test_id\_part_qos"
 
 proc cleanup { } {
 	global test_acct job_qos part_qos scontrol sacctmgr test_part
-	global exit_code
+	global bin_rm file_in
 
 	# Delete the test QOS
 	spawn $sacctmgr -i delete qos $job_qos,$part_qos
 	expect {
 		timeout {
 			log_error "sacctmgr is not responding"
-			set exit_code 1
 		}
 		eof {
 			wait
@@ -54,8 +53,7 @@ proc cleanup { } {
 	spawn $sacctmgr -i delete account $test_acct
 	expect {
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+		log_error "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -66,23 +64,23 @@ proc cleanup { } {
 	spawn $scontrol delete partitionname=$test_part
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
 		}
 	}
+
+	exec $bin_rm -f $file_in
 }
 
 proc set_assoc {count} {
-	global sacctmgr test_acct exit_code
+	global sacctmgr test_acct
 
 	spawn $sacctmgr -i modify account $test_acct set grpnodes=$count
 	expect {
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -91,13 +89,12 @@ proc set_assoc {count} {
 }
 
 proc set_qos {qos_name count} {
-	global sacctmgr exit_code
+	global sacctmgr
 
 	spawn $sacctmgr -i modify qos $qos_name set grpnodes=$count
 	expect {
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -106,7 +103,7 @@ proc set_qos {qos_name count} {
 }
 
 proc reason_node_limit {job_id} {
-	global scontrol exit_code
+	global scontrol
 
 	set node_limit 0
 	spawn $scontrol show job $job_id
@@ -120,8 +117,7 @@ proc reason_node_limit {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -131,7 +127,7 @@ proc reason_node_limit {job_id} {
 }
 
 proc run_job_test { } {
-	global file_in cancel_job sbatch scontrol test_acct
+	global file_in sbatch scontrol test_acct
 	global test_part job_qos number re_word_str
 	global nb_nodes exit_code reason_node_limit
 
@@ -149,8 +145,7 @@ proc run_job_test { } {
             exp_continue
         }
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -177,8 +172,7 @@ proc run_job_test { } {
                         exp_continue
                 }
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -200,8 +194,7 @@ proc run_job_test { } {
                         exp_continue
                 }
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -223,8 +216,7 @@ proc run_job_test { } {
             exp_continue
         }
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -264,8 +256,7 @@ proc run_job_test { } {
                         exp_continue
                 }
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -311,8 +302,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -329,24 +319,21 @@ set user_name [get_my_user_name]
 spawn $sacctmgr -i create user name=$user_name account=$test_acct
 expect {
 	timeout {
-		log_error "sacctmgr not responding"
-		set exit_code 1
+		fail "sacctmgr not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-# Get default partition name
-set def_part [default_partition]
-set nb_nodes [get_node_cnt_in_part $def_part]
+# Get the number of nodes in the default partition
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 
 # Create a partition to use for testing
-spawn $scontrol create partitionname=$test_part qos=$part_qos nodes=[available_nodes_hostnames $def_part]
+spawn $scontrol create partitionname=$test_part qos=$part_qos nodes=[list2hostlist [get_nodes_by_state]]
 expect {
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -371,8 +358,6 @@ run_job_test
 set_qos $part_qos -1
 
 # Clean up and exit
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test21.41 b/testsuite/expect/test21.41
index 7dad54800b..df1ce7d55f 100755
--- a/testsuite/expect/test21.41
+++ b/testsuite/expect/test21.41
@@ -64,28 +64,6 @@ set jobid06       "1006"
 set jobid07       "1007"
 set jobid08       "1008"
 
-###############################################################################
-#
-# Proc: Loads the remove sql entries and remove the added users, accounts and
-#       clusters.
-#
-###############################################################################
-proc cleanup {} {
-	global exit_code bin_rm
-	global sql_in_clus1 sql_in_clus2
-	global sql_rem_clus1 sql_rem_clus2
-	global clusters accounts users
-
-	incr exit_code [archive_load $sql_rem_clus1]
-	incr exit_code [archive_load $sql_rem_clus2]
-	remove_user    $clusters $accounts $users
-	remove_acct    "" $accounts
-	remove_cluster $clusters
-
-	exec $bin_rm $sql_in_clus1 $sql_in_clus2 $sql_rem_clus1 $sql_rem_clus2
-}
-
-
 ###############################################################################
 #
 # Proc: Creates the sql files to load 8 test jobs, and to remove them.
@@ -100,7 +78,7 @@ proc cleanup {} {
 proc create_sql {cluster sql_in sql_rem} {
 
 	global bin_rm
-	global exit_code test_name
+	global test_name
 	global account1 account2
 	global wckey1 wckey2
 	global user1acct1 user1acct2
@@ -258,10 +236,13 @@ proc _run_test { update_str expected_jobs } {
 	incr exit_code [archive_load $sql_rem_clus2]
 	incr exit_code [archive_load $sql_in_clus1]
 	incr exit_code [archive_load $sql_in_clus2]
-	fail_on_error "Unable to load archive"
+	if {$exit_code != 0} {
+		fail "Unable to load archive"
+	}
 
-	incr exit_code [test_job_update $update_str $expected_jobs]
-	fail_on_error "Update failed with: $update_str"
+	if [test_job_update $update_str $expected_jobs] {
+		fail "Update failed with: $update_str"
+	}
 }
 
 #
@@ -285,6 +266,29 @@ if {![string compare $user1 $user2]} {
 	skip "This test can't be run as root, because it needs 2 usernames and uses the current one and root"
 }
 
+###############################################################################
+#
+# Proc: Loads the remove sql entries and remove the added users, accounts and
+#       clusters.
+#
+###############################################################################
+proc cleanup {} {
+	global code bin_rm
+	global sql_in_clus1 sql_in_clus2
+	global sql_rem_clus1 sql_rem_clus2
+	global clusters accounts users
+
+	archive_load $sql_rem_clus1
+	archive_load $sql_rem_clus2
+
+	remove_user    $clusters $accounts $users
+	remove_acct    "" $accounts
+	remove_cluster $clusters
+
+	exec $bin_rm -f $sql_in_clus1 $sql_in_clus2 $sql_rem_clus1 $sql_rem_clus2
+}
+
+
 # Cluster Request
 array set clus_req {}
 
@@ -308,15 +312,19 @@ remove_cluster $clusters
 # Add cluster
 incr exit_code [add_cluster $cluster1 [array get clus_req]]
 incr exit_code [add_cluster $cluster2 [array get clus_req]]
-fail_on_error "Unable to add clusters"
+if {$exit_code != 0} {
+	fail "Unable to add clusters"
+}
 
 # Add accounts
-incr exit_code [add_acct "$account1,$account2" [array get acct_req]]
-fail_on_error "Unable to add accounts"
+if [add_acct "$account1,$account2" [array get acct_req]] {
+	fail "Unable to add accounts"
+}
 
 # Add users
-incr exit_code [add_user $users [array get user_req]]
-fail_on_error "Unable to add users"
+if [add_user $users [array get user_req]] {
+	fail "Unable to add users"
+}
 
 #
 # Get the association ids
@@ -337,9 +345,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding"
 	}
 	eof {
 		wait
@@ -356,9 +363,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding"
 	}
 	eof {
 		wait
@@ -375,9 +381,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding"
 	}
 	eof {
 		wait
@@ -394,9 +399,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr list associations not responding"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr list associations not responding"
 	}
 	eof {
 		wait
@@ -438,9 +442,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr wckeys not responding"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr wckeys not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test21.43 b/testsuite/expect/test21.43
index 99b2b8c534..9a2bae0226 100755
--- a/testsuite/expect/test21.43
+++ b/testsuite/expect/test21.43
@@ -32,9 +32,7 @@ set qos_prefix          "${test_name}_qos_"
 set test_acct           "${test_name}_acct"
 set test_user           [get_my_user_name]
 set access_err          0
-set exit_code           0
 set job_list            {}
-set failure_count       0
 
 set qoses {
 	high {UsageFactor 2}
@@ -134,14 +132,15 @@ expect {
 #
 # Clear the usage statistics
 #
-reset_account_usage "$cluster" "$test_acct"
-fail_on_error "Unable to reset account usage"
+if [reset_account_usage "$cluster" "$test_acct"] {
+	fail "Unable to reset account usage"
+}
 
 #
 # Test Usage Factor Function
 #
 proc test_usage_factor { qos usage_factor } {
-	global failure_count sbatch scontrol test_acct number test_name
+	global sbatch scontrol test_acct number test_name
 
 	log_info "Testing for a usage factor of $usage_factor with qos $qos"
 
@@ -175,7 +174,7 @@ proc test_usage_factor { qos usage_factor } {
 	#
 	# Wait for job to enter running state
 	#
-	if {[wait_for_job $job_id "RUNNING"] != 0} {
+	if {[wait_for_job -pollinterval .1 $job_id "RUNNING"] != 0} {
 		fail "Error waiting for job $job_id to be RUNNING"
 	}
 
@@ -215,10 +214,10 @@ proc test_usage_factor { qos usage_factor } {
 			wait
 		}
 	}
-	if {$observed_usage != $expected_usage} {
-		log_error "Usage for qos $qos was expected to be $expected_usage but was observed to be $observed_usage"
-		incr failure_count
-	}
+
+	# A tolerance of -1 (sec) must be permitted because usage can be accrued
+	# one second before the usage value can be returned.
+	subtest [tolerance $expected_usage $observed_usage -1] "Check that usage for qos $qos is within tolerance (-1 sec)" "$observed_usage not in \[$expected_usage-1, $expected_usage\]"
 
 	#
 	# Cancel the job
@@ -232,8 +231,3 @@ dict for {key qos_spec} $qoses {
 		test_usage_factor $test_qos $UsageFactor
 	}
 }
-
-# Fail test if any previous subtests failed
-if {$failure_count} {
-    fail "Test failed due to $failure_count prior subtest failures"
-}
diff --git a/testsuite/expect/test21.5 b/testsuite/expect/test21.5
index 782d4cb0bd..1b02d68bbb 100755
--- a/testsuite/expect/test21.5
+++ b/testsuite/expect/test21.5
@@ -100,9 +100,8 @@ set my_pid [spawn $sacctmgr -i delete cluster $tc1]
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr delete not responding"
 			slow_kill $my_pid
-			incr exit_code 1
+			fail "sacctmgr delete not responding"
 		}
 		eof {
 			wait
@@ -136,9 +135,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -161,8 +159,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -188,6 +185,10 @@ if {$access_err != 0} {
 }
 
 check_assoc_limit 1 cluster $tc1 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc1 [array get cluster]]} {
+	log_error "The association limits for cluster $tc1 are incorrect"
+	set exit_code 1
+}
 
 if {![check_acct_associations]} {
 	log_error "Our associations don't line up"
@@ -209,9 +210,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -234,9 +234,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test21.6 b/testsuite/expect/test21.6
index 0b4b3c0931..21095a7af2 100755
--- a/testsuite/expect/test21.6
+++ b/testsuite/expect/test21.6
@@ -106,9 +106,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -143,9 +142,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -168,8 +166,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -192,13 +189,22 @@ if {$access_err != 0} {
 }
 
 # Check Cluster 1
-check_assoc_limit 1 cluster $tc1 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc1 [array get cluster]]} {
+	log_error "The association limits for cluster $tc1 are incorrect"
+	set exit_code 1
+}
 
 # Check Cluster 2
-check_assoc_limit 1 cluster $tc2 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc2 [array get cluster]]} {
+	log_error "The association limits for cluster $tc2 are incorrect"
+	set exit_code 1
+}
 
 # Check Cluster 3
-check_assoc_limit 1 cluster $tc3 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc3 [array get cluster]]} {
+	log_error "The association limits for cluster $tc3 are incorrect"
+	set exit_code 1
+}
 
 if {![check_acct_associations]} {
 	log_error "Our associations don't line up"
@@ -229,9 +235,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -253,9 +258,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test21.7 b/testsuite/expect/test21.7
index b8c2b40767..505dcfb83c 100755
--- a/testsuite/expect/test21.7
+++ b/testsuite/expect/test21.7
@@ -80,9 +80,18 @@ if {$access_err != 0} {
 #
 # Check cluster limits
 #
-check_assoc_limit 1 cluster $tc1 [array get cluster]
-check_assoc_limit 1 cluster $tc2 [array get cluster]
-check_assoc_limit 1 cluster $tc3 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc1 [array get cluster]]} {
+	log_error "The association limits for cluster $tc1 are incorrect"
+	set exit_code 1
+}
+if {![check_assoc_limit 1 cluster $tc2 [array get cluster]]} {
+	log_error "The association limits for cluster $tc2 are incorrect"
+	set exit_code 1
+}
+if {![check_assoc_limit 1 cluster $tc3 [array get cluster]]} {
+	log_error "The association limits for cluster $tc3 are incorrect"
+	set exit_code 1
+}
 
 #
 # Use sacctmgr to delete the test cluster
@@ -107,9 +116,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test21.8 b/testsuite/expect/test21.8
index 4e64bebe1c..2297b0b284 100755
--- a/testsuite/expect/test21.8
+++ b/testsuite/expect/test21.8
@@ -202,13 +202,22 @@ if {$access_err != 0} {
 }
 
 # Check Cluster 1
-check_assoc_limit 1 cluster $tc1 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc1 [array get cluster]]} {
+	log_error "The association limits for cluster $tc1 are incorrect"
+	set exit_code 1
+}
 
 # Check Cluster 2
-check_assoc_limit 1 cluster $tc2 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc2 [array get cluster]]} {
+	log_error "The association limits for cluster $tc2 are incorrect"
+	set exit_code 1
+}
 
 # Check Cluster 3
-check_assoc_limit 1 cluster $tc3 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc3 [array get cluster]]} {
+	log_error "The association limits for cluster $tc3 are incorrect"
+	set exit_code 1
+}
 
 if {![check_acct_associations]} {
 	log_error "Our associations don't line up"
@@ -226,7 +235,10 @@ if {$access_err != 0} {
 }
 
 # Check Cluster 2
-check_assoc_limit 1 cluster $tc2 [array get mod_cluster]
+if {![check_assoc_limit 1 cluster $tc2 [array get mod_cluster]]} {
+	log_error "The association limits for cluster $tc2 are incorrect"
+	set exit_code 1
+}
 
 if {![check_acct_associations]} {
 	log_error "Our associations don't line up"
@@ -238,13 +250,22 @@ if {![check_acct_associations]} {
 #
 log_info "Check Cluster limits after one cluster has been modified:"
 # Check Cluster 1
-check_assoc_limit 1 cluster $tc1 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc1 [array get cluster]]} {
+	log_error "The association limits for cluster $tc1 are incorrect"
+	set exit_code 1
+}
 
 # Check Cluster 2
-check_assoc_limit 1 cluster $tc2 [array get mod_cluster]
+if {![check_assoc_limit 1 cluster $tc2 [array get mod_cluster]]} {
+	log_error "The association limits for cluster $tc2 are incorrect"
+	set exit_code 1
+}
 
 # Check Cluster 3
-check_assoc_limit 1 cluster $tc3 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc3 [array get cluster]]} {
+	log_error "The association limits for cluster $tc3 are incorrect"
+	set exit_code 1
+}
 
 #
 # Use sacctmgr to delete the test cluster
@@ -270,9 +291,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -296,9 +316,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test21.9 b/testsuite/expect/test21.9
index ccc5d0b332..5c6f09bb7e 100755
--- a/testsuite/expect/test21.9
+++ b/testsuite/expect/test21.9
@@ -122,9 +122,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $my_pid
-		incr exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -159,9 +158,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -184,8 +182,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -206,13 +203,22 @@ if {$access_err != 0} {
 }
 
 # Check Cluster 1
-check_assoc_limit 1 cluster $tc1 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc1 [array get cluster]]} {
+	log_error "The association limits for cluster $tc1 are incorrect"
+	set exit_code 1
+}
 
 # Check Cluster 2
-check_assoc_limit 1 cluster $tc2 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc2 [array get cluster]]} {
+	log_error "The association limits for cluster $tc2 are incorrect"
+	set exit_code 1
+}
 
 # Check Cluster 3
-check_assoc_limit 1 cluster $tc3 [array get cluster]
+if {![check_assoc_limit 1 cluster $tc3 [array get cluster]]} {
+	log_error "The association limits for cluster $tc3 are incorrect"
+	set exit_code 1
+}
 
 if {![check_acct_associations]} {
 	log_error "Our associations don't line up"
@@ -226,13 +232,22 @@ mod_cluster "$tc1,$tc2,$tc3" [array get mod_cluster]
 
 log_info "Checking modifed cluster limits:"
 # Check Cluster 1
-check_assoc_limit 1 cluster $tc1 [array get mod_cluster]
+if {![check_assoc_limit 1 cluster $tc1 [array get mod_cluster]]} {
+	log_error "The association limits for cluster $tc1 are incorrect"
+	set exit_code 1
+}
 
 # Check Cluster 2
-check_assoc_limit 1 cluster $tc2 [array get mod_cluster]
+if {![check_assoc_limit 1 cluster $tc2 [array get mod_cluster]]} {
+	log_error "The association limits for cluster $tc2 are incorrect"
+	set exit_code 1
+}
 
 # Check Cluster 3
-check_assoc_limit 1 cluster $tc3 [array get mod_cluster]
+if {![check_assoc_limit 1 cluster $tc3 [array get mod_cluster]]} {
+	log_error "The association limits for cluster $tc3 are incorrect"
+	set exit_code 1
+}
 
 if {![check_acct_associations]} {
 	log_error "Our associations don't line up"
@@ -263,9 +278,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -288,9 +302,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test22.2 b/testsuite/expect/test22.2
index 439aaa377d..8ef285e506 100755
--- a/testsuite/expect/test22.2
+++ b/testsuite/expect/test22.2
@@ -82,8 +82,7 @@ proc sreport_opt { soption } {
 			exp_continue
 		}
 		timeout {
-			log_error "sreport not responding"
-			set exit_code 1
+			fail "sreport not responding"
 		}
 		eof {
 			wait
@@ -115,8 +114,7 @@ proc sreport_opt { soption } {
 			exp_continue
 		}
 		timeout {
-			log_error "sreport not responding"
-			set exit_code 1
+			fail "sreport not responding"
 		}
 		eof {
 			wait
@@ -152,8 +150,7 @@ proc sreport_opt { soption } {
 			exp_continue
 		}
 		timeout {
-			log_error "sreport not responding"
-			set exit_code 1
+			fail "sreport not responding"
 		}
 		eof {
 			wait
@@ -185,8 +182,7 @@ proc sreport_opt { soption } {
 			exp_continue
 		}
 		timeout {
-			log_error "sreport not responding"
-			set exit_code 1
+			fail "sreport not responding"
 		}
 		eof {
 			wait
@@ -218,8 +214,7 @@ proc sreport_opt { soption } {
 			exp_continue
 		}
 		timeout {
-			log_error "sreport not responding"
-			set exit_code 1
+			fail "sreport not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test23.1 b/testsuite/expect/test23.1
index 57e059fbba..1e06f6520a 100755
--- a/testsuite/expect/test23.1
+++ b/testsuite/expect/test23.1
@@ -72,8 +72,7 @@ proc sstat_job { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sstat not responding"
-				set exit_code 1
+				fail "sstat not responding"
 			}
 			eof {
 				wait
@@ -102,8 +101,7 @@ proc sstat_job { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sstat not responding"
-				set exit_code 1
+				fail "sstat not responding"
 			}
 			eof {
 				wait
@@ -127,8 +125,7 @@ proc sstat_job { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sstat not responding"
-				set exit_code 1
+				fail "sstat not responding"
 			}
 			eof {
 				wait
diff --git a/testsuite/expect/test23.2 b/testsuite/expect/test23.2
index ea71d9451d..acda0a8ec1 100755
--- a/testsuite/expect/test23.2
+++ b/testsuite/expect/test23.2
@@ -35,6 +35,12 @@ set file_in3    "test$test_id.input3"
 set test_acct   "test$test_id\_acct"
 set timeout     $max_job_delay
 
+proc cleanup {} {
+	global bin_rm file_in1 file_in2 file_in3
+
+	exec $bin_rm -f $file_in1 $file_in2 $file_in3
+}
+
 set ac		AveCPU
 set ap		AvePages
 set ar		AveRSS
@@ -123,9 +129,8 @@ if {$aamatches != 1} {
 set sadd_pid [spawn $sacctmgr -i create user name=$user_name account=$test_acct]
 expect {
 	 timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $sadd_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -175,8 +180,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -194,8 +198,7 @@ if {$job_id3 == 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -229,7 +232,6 @@ sleep 5
 proc sstat_job { soption job_id step_id } {
 	global sstat number
 	set debug       0
-	set exit_code   0
 	set matches     0
 	set not_support 0
 	log_debug "sstat -$soption -p -j $job_id"
@@ -252,8 +254,7 @@ proc sstat_job { soption job_id step_id } {
 				exp_continue
 			}
 			timeout {
-				log_error "sstat not responding"
-				set exit_code 1
+				fail "sstat not responding"
 			}
 			eof {
 				wait
@@ -286,8 +287,7 @@ proc sstat_job { soption job_id step_id } {
 				exp_continue
 			}
 			timeout {
-				log_error "sstat not responding"
-				set exit_code 1
+				fail "sstat not responding"
 			}
 			eof {
 				wait
@@ -327,8 +327,7 @@ proc sstat_job { soption job_id step_id } {
 				exp_continue
 			}
 			timeout {
-				log_error "sstat not responding"
-				set exit_code 1
+				fail "sstat not responding"
 			}
 			eof {
 				wait
@@ -368,8 +367,7 @@ proc sstat_job { soption job_id step_id } {
 				exp_continue
 			}
 			timeout {
-				log_error "sstat not responding"
-				set exit_code 1
+				fail "sstat not responding"
 			}
 			eof {
 				wait
@@ -409,8 +407,7 @@ proc sstat_job { soption job_id step_id } {
 				exp_continue
 			}
 			timeout {
-				log_error "sstat not responding"
-				set exit_code 1
+				fail "sstat not responding"
 			}
 			eof {
 				wait
@@ -438,7 +435,6 @@ proc sstat_job { soption job_id step_id } {
 proc sstat_vargs { soption vargs job_id} {
 	global sstat
 	set debug	0
-	set exit_code   0
 	set matches     0
 	set not_support 0
 	log_debug "sstat -$soption $vargs -p -j $job_id"
@@ -481,8 +477,7 @@ proc sstat_vargs { soption vargs job_id} {
 				exp_continue
 			}
 			timeout {
-				log_error "sstat not responding"
-				set exit_code 1
+				fail "sstat not responding"
 			}
 			eof {
 				wait
@@ -584,9 +579,8 @@ expect {
 	}
 
 	timeout {
-		log_error "sacctmgr delete not responding"
 		slow_kill $sadel_pid
-		set exit_code 1
+		fail "sacctmgr delete not responding"
 	}
 	eof {
 		wait
@@ -622,9 +616,8 @@ if {$needtodel == 1} {
 		}
 
 		timeout {
-			log_error "sacctmgr delete not responding"
 			slow_kill $sadel_pid
-			set exit_code 1
+			fail "sacctmgr delete not responding"
 		}
 		eof {
 			wait
@@ -636,8 +629,6 @@ if {$damatches != 1} {
 	fail "sacctmgr had problems deleting the account"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2 $file_in3
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test24.1 b/testsuite/expect/test24.1
index a993a88e4e..56d58a591d 100755
--- a/testsuite/expect/test24.1
+++ b/testsuite/expect/test24.1
@@ -31,10 +31,15 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set test_prog   "test$test_id.prog"
 set matches     0
 
+proc cleanup {} {
+	global test_prog
+
+	file delete $test_prog
+}
+
 set damp [get_config_param "FairShareDampeningFactor"]
 if {$damp != 1} {
 	skip "Unable to run with FairShareDampeningFactor=$damp (must be 1)"
@@ -45,10 +50,11 @@ if {$damp != 1} {
 #
 file delete $test_prog
 
-compile_against_libslurm ${test_prog} 1 "-ldl -lm -export-dynamic \
-					 ${build_dir}/src/slurmctld/locks.o \
-					 ${build_dir}/src/sshare/process.o"
-fail_on_error "Cannot compile test program"
+if [compile_against_libslurm -full $test_prog "-ldl -lm -export-dynamic \
+				   ${build_dir}/src/slurmctld/locks.o \
+				   ${build_dir}/src/sshare/process.o"] {
+	fail "Cannot compile test program"
+}
 
 # Usage: test24.1.prog
 spawn ./$test_prog
@@ -114,9 +120,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "spawn IO not responding"
 		cancel_job $job_id
-		set exit_code 1
+		fail "spawn IO not responding"
 	}
 	eof {
 		wait
@@ -124,12 +129,5 @@ expect {
 }
 
 if {$matches != 13} {
-	log_error "We didn't get the correct priorities from the plugin ($matches != 13)"
-	set exit_code 1
-}
-
-if {$exit_code == 0} {
-	file delete $test_prog
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+	fail "We didn't get the correct priorities from the plugin ($matches != 13)"
 }
diff --git a/testsuite/expect/test24.1.prog.c b/testsuite/expect/test24.1.prog.c
index b11fa0b9c7..2f5d9e44d1 100644
--- a/testsuite/expect/test24.1.prog.c
+++ b/testsuite/expect/test24.1.prog.c
@@ -45,7 +45,6 @@
 /* set up some fake system */
 void *acct_db_conn = NULL;
 uint32_t cluster_cpus = 50;
-int long_flag = 1;
 int exit_code = 0;
 sshare_time_format_t time_format = SSHARE_TIME_MINS;
 char *time_format_string = "Minutes";
@@ -341,6 +340,12 @@ int main (int argc, char **argv)
 	sleep(1);
 	memset(&resp, 0, sizeof(shares_response_msg_t));
 	assoc_mgr_get_shares(NULL, 0, NULL, &resp);
+
+	/*
+	 * This is the global var from sshare.h to tell we want the long format
+	 */
+	long_flag = 1;
+
 	process(&resp, 0);
 
 	/* free memory */
diff --git a/testsuite/expect/test24.2 b/testsuite/expect/test24.2
index d621553de0..8c8a29c055 100755
--- a/testsuite/expect/test24.2
+++ b/testsuite/expect/test24.2
@@ -51,7 +51,7 @@ if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"}
 ################################################################
 
 proc sshare_opt { soption } {
-	global exit_code sshare number
+	global sshare number
 	set debug       1
 	set matches     0
 	set not_support 0
@@ -85,8 +85,7 @@ proc sshare_opt { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sshare not responding"
-				set exit_code 1
+				fail "sshare not responding"
 			}
 			eof {
 				wait
@@ -122,8 +121,7 @@ proc sshare_opt { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sshare not responding"
-				set exit_code 1
+				fail "sshare not responding"
 			}
 			eof {
 				wait
@@ -164,8 +162,7 @@ proc sshare_opt { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sshare not responding"
-				set exit_code 1
+				fail "sshare not responding"
 			}
 			eof {
 				wait
@@ -202,8 +199,7 @@ proc sshare_opt { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sshare not responding"
-				set exit_code 1
+				fail "sshare not responding"
 			}
 			eof {
 				wait
@@ -244,8 +240,7 @@ proc sshare_opt { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sshare not responding"
-				set exit_code 1
+				fail "sshare not responding"
 			}
 			eof {
 				wait
@@ -282,8 +277,7 @@ proc sshare_opt { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sshare not responding"
-				set exit_code 1
+				fail "sshare not responding"
 			}
 			eof {
 				wait
@@ -364,7 +358,6 @@ if {$matches != 2} {
 	set exit_code 1
 }
 
-
 set matches [sshare_opt V ]
 if {$matches != 1} {
 	log_error "sshare -v failed ($matches != 1)"
diff --git a/testsuite/expect/test24.3 b/testsuite/expect/test24.3
index ba82910f79..f683ef2dad 100755
--- a/testsuite/expect/test24.3
+++ b/testsuite/expect/test24.3
@@ -35,10 +35,15 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set test_prog   "test$test_id.prog"
 set matches     0
 
+proc cleanup {} {
+	global test_prog
+
+	file delete $test_prog
+}
+
 set damp [get_config_param "FairShareDampeningFactor"]
 if {$damp != 1} {
 	skip "Unable to run with FairShareDampeningFactor=$damp (must be 1)"
@@ -49,10 +54,11 @@ if {$damp != 1} {
 #
 file delete $test_prog
 
-compile_against_libslurm ${test_prog} 1 "-ldl -lm -export-dynamic \
-					 ${build_dir}/src/slurmctld/locks.o \
-					 ${build_dir}/src/sshare/process.o"
-fail_on_error "Cannot compile test program"
+if [compile_against_libslurm -full $test_prog "-ldl -lm -export-dynamic \
+				   ${build_dir}/src/slurmctld/locks.o \
+				   ${build_dir}/src/sshare/process.o"] {
+	fail "Cannot compile test program"
+}
 
 # Usage: test24.3.prog
 spawn ./$test_prog
@@ -156,9 +162,8 @@ expect {
 	}
 
 	timeout {
-		log_error "spawn IO not responding"
 		cancel_job $job_id
-		set exit_code 1
+		fail "spawn IO not responding"
 	}
 	eof {
 		wait
@@ -168,9 +173,3 @@ expect {
 if {$matches != 22} {
 	fail "We didn't get the correct priorities from the plugin ($matches != 22)"
 }
-
-if {$exit_code == 0} {
-	file delete $test_prog
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test24.3.prog.c b/testsuite/expect/test24.3.prog.c
index 42d262da6e..8ae85df3de 100644
--- a/testsuite/expect/test24.3.prog.c
+++ b/testsuite/expect/test24.3.prog.c
@@ -50,7 +50,6 @@
 /* set up some fake system */
 void *acct_db_conn = NULL;
 uint32_t cluster_cpus = 50;
-int long_flag = 1;
 int exit_code = 0;
 sshare_time_format_t time_format = SSHARE_TIME_MINS;
 char *time_format_string = "Minutes";
@@ -453,6 +452,12 @@ int main (int argc, char **argv)
 	sleep(1);
 	memset(&resp, 0, sizeof(shares_response_msg_t));
 	assoc_mgr_get_shares(NULL, 0, NULL, &resp);
+
+	/*
+	 * This is the global var from sshare.h to tell we want the long format
+	 */
+	long_flag = 1;
+
 	process(&resp, 0);
 
 	/* free memory */
diff --git a/testsuite/expect/test24.4 b/testsuite/expect/test24.4
index 547f080b12..a2c1df5e43 100755
--- a/testsuite/expect/test24.4
+++ b/testsuite/expect/test24.4
@@ -33,11 +33,16 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set test_prog   "test$test_id.prog"
 set matches     0
 set expected_matches 35
 
+proc cleanup {} {
+	global test_prog
+
+	file delete $test_prog
+}
+
 set damp [get_config_param "FairShareDampeningFactor"]
 if {$damp != 1} {
 	skip "Unable to run with FairShareDampeningFactor=$damp (must be 1)"
@@ -48,10 +53,11 @@ if {$damp != 1} {
 #
 file delete $test_prog
 
-compile_against_libslurm ${test_prog} 1 "-ldl -lm -export-dynamic \
-					 ${build_dir}/src/slurmctld/locks.o \
-					 ${build_dir}/src/sshare/process.o"
-fail_on_error "Cannot compile test program"
+if [compile_against_libslurm -full $test_prog "-ldl -lm -export-dynamic \
+				   ${build_dir}/src/slurmctld/locks.o \
+				   ${build_dir}/src/sshare/process.o"] {
+	fail "Cannot compile test program"
+}
 
 # Usage: test24.4.prog
 spawn ./$test_prog
@@ -207,9 +213,8 @@ expect {
 	}
 
 	timeout {
-		log_error "spawn IO not responding"
 		cancel_job $job_id
-		set exit_code 1
+		fail "spawn IO not responding"
 	}
 	eof {
 		wait
@@ -217,19 +222,12 @@ expect {
 }
 
 if {$matches != $expected_matches} {
-	log_error "We didn't get the correct priorities from the plugin ($matches != $expected_matches)"
-	log_debug "Some potentially useful information is below:
+	log_debug "
 * Account aA, aB, and aC are general purpose algorithm tests with various shares, usage values, children counts, and depths
 * Account aD is used to test USE_PARENT. Any account that is USE_PARENT should have its children effectively reparented to the parent's parent. Any user with USE_PARENT should be ranked highest in its account, subject to ties with any other association with level_fs==1.0. uD2 and uD3 do NOT have the same level_fs; sshare doesn't show enough digits to visually distinguish.
 * Account aE and its children should have fairshare==1.0 as a result of tie handling code.
 * Account aF is similar to aE except its shares are different; they should still be 1.0.
 * Accounts aE and aF and their descendants and u1 (root) should have fairshare==1.0 or ranking is broken.
 * Account aG is set up so that uGA1 and uG1 will have equivalent fs factors due to the tie handling code but uGA2 will not."
-	set exit_code 1
-}
-
-if {$exit_code == 0} {
-	file delete $test_prog
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+	fail "We didn't get the correct priorities from the plugin ($matches != $expected_matches)"
 }
diff --git a/testsuite/expect/test24.4.prog.c b/testsuite/expect/test24.4.prog.c
index 808c20203f..cc1c735e39 100644
--- a/testsuite/expect/test24.4.prog.c
+++ b/testsuite/expect/test24.4.prog.c
@@ -48,7 +48,6 @@
 /* set up some fake system */
 void *acct_db_conn = NULL;
 uint32_t cluster_cpus = 50;
-int long_flag = 1;
 int exit_code = 0;
 sshare_time_format_t time_format = SSHARE_TIME_MINS;
 char *time_format_string = "Minutes";
@@ -502,6 +501,12 @@ int main (int argc, char **argv)
 	sleep(1);
 	memset(&resp, 0, sizeof(shares_response_msg_t));
 	assoc_mgr_get_shares(NULL, 0, NULL, &resp);
+
+	/*
+	 * This is the global var from sshare.h to tell we want the long format
+	 */
+	long_flag = 1;
+
 	process(&resp, 0);
 
 	/* free memory */
diff --git a/testsuite/expect/test24.5 b/testsuite/expect/test24.5
index de8d86966f..0d57af8496 100755
--- a/testsuite/expect/test24.5
+++ b/testsuite/expect/test24.5
@@ -25,7 +25,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set timeout	60
 
 set jobid1 0
@@ -37,7 +36,7 @@ set jobid2 0
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "This test can't be run without a usable AccountStorageType"
 }
-if { [string compare [priority_type] multifactor] } {
+if {[get_config_param "PriorityType"] ne "priority/multifactor"} {
 	skip "This test can't be run without a usable PriorityType"
 }
 
@@ -49,20 +48,11 @@ if { [string first "CR_ONE_TASK_PER_CORE" $select_type_params] != -1 } {
 	skip "This test can't be run SelectTypeParameters=CR_ONE_TASK_PER_CORE"
 }
 
-proc end_it { exit_code } {
-	global test_id jobid1 jobid2
+proc cleanup {} {
+	global jobid1 jobid2
 
-	if {$jobid1} {
-		cancel_job $jobid1
-	}
-	if {$jobid2} {
-		cancel_job $jobid2
-	}
-
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
+	cancel_job $jobid1
+	cancel_job $jobid2
 }
 
 
@@ -77,8 +67,7 @@ proc sub_job { cpu_cnt state } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -86,13 +75,11 @@ proc sub_job { cpu_cnt state } {
 	}
 
 	if {$jobid == 0} {
-		log_error "did not get sbatch jobid"
-		end_it 1
+		fail "did not get sbatch jobid"
 	}
 
 	if {[wait_for_job $jobid $state] != 0} {
-		log_error "error starting job $jobid"
-		end_it 1
+		fail "error starting job $jobid"
 	}
 
 	return $jobid
@@ -101,8 +88,9 @@ proc sub_job { cpu_cnt state } {
 
 proc sprio_args { args regex match_cnt } {
 	global sprio
-	if {[wait_for_command $sprio $args $regex $match_cnt]} {
-		end_it 1
+
+	if [wait_for_command "$sprio $args" "\[regexp -all {$regex} \[dict get \$result output\]\] == $match_cnt"] {
+		fail "sprio did not match"
 	}
 }
 
@@ -121,8 +109,7 @@ proc update_job { jobid prio {error ""} } {
 			incr matches
 		}
 		timeout {
-			log_error "scontrol not responding"
-			end_it 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -130,8 +117,7 @@ proc update_job { jobid prio {error ""} } {
 	}
 
 	if {($error != "") && !$matches} {
-		log_error "didn't get expected error '$error'"
-		end_it 1
+		fail "didn't get expected error '$error'"
 	}
 }
 
@@ -159,5 +145,3 @@ sprio_args "-j $jobid2 -o \"%.15i %S\"" "$jobid2 -2147483645" 1
 
 update_job $jobid2 2147483646 "scontrol: error: SiteFactor value out of range"
 update_job $jobid2 -2147483646 "scontrol: error: SiteFactor value out of range"
-
-end_it 0
diff --git a/testsuite/expect/test24.6 b/testsuite/expect/test24.6
index 7e1f991452..8ec7f3f4e8 100755
--- a/testsuite/expect/test24.6
+++ b/testsuite/expect/test24.6
@@ -50,7 +50,7 @@ set access_err 0
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "This test can't be run without a usable AccountStorageType"
 }
-if { [string compare [priority_type] multifactor] } {
+if {[get_config_param "PriorityType"] ne "priority/multifactor"} {
 	skip "This test can't be run without a usable PriorityType"
 }
 
@@ -69,31 +69,18 @@ proc clean_assocs {} {
 	remove_qos $tq1
 }
 
-proc end_it { exit_code } {
-	global test_id jobid1 jobid2 jobid3 jobid4 bin_cp config_file test_id ta1 tq1
+proc cleanup {} {
+	global jobid1 jobid2 jobid3 jobid4 config_file
 
-	if {$jobid1} {
-		cancel_job $jobid1
-	}
-	if {$jobid2} {
-		cancel_job $jobid2
-	}
-	if {$jobid3} {
-		cancel_job $jobid3
-	}
-	if {$jobid4} {
-		cancel_job $jobid4
-	}
+	cancel_job $jobid1
+	cancel_job $jobid2
+	cancel_job $jobid3
+	cancel_job $jobid4
 
 	clean_assocs
 
 	restore_conf $config_file
 	reconfigure
-
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
 }
 
 proc part_cpu_cnt { partition } {
@@ -111,8 +98,7 @@ proc part_cpu_cnt { partition } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -136,8 +122,7 @@ proc sub_job { args state } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -145,13 +130,11 @@ proc sub_job { args state } {
 	}
 
 	if {$jobid == 0} {
-		log_error "did not get sbatch jobid"
-		end_it 1
+		fail "Did not get sbatch jobid"
 	}
 
 	if {[wait_for_job $jobid $state] != 0} {
-		log_error "error starting job $jobid"
-		end_it 1
+		fail "Error starting job $jobid"
 	}
 
 	return $jobid
@@ -168,8 +151,7 @@ proc sprio_args { args regex match_cnt } {
 			exp_continue
 		}
 		timeout {
-			log_error "sprio not responding"
-			end_it 1
+			fail "sprio not responding"
 		}
 		eof {
 			wait
@@ -177,8 +159,7 @@ proc sprio_args { args regex match_cnt } {
 	}
 
 	if {$matches != $match_cnt} {
-		log_error "sprio $args failed to match '$regex' $match_cnt times"
-		end_it 1
+		fail "sprio $args failed to match '$regex' $match_cnt times"
 	}
 }
 
@@ -197,8 +178,7 @@ proc update_job { jobid prio {error ""} } {
 			incr matches
 		}
 		timeout {
-			log_error "scontrol not responding"
-			end_it 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -206,8 +186,7 @@ proc update_job { jobid prio {error ""} } {
 	}
 
 	if {($error != "") && !$matches} {
-		log_error "didn't get expected error '$error'"
-		end_it 1
+		fail "Didn't get expected error '$error'"
 	}
 }
 
@@ -218,12 +197,10 @@ proc create_part { name nodes prio } {
 	spawn $scontrol create partitionname=$name priorityjobfactor=$prio nodes=$nodes
 	expect {
 		-re "error" {
-			log_error "scontrol found error"
-			end_it 1
+			fail "scontrol found error"
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			end_it 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -238,8 +215,7 @@ proc create_part { name nodes prio } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			end_it 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -247,8 +223,7 @@ proc create_part { name nodes prio } {
 	}
 
 	if {$found == 0} {
-		log_error "scontrol did not create partition $name"
-		end_it 1
+		fail "scontrol did not create partition $name"
 	}
 }
 
@@ -259,7 +234,6 @@ if {[info exists env(SPRIO_FORMAT)]} {
 }
 
 set config_path [get_conf_path]
-fail_on_error "Unable to get config path"
 set config_file $config_path/slurm.conf
 
 save_conf $config_file
@@ -275,7 +249,7 @@ PriorityWeightTRES=cpu=1
 PriorityFlags=NO_NORMAL_ALL
 "
 exec $bin_echo $prio_conf >> $config_file
-reconfigure
+reconfigure -fail
 
 
 # verify NO_NORMAL_ALL shows. It sets multiple flags but show be collapsed to
@@ -288,22 +262,19 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {!$match} {
-	log_error "didn't find NO_NORMAL_ALL flag"
-	end_it 1
+	fail "Didn't find NO_NORMAL_ALL flag"
 }
 
-set idle_node [get_idle_node_in_part]
+set idle_node [lindex [get_nodes_by_state] 0]
 if {$idle_node == ""} {
-	log_error "no idle nodes"
-	end_it 1
+	fail "No idle nodes"
 }
 log_info "idle: $idle_node"
 create_part $p1 $idle_node 10
@@ -315,20 +286,20 @@ clean_assocs
 array set qos_req {}
 set qos_req(priority) 200
 if {[add_qos $tq1 [array get qos_req]]} {
-	end_it 1
+	fail "Unable to add qos ($tq1)"
 }
 
 array set acct_req {}
 set acct_req(priority) 100
 set acct_req(qos) $tq1
 if {[add_acct $ta1 [array get acct_req]]} {
-	end_it 1
+	fail "Unable to add account ($ta1)"
 }
 
 array set user_req {}
 set user_req(account) $ta1
 if {[add_user [get_my_user_name] [array get user_req]]} {
-	end_it 1
+	fail "Unable to add user to account ($ta1)"
 }
 
 set cpu_cnt [part_cpu_cnt $p1]
@@ -341,5 +312,3 @@ sprio_args "-j $jobid2 -o \"%.15i %10B %10P %10Q %10T\"" "$jobid2\\s+100\\s+10\\
 sprio_args "-j $jobid3 -o \"%.15i %10B %10P %10Q %10T\"" "$jobid3\\s+100\\s+20\\s+200\\s+cpu=$cpu_cnt" 1
 sprio_args "-j $jobid4 -p$p1 -o \"%.15i %10B %10P %10Q %10T\"" "$jobid4\\s+100\\s+10\\s+200\\s+cpu=$cpu_cnt" 1
 sprio_args "-j $jobid4 -p$p2 -o \"%.15i %10B %10P %10Q %10T\"" "$jobid4\\s+100\\s+20\\s+200\\s+cpu=$cpu_cnt" 1
-
-end_it 0
diff --git a/testsuite/expect/test24.7 b/testsuite/expect/test24.7
index ef6d57cd5f..b1694f2bb9 100755
--- a/testsuite/expect/test24.7
+++ b/testsuite/expect/test24.7
@@ -26,7 +26,6 @@
 source ./globals
 source ./globals_accounting
 
-set exit_code   0
 set timeout	60
 
 set ta1         "test$test_id-account.1"
@@ -39,11 +38,7 @@ set p2         "test$test_id-part.2"
 
 set config_path  ""
 
-set jobid1 0
-set jobid2 0
-set jobid3 0
-set jobid4 0
-set jobid5 0
+set jobid_list ""
 
 set cwd "[$bin_pwd]"
 
@@ -57,7 +52,7 @@ set user [get_my_user_name]
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "This test can't be run without a usable AccountStorageType"
 }
-if { [string compare [priority_type] multifactor] } {
+if {[get_config_param "PriorityType"] ne "priority/multifactor"} {
 	skip "This test can't be run without a usable PriorityType"
 }
 
@@ -79,25 +74,9 @@ proc clean_assocs {} {
 }
 
 proc cleanup { } {
-	global test_id jobid1 jobid2 jobid3 jobid4 jobid5 bin_cp
-	global config_file test_id cwd
-
-	if {$jobid1} {
-		cancel_job $jobid1
-	}
-	if {$jobid2} {
-		cancel_job $jobid2
-	}
-	if {$jobid3} {
-		cancel_job $jobid3
-	}
-	if {$jobid4} {
-		cancel_job $jobid4
-	}
-	if {$jobid5} {
-		cancel_job $jobid5
-	}
+	global config_file jobid_list
 
+	cancel_job $jobid_list
 	clean_assocs
 
 	restore_conf $config_file
@@ -131,7 +110,7 @@ proc part_cpu_cnt { partition } {
 
 proc sub_job { args state } {
 
-	global number sbatch test_id bin_sleep
+	global number sbatch test_id bin_sleep jobid_list
 
 	set jobid 0
 	set cmd "$sbatch -J$test_id -o/dev/null -e/dev/null --exclusive --wrap \"$bin_sleep 999\""
@@ -159,30 +138,16 @@ proc sub_job { args state } {
 		fail "Error starting job $jobid"
 	}
 
+	lappend jobid_list $jobid
 	return $jobid
 }
 
-proc sprio_args { args regex match_cnt } {
+proc sprio_args { args regex } {
 	global sprio
-	set matches 0
 
-	spawn $sprio {*}$args
-	expect {
-		-re $regex {
-			incr matches
-			exp_continue
-		}
-		timeout {
-			fail "sprio not responding"
-		}
-		eof {
-			wait
-		}
-	}
-
-	if {$matches != $match_cnt} {
-		fail "sprio $args failed to match '$regex' $match_cnt times"
-	}
+	wait_for -timeout 5 -poll .1 {
+		[regexp $regex [run_command_output -fail "$sprio $args"]] == 1
+	} { }
 }
 
 proc scontrol { args regex match_cnt } {
@@ -298,7 +263,6 @@ if {[info exists env(SPRIO_FORMAT)]} {
 }
 
 set config_path [get_conf_path]
-fail_on_error "Unable to get config path"
 set config_file $config_path/slurm.conf
 
 save_conf $config_file
@@ -320,10 +284,10 @@ PriorityWeightQOS       = $weight
 PriorityWeightTRES=cpu=$weight
 "
 exec $bin_echo $prio_conf >> $config_file
-reconfigure
+reconfigure -fail
 
 
-set idle_node [get_idle_node_in_part]
+set idle_node [lindex [get_nodes_by_state] 0]
 if {$idle_node == ""} {
 	fail "No idle nodes"
 }
@@ -376,11 +340,11 @@ set jobid1 [sub_job "-n$cpu_cnt -p$p1 -A$ta1 --qos=$tq1" RUNNING]
 set jobid2 [sub_job "-n$cpu_cnt -p$p1 -A$ta1 --qos=$tq1" PENDING]
 set jobid3 [sub_job "-n$cpu_cnt_half -p$p2 -A$ta2 --qos=$tq2" PENDING]
 
-sprio_args "-j $jobid2 -o \"%.15i %10B %10P %10Q %12T\"" "$jobid2\\s+$weight\\s+$part_weight\\s+$weight\\s+cpu=$weight" 1
-sprio_args "-n -j $jobid2 -o \"%.15i %10b %10p %10q %12t\"" "$jobid2\\s+1\\.0+\\s+1\\.0+\\s+1\\.0+\\s+cpu=1\\.0+" 1
+sprio_args "-j $jobid2 -o \"%.15i %10B %10P %10Q %12T\"" "$jobid2\\s+$weight\\s+$part_weight\\s+$weight\\s+cpu=$weight"
+sprio_args "-n -j $jobid2 -o \"%.15i %10b %10p %10q %12t\"" "$jobid2\\s+1\\.0+\\s+1\\.0+\\s+1\\.0+\\s+cpu=1\\.0+"
 
-sprio_args "-j $jobid3 -o \"%.15i %10B %10P %10Q %12T\"" "$jobid3\\s+$weight_half\\s+$part_weight_half\\s+$weight_half\\s+cpu=$weight_half" 1
-sprio_args "-n -j $jobid3 -o \"%.15i %10b %10p %10q %12t\"" "$jobid3\\s+0\\.50+\\s+0\\.50+\\s+0\\.50+\\s+cpu=0\\.5+" 1
+sprio_args "-j $jobid3 -o \"%.15i %10B %10P %10Q %12T\"" "$jobid3\\s+$weight_half\\s+$part_weight_half\\s+$weight_half\\s+cpu=$weight_half"
+sprio_args "-n -j $jobid3 -o \"%.15i %10b %10p %10q %12t\"" "$jobid3\\s+0\\.50+\\s+0\\.50+\\s+0\\.50+\\s+cpu=0\\.5+"
 
 log_info "test2"
 # update priorities to high water mark, job should get full weights because the
@@ -401,9 +365,9 @@ scontrol "show assoc qos=$tq1 flags=qos" "Priority=$weight_half" 1
 
 update_part $p1 "priorityjobfactor=$part_weight_half"
 
-set jobid4 [sub_job "-n$cpu_cnt -p$p2 -A$ta2 --qos=$tq2" PENDING]
-sprio_args "-j $jobid4 -o \"%.15i %10B %10P %10Q %12T\"" "$jobid4\\s+$weight\\s+$part_weight\\s+$weight\\s+cpu=$weight" 1
-sprio_args "-n -j $jobid4 -o \"%.15i %10b %10p %10q %12t\"" "$jobid4\\s+1\\.0+\\s+1\\.0+\\s+1\\.0+\\s+cpu=1\\.0+" 1
+set jobid [sub_job "-n$cpu_cnt -p$p2 -A$ta2 --qos=$tq2" PENDING]
+sprio_args "-j $jobid -o \"%.15i %10B %10P %10Q %12T\"" "$jobid\\s+$weight\\s+$part_weight\\s+$weight\\s+cpu=$weight"
+sprio_args "-n -j $jobid -o \"%.15i %10b %10p %10q %12t\"" "$jobid\\s+1\\.0+\\s+1\\.0+\\s+1\\.0+\\s+cpu=1\\.0+"
 
 
 log_info "test3"
@@ -424,14 +388,14 @@ scontrol "show assoc qos=$tq1 flags=qos" "Priority=$weight" 1
 
 update_part $p1 "priorityjobfactor=$part_weight"
 
-set jobid5 [sub_job "-n$cpu_cnt_half -p$p2 -A$ta2 --qos=$tq2" PENDING]
-sprio_args "-j $jobid5 -o \"%.15i %10B %10P %10Q %12T\"" "$jobid5\\s+$weight_half\\s+$part_weight_half\\s+$weight_half\\s+cpu=$weight_half" 1
-sprio_args "-n -j $jobid5 -o \"%.15i %10b %10p %10q %12t\"" "$jobid5\\s+0\\.50+\\s+0\\.50+\\s+0\\.50+\\s+cpu=0\\.5+" 1
+set jobid [sub_job "-n$cpu_cnt_half -p$p2 -A$ta2 --qos=$tq2" PENDING]
+sprio_args "-j $jobid -o \"%.15i %10B %10P %10Q %12T\"" "$jobid\\s+$weight_half\\s+$part_weight_half\\s+$weight_half\\s+cpu=$weight_half"
+sprio_args "-n -j $jobid -o \"%.15i %10b %10p %10q %12t\"" "$jobid\\s+0\\.50+\\s+0\\.50+\\s+0\\.50+\\s+cpu=0\\.5+"
 
 log_info "test4"
 # test setting priority directly on a job
-set jobid5 [sub_job "-n$cpu_cnt_half -p$p2 -A$ta2 --qos=$tq2" PENDING]
-update_job $jobid5 999
+set jobid [sub_job "-n$cpu_cnt_half -p$p2 -A$ta2 --qos=$tq2" PENDING]
+update_job $jobid 999
 
-sprio_args "-j $jobid5 -o \"%.15i %.10Y %.10S %.10A %.10B %.10F %.10J %.10P %.10Q %.11N %.20T\"" "$jobid5\\s+999\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0" 1
-sprio_args "-n -j $jobid5 -o \"%.15i %.10Y %.10S %.10A %.10B %.10F %.10J %.10P %.10Q %.11N %.20T\"" "$jobid5\\s+999\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0" 1
+sprio_args "-j $jobid -o \"%.15i %.10Y %.10S %.10A %.10B %.10F %.10J %.10P %.10Q %.11N %.20T\"" "$jobid\\s+999\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0"
+sprio_args "-n -j $jobid -o \"%.15i %.10Y %.10S %.10A %.10B %.10F %.10J %.10P %.10Q %.11N %.20T\"" "$jobid\\s+999\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0\\s+0"
diff --git a/testsuite/expect/test25.1 b/testsuite/expect/test25.1
index 4642d6d9e8..04134df099 100755
--- a/testsuite/expect/test25.1
+++ b/testsuite/expect/test25.1
@@ -33,13 +33,19 @@ set exit_code   0
 set file_in     "test$test_id.input"
 set timeout	60
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 #
 # Check accounting config and bail if not found.
 #
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "This test can't be run without a usable AccountStorageType"
 }
-if { [string compare [priority_type] multifactor] } {
+if {[get_config_param "PriorityType"] ne "priority/multifactor"} {
 	skip "This test can't be run without a usable PriorityType"
 }
 
@@ -67,10 +73,9 @@ make_bash_script $file_in "$bin_sleep 600"
 ################################################################
 
 proc sub_job { cpu_cnt } {
-
 	global exit_code file_in number sbatch test_id
-	set file_in	test${test_id}.input
 
+	set file_in	test${test_id}.input
 	set job_id	0
 	spawn $sbatch --output=/dev/null --error=/dev/null -n $cpu_cnt --exclusive $file_in
 	expect {
@@ -79,8 +84,7 @@ proc sub_job { cpu_cnt } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -143,8 +147,7 @@ proc sprio_opt { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -177,8 +180,7 @@ proc sprio_opt { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -210,8 +212,7 @@ proc sprio_opt { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -249,8 +250,7 @@ proc sprio_opt { soption } {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -303,8 +303,7 @@ proc sprio_args { soption sargs jobid} {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -341,8 +340,7 @@ proc sprio_args { soption sargs jobid} {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -379,8 +377,7 @@ proc sprio_args { soption sargs jobid} {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -417,8 +414,7 @@ proc sprio_args { soption sargs jobid} {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -460,8 +456,7 @@ proc sprio_args { soption sargs jobid} {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -498,8 +493,7 @@ proc sprio_args { soption sargs jobid} {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -536,8 +530,7 @@ proc sprio_args { soption sargs jobid} {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -579,8 +572,7 @@ proc sprio_args { soption sargs jobid} {
 				exp_continue
 			}
 			timeout {
-				log_error "sprio not responding"
-				set exit_code 1
+				fail "sprio not responding"
 			}
 			eof {
 				wait
@@ -695,8 +687,6 @@ cancel_job $jobid2
 #
 # Exit with code as appropriate
 #
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test27.1 b/testsuite/expect/test27.1
index ab93af47bf..965893c15b 100755
--- a/testsuite/expect/test27.1
+++ b/testsuite/expect/test27.1
@@ -25,7 +25,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -39,8 +38,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sdiag not responding"
-		set exit_code 1
+		fail "sdiag not responding"
 	}
 	eof {
 		wait
@@ -50,7 +48,3 @@ expect {
 if {$matches != 1} {
 	fail "sdiag --usage failed ($matches)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test27.2 b/testsuite/expect/test27.2
index 308b19c1ca..584aeddaa6 100755
--- a/testsuite/expect/test27.2
+++ b/testsuite/expect/test27.2
@@ -25,7 +25,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -43,8 +42,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sdiag not responding"
-		set exit_code 1
+		fail "sdiag not responding"
 	}
 	eof {
 		wait
@@ -54,7 +52,3 @@ expect {
 if {$matches != 2} {
 	fail "sdiag --help failed ($matches)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test27.3 b/testsuite/expect/test27.3
index 70ba1c0ad7..8e7e24a9f4 100755
--- a/testsuite/expect/test27.3
+++ b/testsuite/expect/test27.3
@@ -25,7 +25,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -39,8 +38,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sdiag not responding"
-		set exit_code 1
+		fail "sdiag not responding"
 	}
 	eof {
 		wait
@@ -50,7 +48,3 @@ expect {
 if {$matches != 1} {
 	fail "sdiag -V failed ($matches)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test27.4 b/testsuite/expect/test27.4
index d608fdda1d..2dd1c5f538 100755
--- a/testsuite/expect/test27.4
+++ b/testsuite/expect/test27.4
@@ -45,8 +45,7 @@ proc sdiag_all { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sdiag not responding"
-			set exit_code 1
+			fail "sdiag not responding"
 		}
 		eof {
 			wait
@@ -72,9 +71,8 @@ set timeout $max_job_delay
 set srun_pid [spawn $srun -N1 -t1 $bin_id]
 expect {	exp_continue
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test27.5 b/testsuite/expect/test27.5
index 5055e0159b..d4719e92da 100755
--- a/testsuite/expect/test27.5
+++ b/testsuite/expect/test27.5
@@ -45,8 +45,7 @@ proc sdiag_all { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sdiag not responding"
-			set exit_code 1
+			fail "sdiag not responding"
 		}
 		eof {
 			wait
diff --git a/testsuite/expect/test28.1 b/testsuite/expect/test28.1
index 02642c379f..c148939c35 100755
--- a/testsuite/expect/test28.1
+++ b/testsuite/expect/test28.1
@@ -36,6 +36,12 @@ set job_id      ""
 set min_task_id 5
 set max_task_id 8
 
+proc cleanup {} {
+	global file_in file_out file_script
+
+	file delete $file_in $file_out $file_script
+}
+
 set array_size [get_config_param "MaxArraySize"]
 if {$array_size < $min_task_id} {
 	skip "MaxArraySize is too small"
@@ -58,8 +64,7 @@ proc scontrol_check { job_id } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -84,8 +89,7 @@ proc multi_squeue_check {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -95,8 +99,7 @@ proc multi_squeue_check {job_id} {
 }
 
 proc multi_scontrol_check { job_id } {
-
-	global scontrol number array_id exit_code
+	global scontrol number array_id
 
 	set task_cnt 0
 	spawn $scontrol show job $job_id
@@ -106,8 +109,7 @@ proc multi_scontrol_check { job_id } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -132,8 +134,7 @@ expect {
 		fail "sbatch did not submit jobs"
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -161,8 +162,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -179,8 +179,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -190,8 +189,6 @@ expect {
 # checks that all the job indexes where cancelled
 scontrol_check $job_id
 
-if {$exit_code == 0} {
-	file delete $file_in $file_out $file_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test28.10 b/testsuite/expect/test28.10
index a512e42fbc..b959c9d61c 100755
--- a/testsuite/expect/test28.10
+++ b/testsuite/expect/test28.10
@@ -32,6 +32,12 @@ set file_script   "test$test_id.sh"
 set job_id        0
 set task_limit    1
 
+proc cleanup {} {
+	global bin_rm file_script
+
+	exec $bin_rm -f $file_script
+}
+
 if {[get_config_param "MaxArraySize"] < [expr $array_size + 1]} {
 	skip "MaxArraySize is too small"
 }
@@ -50,8 +56,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -78,8 +83,7 @@ while { $inx < 10 } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -98,8 +102,7 @@ while { $inx < 10 } {
 		spawn $scontrol update jobid=$job_id arraytaskthrottle $task_limit
 		expect {
 			timeout {
-				log_error "scontrol not responding"
-				set exit_code 1
+				fail "scontrol not responding"
 			}
 			eof {
 				wait
@@ -113,8 +116,6 @@ if {[cancel_job $job_id] != 0} {
 	fail "Unable to cancel job ($job_id)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test28.11 b/testsuite/expect/test28.11
index 1ff5e4574f..e9aa846839 100755
--- a/testsuite/expect/test28.11
+++ b/testsuite/expect/test28.11
@@ -34,62 +34,39 @@ set exit_code 0
 set file_script "test$test_id.sh"
 set config_path ""
 set cwd "[$bin_pwd]"
+set node_feature "$test_name"
 
-proc cleanup { } {
-	global exit_code file_script reconfigure bin_cp cwd config_file test_id
-	restore_conf $config_file
-	file delete $file_script
-	reconfigure
+if {![is_super_user]} {
+	skip "This test must be run as SlurmUser or root"
 }
 
-proc get_single_node_feature { } {
-	global scontrol exit_code re_word_str
-	set ret_features ""
-
-	log_user 1
-	set scon_pid [spawn $scontrol show node]
-	expect {
-		-re "AvailableFeatures=($re_word_str)" {
-			set ret_features $expect_out(1,string)
-			if [string match "(null)" $ret_features] {
-				set ret_features ""
-				exp_continue
-			}
-			set coma_pos [expr [string last , $ret_features] -1]
-			if { $coma_pos > 0 } {
-				set ret_features [string range $ret_features 0 $coma_pos]
-			}
-			# Don't exp_continue since we only care about one.
-		}
-		timeout {
-			log_error "scontrol not responding"
-			slow_kill $scon_pid
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	return $ret_features
-}
+proc cleanup { } {
+	global config_file file_script
 
-if {![is_super_user]} {
-	skip "This test must be run as SlurmUser or root"
+	# Restore previous MinJobAge and AvailableFeatures
+	restore_conf $config_file
+	reconfigure
+	file delete $file_script
 }
 
+# Change the slurm.conf MinJobAge=10 so we don't have to wait very long.
 set config_path [get_conf_path]
-fail_on_error "Not able to get config_path"
-
 set config_file $config_path/slurm.conf
-
 save_conf $config_file
 
-# Change the slurm.conf MinJobAge=10 so we don't have to wait very long.
 exec $bin_sed -i /^\[\t\s\]*MinJobAge\[\t\s\]*=/Id $config_file
 exec $bin_echo -e "\nMinJobAge=10" >> $config_file
-
-reconfigure
-fail_on_error "Not able to reconfigure"
+reconfigure -fail
+
+# Setup the necessary feature to do the test
+set node [get_nodes_by_request "-N1 -t1"]
+set features [get_node_param $node "AvailableFeatures"]
+if {$features == "(null)"} {
+	set features "$node_feature"
+} else {
+	set features "$features,$node_feature"
+}
+run_command -fail "$scontrol update nodename=$node AvailableFeatures=$features"
 
 # Verify that MinJobAge was set
 regexp "($number)" [get_config_param "MinJobAge"] {} min_job_age
@@ -97,11 +74,6 @@ if {$min_job_age != 10} {
 	fail "MinJobAge was not set"
 }
 
-set node_feature [get_single_node_feature]
-if { $node_feature == "" } {
-	skip "Cannot run this test without any node features."
-}
-
 # It doesn't matter how long the job sleeps; it will be cancelled anyway.
 make_bash_script $file_script "sleep 5"
 set job_id 0
@@ -119,15 +91,16 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch timed out"
-		set exit_code 1
+		fail "sbatch timed out"
 	}
 	eof {
 		wait
 	}
 }
 
-fail_on_error "Error submitting job"
+if {$exit_code != 0} {
+	fail "Error submitting job"
+}
 
 # Wait enough time for the jobs to be in the controller
 set count 0
@@ -145,8 +118,9 @@ subtest -fail { $count == $count_exp } "Jobs have requested feature $node_featur
                                                 $count_exp $node_feature $count]
 
 # Cancel the jobs and wait for them to purged from the controller
-set exit_code [cancel_job $job_id]
-fail_on_error "Problem cancelling job $job_id"
+if [cancel_job $job_id] {
+	fail "Problem cancelling job $job_id"
+}
 
 set exit_code 1
 set sleep_time $min_job_age
@@ -161,12 +135,9 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol timed out"
-		set exit_code 1
+		fail "scontrol timed out"
 	}
 	eof {
 		wait
 	}
 }
-
-pass
diff --git a/testsuite/expect/test28.12 b/testsuite/expect/test28.12
index f2bbb51ab8..4cffd1eb70 100755
--- a/testsuite/expect/test28.12
+++ b/testsuite/expect/test28.12
@@ -30,6 +30,13 @@ set exit_code   0
 set file_script "test$test_id.bash"
 set job_id      0
 
+proc cleanup {} {
+	global job_id file_script
+
+	cancel_job $job_id
+	file delete $file_script
+}
+
 regexp "($number)" [get_config_param "MinJobAge"] {} min_job_age
 if {$min_job_age > 60} {
 	skip "MinJobAge too large for this test ($min_job_age > 60)"
@@ -55,8 +62,7 @@ expect {
 		fail "sbatch did not submit jobs"
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -87,8 +93,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -98,9 +103,6 @@ if {$match != 1} {
 	fail "Head job not found"
 }
 
-cancel_job $job_id
-if {$exit_code == 0} {
-	file delete $file_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test28.13 b/testsuite/expect/test28.13
index 09621fc6ea..bb66e5b5f2 100755
--- a/testsuite/expect/test28.13
+++ b/testsuite/expect/test28.13
@@ -30,6 +30,13 @@ set exit_code   0
 set file_script "test$test_id.bash"
 set job_id      0
 
+proc cleanup {} {
+	global job_id file_script
+
+	cancel_job $job_id
+	file delete $file_script
+}
+
 make_bash_script $file_script "
 if \[ \$SLURM_ARRAY_TASK_ID == 2 \]
 then
@@ -50,8 +57,7 @@ expect {
 		fail "sbatch did not submit jobs"
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -74,8 +80,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -91,8 +96,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -114,20 +118,16 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
 	}
 }
-cancel_job $job_id
 if {$match != 3} {
 	fail "Failed to requeue desired count of job array elements ($match != 3)"
 }
 
-if {$exit_code == 0} {
-	file delete $file_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test28.2 b/testsuite/expect/test28.2
index b0ecb3e426..2a079a13d5 100755
--- a/testsuite/expect/test28.2
+++ b/testsuite/expect/test28.2
@@ -56,6 +56,11 @@ proc delete_file {} {
 	exec $bin_rm -f $file_script
 }
 
+proc cleanup {} {
+
+	delete_file
+}
+
 # delete any remaining output files
 delete_file
 
@@ -82,9 +87,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -118,9 +121,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -207,8 +208,6 @@ for {set index 0} {$index < $array_end} {incr index} {
 	}
 }
 
-if {$exit_code == 0} {
-	delete_file
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test28.3 b/testsuite/expect/test28.3
index 73de662e68..5f00e4cb5b 100755
--- a/testsuite/expect/test28.3
+++ b/testsuite/expect/test28.3
@@ -32,12 +32,17 @@ set array_size    4
 set file_script   "test$test_id.sh"
 set job_id        0
 
+proc cleanup {} {
+	global bin_rm file_script
+
+	exec $bin_rm -f $file_script
+}
+
 if {[get_config_param "MaxArraySize"] < [expr $array_size + 1]} {
 	skip "MaxArraySize is to small"
 }
 
 proc check_ids { job } {
-
 	global scontrol array_size exit_code number
 
 	for {set index 0} {$index<$array_size} {incr index} {
@@ -49,8 +54,7 @@ proc check_ids { job } {
 				exp_continue
 			}
 			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
+				fail "scontrol is not responding"
 			}
 			eof {
 				wait
@@ -76,8 +80,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -90,8 +93,6 @@ if {$job_id != 0} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test28.4 b/testsuite/expect/test28.4
index b7fd759bc9..6d5826acdb 100755
--- a/testsuite/expect/test28.4
+++ b/testsuite/expect/test28.4
@@ -33,12 +33,17 @@ set file_script   "test$test_id.sh"
 set job_id        0
 set array_in      2
 
+proc cleanup {} {
+	global bin_rm file_script
+
+	exec $bin_rm -f $file_script
+}
+
 if {[get_config_param "MaxArraySize"] < [expr $array_size + 1]} {
 	skip "MaxArraySize is too small"
 }
 
 proc check_update { job job_time } {
-
 	global scontrol number exit_code
 
 	set new_job_id 0
@@ -56,8 +61,7 @@ proc check_update { job job_time } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -75,14 +79,12 @@ proc check_update { job job_time } {
 }
 
 proc update_job { job job_time } {
-
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol update jobid=$job TimeLimit=$job_time
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -105,8 +107,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -131,8 +132,6 @@ if {[cancel_job $job_id] != 0} {
 	fail "Unable to cancel job ($job_id)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test28.5 b/testsuite/expect/test28.5
index 84b15df2ed..eb60212e36 100755
--- a/testsuite/expect/test28.5
+++ b/testsuite/expect/test28.5
@@ -33,19 +33,23 @@ set array_in     2
 set array_size   4
 set file_script  "test$test_id.sh"
 
+proc cleanup {} {
+	global bin_rm file_script
+
+	exec $bin_rm -f $file_script
+}
+
 if {[get_config_param "MaxArraySize"] < [expr $array_size + 1]} {
 	skip "MaxArraySize is to small for this test"
 }
 
 proc hold_job {job} {
-
 	global scontrol exit_code
 
 	spawn $scontrol hold $job
 	expect {
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -54,14 +58,12 @@ proc hold_job {job} {
 }
 
 proc release_job {job} {
-
 	global scontrol exit_code
 
 	spawn $scontrol release $job
 	expect {
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -71,7 +73,6 @@ proc release_job {job} {
 
 #change this so it checks through all the jobs in the array
 proc check_hold_job {job} {
-
 	global scontrol exit_code number
 
 	set pmatch 0
@@ -84,8 +85,7 @@ proc check_hold_job {job} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -98,7 +98,6 @@ proc check_hold_job {job} {
 }
 
 proc check_release_job { job } {
-
 	global scontrol exit_code number
 
 	set pmatch 0
@@ -111,8 +110,7 @@ proc check_release_job { job } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -140,8 +138,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -180,8 +177,6 @@ if {$job_id != 0} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test28.6 b/testsuite/expect/test28.6
index 823ef02b7f..7e398b95a6 100755
--- a/testsuite/expect/test28.6
+++ b/testsuite/expect/test28.6
@@ -34,6 +34,12 @@ set script	 "$test_name\_script"
 set array_size	 2
 set exit_code	 0
 
+proc cleanup {} {
+	global bin_rm script
+
+	exec $bin_rm -f $script
+}
+
 if {[get_config_param "MaxArraySize"] < [expr $array_size + 1]} {
 	skip "MaxArraySize is to small for this test"
 } elseif {![is_super_user]} {
@@ -57,8 +63,7 @@ proc check_job { job_id } {
 				exp_continue
 			}
 			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
+				fail "scontrol is not responding"
 			}
 			eof {
 				wait
@@ -91,8 +96,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -109,13 +113,12 @@ if {[string compare $node_list ""] == 0} {
 spawn $scontrol create PartitionName=$test_part Nodes=$node_list
 expect {
 	-re "error" {
-		log_error"scontrol did not create partition"
+		log_error "scontrol did not create partition"
 		set exit_code 1
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -132,8 +135,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -161,16 +163,13 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $script 
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test28.7 b/testsuite/expect/test28.7
index bb4b6abd7b..c2f169fca4 100755
--- a/testsuite/expect/test28.7
+++ b/testsuite/expect/test28.7
@@ -29,6 +29,13 @@ source ./globals
 set exit_code     0
 set array_size    3
 set top_array_task_id [expr $array_size - 1]
+set job_id        0
+
+proc cleanup {} {
+	global job_id
+
+	cancel_job $job_id
+}
 
 if {$array_size > [get_config_param "MaxArraySize"]} {
 	skip "MaxArraySize is too small"
@@ -37,7 +44,6 @@ if {$array_size > [get_config_param "MaxArraySize"]} {
 #
 # Submit a job array for first dependency test
 #
-set job_id 0
 spawn $sbatch -N1 -t1 -a 0-$top_array_task_id -o /dev/null -e /dev/null --wrap "sleep \$(( ( RANDOM % 10 ) + 1 ))"
 expect {
 	-re "Submitted batch job ($number)" {
@@ -45,8 +51,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -68,9 +73,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -96,8 +100,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -119,9 +122,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -131,7 +133,6 @@ if {$match_job_state != $array_size} {
 	fail "Dependent job not completed ($match_job_state != $array_size)"
 }
 
-cancel_job $job_id
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test28.8 b/testsuite/expect/test28.8
index c0a1b4d3b9..cde5bf4e16 100755
--- a/testsuite/expect/test28.8
+++ b/testsuite/expect/test28.8
@@ -36,6 +36,13 @@ set file_script    "test$test_id.bash"
 set job_id         0
 set not_supported  0
 
+proc cleanup {} {
+	global job_id bin_rm file_script
+
+	cancel_job $job_id
+	exec $bin_rm -f $file_script
+}
+
 if {[get_config_param "MaxArraySize"] < [expr $array_size + 1]} {
 	skip "MaxArraySize is to small for this test"
 }
@@ -65,8 +72,7 @@ proc suspend_job { job_id operation } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -90,8 +96,7 @@ proc check_output { file_name } {
 			exp_continue
 		}
 		timeout {
-			log_error "cat not responding"
-			set exit_code 1
+			fail "cat not responding"
 		}
 		eof {
 			wait
@@ -123,8 +128,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -154,10 +158,7 @@ if {[wait_for_job ${job_id}_1 RUNNING] != 0} {
 	cancel_job $job_id
 	fail "Error resuming job $job_id"
 }
-cancel_job $job_id
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test28.9 b/testsuite/expect/test28.9
index 02d31f945f..3d3c40b822 100755
--- a/testsuite/expect/test28.9
+++ b/testsuite/expect/test28.9
@@ -32,6 +32,13 @@ set file_script   "test$test_id.sh"
 set job_id        0
 set array_in      2
 
+proc cleanup {} {
+	global job_id bin_rm file_script
+
+	cancel_job $job_id
+	exec $bin_rm -f $file_script
+}
+
 if {[get_config_param "MaxArraySize"] < [expr $array_size + 1]} {
 	skip "MaxArraySize is too small"
 }
@@ -50,8 +57,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -77,8 +83,7 @@ while { $inx < 10 } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -95,12 +100,6 @@ while { $inx < 10 } {
 	incr inx
 }
 
-if {[cancel_job $job_id] != 0} {
-	fail "Unable to cancel job ($job_id)"
-}
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_script
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test29.1 b/testsuite/expect/test29.1
index 1eead9e623..636ff1cf00 100755
--- a/testsuite/expect/test29.1
+++ b/testsuite/expect/test29.1
@@ -9,9 +9,7 @@
 ############################################################################
 source ./globals
 
-set exit_code  0
-
-if {![slurmctld_plug_stack_nonstop]} {
+if {![param_contains [get_config_param "SlurmctldPlugstack"] "nonstop"]} {
 	skip "This test is only compatible when SlurmctldPlugstack includes nonstop"
 }
 
@@ -30,8 +28,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -41,7 +38,3 @@ expect {
 if {$match != 2} {
 	fail "smd --usage failed $match"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test29.2 b/testsuite/expect/test29.2
index a8e730a584..f394370153 100755
--- a/testsuite/expect/test29.2
+++ b/testsuite/expect/test29.2
@@ -9,9 +9,7 @@
 ############################################################################
 source ./globals
 
-set exit_code  0
-
-if {![slurmctld_plug_stack_nonstop]} {
+if {![param_contains [get_config_param "SlurmctldPlugstack"] "nonstop"]} {
 	skip "This test is only compatible when SlurmctldPlugstack includes nonstop"
 }
 
@@ -26,8 +24,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -49,8 +46,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -59,7 +55,3 @@ expect {
 if {$match != 2} {
 	fail "smd show config failed"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test29.3 b/testsuite/expect/test29.3
index 2d2c876834..5c0178f523 100755
--- a/testsuite/expect/test29.3
+++ b/testsuite/expect/test29.3
@@ -15,7 +15,18 @@ set node_name  ""
 set file_in    "test$test_id.script"
 set exit_code  0
 
-if {![slurmctld_plug_stack_nonstop]} {
+proc cleanup {} {
+	global job_id node_name bin_rm file_in
+
+	cancel_job $job_id
+	if {$node_name ne ""} {
+		reset_state $node_name
+	}
+
+	exec $bin_rm -f $file_in
+}
+
+if {![param_contains [get_config_param "SlurmctldPlugstack"] "nonstop"]} {
 	skip "This test is only compatible when SlurmctldPlugstack includes nonstop"
 }
 if {![is_super_user]} {
@@ -23,7 +34,7 @@ if {![is_super_user]} {
 }
 
 proc get_node {job_id} {
-	global scontrol squeue re_word_str re_word_str exit_code
+	global scontrol squeue re_word_str re_word_str
 
 	set node_list ""
 	spawn $squeue -j $job_id --noheader -o NodeList=%N
@@ -33,8 +44,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -49,8 +59,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -60,13 +69,12 @@ proc get_node {job_id} {
 }
 
 proc reset_state {node} {
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol update NodeName=$node State=RESUME
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -87,8 +95,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -119,8 +126,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -143,8 +149,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not reponding"
-		set exit_code 1
+		fail "smd is not reponding"
 	}
 	eof {
 		wait
@@ -167,8 +172,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -180,12 +184,6 @@ if {$sub_match != 1} {
 	set exit_code 1
 }
 
-cancel_job $job_id
-
-reset_state $node_name
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test29.4 b/testsuite/expect/test29.4
index 167cc4770f..fb40c4367f 100755
--- a/testsuite/expect/test29.4
+++ b/testsuite/expect/test29.4
@@ -15,7 +15,18 @@ set file_in     "test$test_id.script"
 set reason_str  "test"
 set exit_code   0
 
-if {![slurmctld_plug_stack_nonstop]} {
+proc cleanup {} {
+	global job_id node_name bin_rm file_in
+
+	cancel_job $job_id
+	if {$node_name ne ""} {
+		reset_state $node_name
+	}
+
+	exec $bin_rm -f $file_in
+}
+
+if {![param_contains [get_config_param "SlurmctldPlugstack"] "nonstop"]} {
 	skip "This test is only compatible when SlurmctldPlugstack includes nonstop"
 }
 if {![is_super_user]} {
@@ -23,7 +34,7 @@ if {![is_super_user]} {
 }
 
 proc get_node {job_id} {
-	global scontrol squeue re_word_str re_word_str exit_code
+	global scontrol squeue re_word_str re_word_str
 
 	set node_list ""
 	spawn $squeue -j $job_id --noheader -o NodeList=%N
@@ -33,8 +44,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -49,8 +59,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -60,14 +69,12 @@ proc get_node {job_id} {
 }
 
 proc reset_state {node} {
-
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol update NodeName=$node State=RESUME
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -88,8 +95,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -121,8 +127,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not reponding"
-		set exit_code 1
+		fail "smd is not reponding"
 	}
 	eof {
 		wait
@@ -148,8 +153,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -161,13 +165,6 @@ if {$match != 2} {
 	set exit_code 1
 }
 
-
-cancel_job $job_id
-
-reset_state $node_name
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test29.5 b/testsuite/expect/test29.5
index 95830c770b..a319484f10 100755
--- a/testsuite/expect/test29.5
+++ b/testsuite/expect/test29.5
@@ -14,9 +14,20 @@ set node_name   ""
 set job_id      0
 set exit_code   0
 
+proc cleanup {} {
+	global job_id node_name bin_rm file_in
+
+	cancel_job $job_id
+	if {$node_name ne ""} {
+		reset_state $node_name
+	}
+
+	exec $bin_rm -f $file_in
+}
+
 # this test is for the nonstop --replace-node test
 
-if {![slurmctld_plug_stack_nonstop]} {
+if {![param_contains [get_config_param "SlurmctldPlugstack"] "nonstop"]} {
 	skip "This test is only compatible when SlurmctldPlugstack includes nonstop"
 }
 if {![is_super_user]} {
@@ -24,7 +35,7 @@ if {![is_super_user]} {
 }
 
 proc get_node {job_id} {
-	global scontrol squeue re_word_str re_word_str exit_code
+	global scontrol squeue re_word_str re_word_str
 
 	set node_list ""
 	spawn $squeue -j $job_id --noheader -o NodeList=%N
@@ -34,8 +45,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -50,8 +60,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -61,14 +70,12 @@ proc get_node {job_id} {
 }
 
 proc reset_state {node} {
-
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol update NodeName=$node State=RESUME
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -89,8 +96,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -122,8 +128,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not reponding"
-		set exit_code 1
+		fail "smd is not reponding"
 	}
 	eof {
 		wait
@@ -145,8 +150,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not reponding"
-		set exit_code 1
+		fail "smd is not reponding"
 	}
 	eof {
 		wait
@@ -168,8 +172,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not reponding"
-		set exit_code 0
+		fail "smd is not reponding"
 	}
 	eof {
 		wait
@@ -181,12 +184,6 @@ if {$sub_match != 1} {
 	set exit_code
 }
 
-cancel_job $job_id
-
-reset_state $node_name
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test29.6 b/testsuite/expect/test29.6
index a6735f4c91..3cf3ff51d3 100755
--- a/testsuite/expect/test29.6
+++ b/testsuite/expect/test29.6
@@ -16,7 +16,18 @@ set node_name   ""
 set time_limit  0
 set exit_code   0
 
-if {![slurmctld_plug_stack_nonstop]} {
+proc cleanup {} {
+	global job_id node_name bin_rm file_in
+
+	cancel_job $job_id
+	if {$node_name ne ""}  {
+		reset_state $node_name
+	}
+
+	exec $bin_rm -f $file_in
+}
+
+if {![param_contains [get_config_param "SlurmctldPlugstack"] "nonstop"]} {
 	skip "This test is only compatible when SlurmctldPlugstack includes nonstop"
 }
 if {![is_super_user]} {
@@ -26,7 +37,7 @@ if {![is_super_user]} {
 make_bash_script $file_in "$bin_sleep 100"
 
 proc get_node {job_id} {
-	global scontrol squeue re_word_str re_word_str exit_code
+	global scontrol squeue re_word_str re_word_str
 
 	set node_list ""
 	spawn $squeue -j $job_id --noheader -o NodeList=%N
@@ -36,8 +47,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -52,8 +62,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -63,14 +72,12 @@ proc get_node {job_id} {
 }
 
 proc reset_state {node} {
-
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol update NodeName=$node State=RESUME
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -79,8 +86,7 @@ proc reset_state {node} {
 }
 
 proc get_time_limit {} {
-
-	global smd time_limit number exit_code
+	global smd time_limit number
 
 	spawn $smd -c
 	expect {
@@ -89,8 +95,7 @@ proc get_time_limit {} {
 			exp_continue
 		}
 		timeout {
-			log_error "smd is not responding"
-			set exit_code 1
+			fail "smd is not responding"
 		}
 		eof {
 			wait
@@ -108,8 +113,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -140,8 +144,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -163,8 +166,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -188,8 +190,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -213,8 +214,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -225,12 +225,6 @@ if {$time_ext != 1} {
 	set exit_code 1
 }
 
-cancel_job $job_id
-
-reset_state $node_name
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test29.7 b/testsuite/expect/test29.7
index 29ed3fa00a..6656ffcb28 100755
--- a/testsuite/expect/test29.7
+++ b/testsuite/expect/test29.7
@@ -14,7 +14,18 @@ set file_in     "test$test_id.script"
 set job_id      0
 set exit_code   0
 
-if {![slurmctld_plug_stack_nonstop]} {
+proc cleanup {} {
+	global job_id node_name bin_rm file_in
+
+	cancel_job $job_id
+	if {$node_name ne ""} {
+		reset_state $node_name
+	}
+
+	exec $bin_rm -f $file_in
+}
+
+if {![param_contains [get_config_param "SlurmctldPlugstack"] "nonstop"]} {
 	skip "This test is only compatible when SlurmctldPlugstack includes nonstop"
 }
 if {![is_super_user]} {
@@ -24,7 +35,7 @@ if {![is_super_user]} {
 make_bash_script $file_in "$bin_sleep 100"
 
 proc get_node {job_id} {
-	global scontrol squeue re_word_str re_word_str exit_code
+	global scontrol squeue re_word_str re_word_str
 
 	set node_list ""
 	spawn $squeue -j $job_id --noheader -o NodeList=%N
@@ -34,8 +45,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -50,8 +60,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -61,14 +70,12 @@ proc get_node {job_id} {
 }
 
 proc reset_state {node} {
-
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol update NodeName=$node State=RESUME
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -87,8 +94,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -119,8 +125,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -142,8 +147,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -165,8 +169,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "smd is not responding"
-		set exit_code 1
+		fail "smd is not responding"
 	}
 	eof {
 		wait
@@ -177,12 +180,6 @@ if {$sub_match != 1} {
 	set exit_code 1
 }
 
-cancel_job $job_id
-
-reset_state $node_name
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test29.8 b/testsuite/expect/test29.8
index eedb4a78a5..12b9ff7ce5 100755
--- a/testsuite/expect/test29.8
+++ b/testsuite/expect/test29.8
@@ -17,7 +17,15 @@ set fail_node    ""
 set job_id       0
 set exit_code    0
 
-if {![slurmctld_plug_stack_nonstop]} {
+proc cleanup {} {
+	global job_id bin_rm file_in
+
+	cancel_job $job_id
+
+	exec $bin_rm -f $file_in
+}
+
+if {![param_contains [get_config_param "SlurmctldPlugstack"] "nonstop"]} {
 	skip "This test is only compatible when SlurmctldPlugstack includes nonstop"
 }
 if {![is_super_user]} {
@@ -27,7 +35,7 @@ if {![is_super_user]} {
 make_bash_script $file_in "$bin_sleep 100"
 
 proc get_max_spare_node_cnt {} {
-	global smd number exit_code
+	global smd number
 
 	set spare_node_cnt 0
 	spawn $smd -c
@@ -37,8 +45,7 @@ proc get_max_spare_node_cnt {} {
 			exp_continue
 		}
 		timeout {
-			log_error "smd is not responding"
-			set exit_code 1
+			fail "smd is not responding"
 		}
 		eof {
 			wait
@@ -48,7 +55,7 @@ proc get_max_spare_node_cnt {} {
 }
 
 proc get_node {job_id} {
-	global scontrol squeue re_word_str re_word_str exit_code
+	global scontrol squeue re_word_str re_word_str
 
 	set node_list ""
 	spawn $squeue -j $job_id --noheader -o NodeList=%N
@@ -58,8 +65,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -74,8 +80,7 @@ proc get_node {job_id} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -85,13 +90,12 @@ proc get_node {job_id} {
 }
 
 proc reset_state {node} {
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol update NodeName=$node State=RESUME
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -110,8 +114,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -141,8 +144,7 @@ for {set count 0} {$count <= $spare_node} {incr count 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "smd is not responding"
-			set exit_code 1
+			fail "smd is not responding"
 		}
 		eof {
 			wait
@@ -166,8 +168,7 @@ for {set count 0} {$count <= $spare_node} {incr count 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "smd is not responding"
-			set exit_code 1
+			fail "smd is not responding"
 		}
 		eof {
 			wait
@@ -192,19 +193,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-cancel_job $job_id
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
 
diff --git a/testsuite/expect/test3.1 b/testsuite/expect/test3.1
index f890964485..25bd29172a 100755
--- a/testsuite/expect/test3.1
+++ b/testsuite/expect/test3.1
@@ -28,8 +28,23 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.input"
+set job_id      0
+
+# TODO: Temporary variables to debug bug 9647 (remove once fixed)
+set config_dir  [get_conf_path]
+
+proc cleanup {} {
+	global job_id bin_rm file_in
+
+	cancel_job $job_id
+	exec $bin_rm -f $file_in
+
+	# TODO: Temporary cleanup of debug for bug 9647 (remove once fixed)
+	global config_dir scontrol
+    restore_conf $config_dir/slurm.conf
+    run_command "$scontrol reconfigure"
+}
 
 #
 # This test must be run as a Slurm administrator, root, or SlurmUser in order to
@@ -39,13 +54,18 @@ if {[string compare [get_admin_level] "Administrator"]} {
 	skip "This test can be run only for Administrators"
 }
 
+# TODO: Temporarily increase logging to debug bug 9647 (remove once fixed)
+save_conf $config_dir/slurm.conf
+run_command -none "$bin_echo SlurmctldDebug=debug3 >> $config_dir/slurm.conf"
+run_command -none "$bin_echo SlurmdDebug=debug3 >> $config_dir/slurm.conf"
+# Allow the test's existing reconfigure call to establish these values
+
 #
 # Have a job running when the reconfigure happens
 #
 make_bash_script $file_in "
   $srun $bin_sleep 60
 "
-set job_id 0
 set sbatch_pid [spawn $sbatch -N1 --output=/dev/null -t2 $file_in]
 expect {
 	-re "Submitted batch job ($number)" {
@@ -53,9 +73,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
 		catch {exec $bin_kill -KILL $sbatch_pid}
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -72,15 +91,8 @@ if {[wait_for_job $job_id RUNNING] != 0} {
 #
 # Issue scontrol reconfigure
 #
-reconfigure
+reconfigure -fail
 
 if {[wait_for_job $job_id RUNNING] != 0} {
 	fail "Job $job_id not running after reconfiguration"
 }
-cancel_job $job_id
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test3.11 b/testsuite/expect/test3.11
index ca8dafe508..8394edd318 100755
--- a/testsuite/expect/test3.11
+++ b/testsuite/expect/test3.11
@@ -59,6 +59,12 @@ set def_node_inx_max	-1
 set ii			0
 set log_cpu_cnt		0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {![is_super_user]} {
 	skip "This test can't be run except as SlurmUser"
 }
@@ -179,7 +185,7 @@ if {$heterogeneous != 0} {
 	log_warn "Cluster is heterogeneous and some tests may fail"
 }
 set cores_per_node [expr $cores_per_socket * $sockets_per_node]
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state idle,alloc,comp]]
 set cluster_cpus [expr $cores_per_node * $node_count]
 
 set cr_socket 0
@@ -189,7 +195,7 @@ if {[param_contains $select_type_parameters "CR_SOCKET*"]} {
 
 # Retrieve a node from partition and total cores in partition
 set states "idle"
-set node_list [get_partition_nodes $def_partition $states]
+set node_list [get_nodes_by_state $states $def_partition]
 set part_node_cnt [llength $node_list]
 if {$part_node_cnt == 0} {
 	fail "Unable to get $states nodes in partition $def_partition"
@@ -233,11 +239,9 @@ if {$cons_res_actived == 1 && $part_node_cores > 1 && $core_spec == 0 && $exclus
 if {$cons_res_actived == 1 && $part_node_cores > 1 && $core_spec == 0 && $exclusive == 0 && $cr_socket == 0 && $irregular_node_name == 0 && $heterogeneous == 0} {
 	inc3_11_9
 }
-
 inc3_11_10
 inc3_11_11
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors"
+
+if {$exit_code != 0} {
+	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test3.12 b/testsuite/expect/test3.12
index 75bd2e5e74..37e5b82b40 100755
--- a/testsuite/expect/test3.12
+++ b/testsuite/expect/test3.12
@@ -52,8 +52,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -87,8 +86,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -111,8 +109,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -149,8 +146,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -168,8 +164,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test3.13 b/testsuite/expect/test3.13
index 7ae7cfd400..d539ca0908 100755
--- a/testsuite/expect/test3.13
+++ b/testsuite/expect/test3.13
@@ -36,6 +36,12 @@ set job_id        0
 set new_prio      1
 set read_priority -1
 
+proc cleanup {} {
+	global job_id
+
+	cancel_job $job_id
+}
+
 #
 # Build input script file
 #
@@ -51,9 +57,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -74,8 +79,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -96,8 +100,7 @@ expect {
 		skip "User not authorized to modify jobs"
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -116,8 +119,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -141,8 +143,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -163,8 +164,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -174,9 +174,6 @@ if {$read_priority == 0} {
 	fail "scontrol priority change error"
 }
 
-if {[cancel_job $job_id] != 0} {
-	fail "Unable to cancel job ($job_id)"
-}
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test3.14 b/testsuite/expect/test3.14
index 5321028483..9d1e98d78d 100755
--- a/testsuite/expect/test3.14
+++ b/testsuite/expect/test3.14
@@ -37,7 +37,7 @@ if {![is_super_user]} {
 }
 
 set def_part_name [default_partition]
-set nb_nodes [get_node_cnt_in_part $def_part_name]
+set nb_nodes [get_partition_param $def_part_name "TotalNodes"]
 if {$nb_nodes < 3} {
 	skip "This test requires at least 3 nodes in the cluster"
 }
@@ -66,8 +66,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -84,8 +83,7 @@ if {$match != 1} {
 spawn $srun -t1 -n1 --reservation=$resv_name $bin_hostname
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -102,8 +100,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -124,8 +121,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -145,8 +141,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -171,15 +166,13 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors"
 }
diff --git a/testsuite/expect/test3.15 b/testsuite/expect/test3.15
index 90bfeba085..5341f864d7 100755
--- a/testsuite/expect/test3.15
+++ b/testsuite/expect/test3.15
@@ -30,6 +30,8 @@ set exit_code		0
 set license_name        "test$test_id"
 set resv_name           "resv$test_id"
 set user_name		""
+set job_id1             0
+set job_id2             0
 
 proc submit_job { license_count } {
 	global bin_sleep license_name sbatch number exit_code
@@ -41,9 +43,7 @@ proc submit_job { license_count } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
-			exp_continue
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -58,6 +58,7 @@ proc submit_job { license_count } {
 
 proc reason_is_licenses { job_id } {
 	global squeue
+
 	set reason_licenses 0
 	spawn $squeue -j $job_id -o "%r"
 	expect {
@@ -66,9 +67,7 @@ proc reason_is_licenses { job_id } {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue not responding"
-			set exit_code 1
-			exp_continue
+			fail "squeue not responding"
 		}
 		eof {
 			wait
@@ -97,9 +96,7 @@ proc test_license_count {want_total want_used want_free } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
-			exp_continue
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -153,8 +150,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -173,6 +169,20 @@ set cwd "[$bin_pwd]"
 
 save_conf $config_file
 
+proc cleanup {} {
+	global job_id1 job_id2
+
+	#
+	# Cancel the jobs and
+	# Restore the configuration
+	#
+	cancel_job $job_id1
+	cancel_job $job_id2
+
+	restore_conf $config_file
+	reconfigure
+}
+
 set sep ""
 if {[string length ${licenses}] > 0} {
 	set sep ","
@@ -182,7 +192,7 @@ exec $bin_echo "Licenses=${licenses}${sep}${license_name}:8" >> $cwd/slurm.conf.
 exec $bin_cp $cwd/slurm.conf.work $config_file
 exec $bin_rm -f $cwd/slurm.conf.work
 
-reconfigure
+reconfigure -fail
 
 #
 # Delete any vesgitial advanced reservation, then
@@ -271,13 +281,3 @@ if { [reason_is_licenses $job_id2] != 0 } {
 # Test scontrol show license output
 #
 test_license_count 8 7 1
-
-#
-# Cancel the jobs and
-# Restore the configuration
-#
-cancel_job $job_id1
-cancel_job $job_id2
-restore_conf $config_file
-reconfigure
-fail_on_error "Error restoring reconfiguration"
diff --git a/testsuite/expect/test3.16 b/testsuite/expect/test3.16
index cf9ebc80ad..a9c5413d69 100755
--- a/testsuite/expect/test3.16
+++ b/testsuite/expect/test3.16
@@ -34,7 +34,6 @@ set lic_c           "lic_c_test$test_id"
 set cluster [get_config_param "ClusterName"]
 
 proc add_lic { license } {
-
 	global sacctmgr exit_code cluster
 
 	set added 0
@@ -46,8 +45,7 @@ proc add_lic { license } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not reponding"
-			set exit_code 1
+			fail "sacctmgr is not reponding"
 		}
 		eof {
 			wait
@@ -61,7 +59,6 @@ proc add_lic { license } {
 }
 
 proc delete_lic { license } {
-
 	global sacctmgr exit_code 1
 
 	set deleted 0
@@ -72,8 +69,7 @@ proc delete_lic { license } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -92,6 +88,14 @@ if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"}
         skip "This test can't be run without superuser permissions"
 }
 
+proc cleanup {} {
+	global lic_a lic_b lic_c
+
+	delete_lic $lic_a
+	delete_lic $lic_b
+	delete_lic $lic_c
+}
+
 # Add the licenses in random order
 add_lic $lic_c
 add_lic $lic_a
@@ -113,8 +117,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -125,10 +128,6 @@ if { $match != 3 } {
 	fail "Licenses are not sorted"
 }
 
-delete_lic $lic_a
-delete_lic $lic_b
-delete_lic $lic_c
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test3.17 b/testsuite/expect/test3.17
index c0d695b984..b3fc2b4312 100755
--- a/testsuite/expect/test3.17
+++ b/testsuite/expect/test3.17
@@ -24,22 +24,23 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-set feature	"test$test_id"
-set file_in     "test$test_id.input"
+set feature	            "test$test_id"
+set file_in                 "test$test_id.input"
+set node_name               ""
+set orig_avail_node_feat    ""
+set orig_active_node_feat   ""
 
 if {![is_super_user]} {
 	skip "This test can't be run without being a super user of the cluster"
 }
 
 proc set_node_feature {node_name new_avail_feature new_active_feature} {
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol update node=$node_name AvailableFeatures=$new_avail_feature ActiveFeatures=$new_active_feature
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -47,6 +48,18 @@ proc set_node_feature {node_name new_avail_feature new_active_feature} {
 	}
 }
 
+proc cleanup {} {
+	global node_name orig_avail_node_feat orig_active_node_feat
+	global bin_rm file_in
+
+	# Explicitly reset features, just to be safe
+	if {$node_name ne ""} {
+		set_node_feature $node_name $orig_avail_node_feat $orig_active_node_feat
+	}
+
+	exec $bin_rm -f $file_in
+}
+
 # Identify a node to use
 set match 0
 exec $bin_rm -f $file_in
@@ -65,9 +78,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -82,9 +94,7 @@ set match 0
 spawn $scontrol show node $node_name
 expect {
 	-re "AvailableFeatures=($re_word_str)" {
-		if {![string compare orig_avail_node_feat "(null)"]} {
-			set orig_avail_node_feat ""
-		} else {
+		if [string compare $expect_out(1,string) "(null)"] {
 			set orig_avail_node_feat $expect_out(1,string)
 		}
 		incr match
@@ -96,9 +106,7 @@ expect {
 		exp_continue
 	}
 	-re "ActiveFeatures=($re_word_str)" {
-		if {![string compare orig_avail_node_feat "(null)"]} {
-			set orig_active_node_feat ""
-		} else {
+		if [string compare $expect_out(1,string) "(null)"] {
 			set orig_active_node_feat $expect_out(1,string)
 		}
 		incr match
@@ -110,8 +118,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -145,25 +152,22 @@ expect {
 		exp_continue
 	}
 	-re "Unable to contact" {
-		log_error "Slurm appears to be down"
-		set exit_code 1
+		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$match == 0} {
-	log_error "Could not run job with constraint"
-	set exit_code 1
+	fail "Could not run job with constraint"
 }
 
 # Run "scontrol reconfig" to restore proper features on the node
-reconfigure
+reconfigure -fail
 
 # Now run a job with that constraint and make sure it fails
 set match 0
@@ -175,13 +179,11 @@ expect {
 		exp_continue
 	}
 	-re "Unable to contact" {
-		log_error "Slurm appears to be down"
-		set exit_code 1
+		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -190,12 +192,3 @@ expect {
 if {$match != 1} {
 	fail "Ran job with what should be invalid constraint"
 }
-
-# Explicitly reset features, just to be safe
-set_node_feature $node_name $orig_avail_node_feat $orig_active_node_feat
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test3.18 b/testsuite/expect/test3.18
index 59e591c94f..b28ba92c1b 100755
--- a/testsuite/expect/test3.18
+++ b/testsuite/expect/test3.18
@@ -33,7 +33,6 @@
 source ./globals
 
 set authorized     1
-set exit_code      0
 set file_in        "test$test_id.input"
 
 if {![is_super_user]} {
@@ -54,9 +53,8 @@ expect {
                 exp_continue
         }
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -78,8 +76,7 @@ expect {
                 exp_continue
         }
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -102,8 +99,7 @@ expect {
             exp_continue
         }
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -112,7 +108,3 @@ expect {
 if {$matches != 1} {
 	fail "Node GRES change request not rejected. Configuration of node $host_name is likely left in a bad state"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test3.2 b/testsuite/expect/test3.2
index b24bf5fde1..b795f9bc70 100755
--- a/testsuite/expect/test3.2
+++ b/testsuite/expect/test3.2
@@ -82,8 +82,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -97,8 +96,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -159,8 +157,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -177,8 +174,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -215,8 +211,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -230,8 +225,7 @@ spawn  $scontrol show partition $part_name
 expect {
 
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test3.3 b/testsuite/expect/test3.3
index db947848d6..6b4f1f6809 100755
--- a/testsuite/expect/test3.3
+++ b/testsuite/expect/test3.3
@@ -52,8 +52,7 @@ expect {
                 exp_continue
         }
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -73,8 +72,7 @@ expect {
 		set node_name $expect_out(1,string)
         }
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -108,8 +106,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -136,8 +133,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -174,8 +170,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -197,8 +192,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test3.4 b/testsuite/expect/test3.4
index 94c293c7b6..6ab6d36526 100755
--- a/testsuite/expect/test3.4
+++ b/testsuite/expect/test3.4
@@ -36,6 +36,16 @@ set job_id        0
 set new_prio      1
 set read_priority -1
 
+proc cleanup {} {
+	global job_id
+
+	if {$job_id != 0} {
+		if {[cancel_job $job_id] != 0} {
+			log_error "Unable to cancel job ($job_id)"
+		}
+	}
+}
+
 #
 # Build input script file
 #
@@ -51,9 +61,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -74,8 +83,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -96,8 +104,7 @@ expect {
 		skip "User not authorized to modify jobs"
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -120,8 +127,7 @@ expect {
 		skip "User not authorized to modify jobs"
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -138,8 +144,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -149,9 +154,6 @@ if {$validate_new_priority && ($read_priority != $new_prio)} {
 	fail "scontrol priority change error"
 }
 
-if {[cancel_job $job_id] != 0} {
-	fail "Unable to cancel job ($job_id)"
-}
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test3.5 b/testsuite/expect/test3.5
index 5ea5fac9b8..23c1f1a16f 100755
--- a/testsuite/expect/test3.5
+++ b/testsuite/expect/test3.5
@@ -60,8 +60,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -117,8 +116,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -145,8 +143,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -170,8 +167,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "id not responding"
-		set exit_code 1
+		fail "id not responding"
 	}
 	eof {
 		wait
@@ -180,8 +176,7 @@ expect {
 spawn $scontrol update PartitionName=$part_name AllowGroups=$my_group MaxTime=1
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -195,8 +190,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -240,8 +234,7 @@ if {$timed_out == 1} {
 spawn $scontrol update PartitionName=$part_name AllowGroups=ALL
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -255,8 +248,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -279,8 +271,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -295,8 +286,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -316,8 +306,7 @@ expect {
 		set found 1
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -338,8 +327,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -359,8 +347,7 @@ expect {
 		set exit_code 1
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -375,8 +362,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -394,8 +380,7 @@ if {$found} {
 spawn $scontrol delete PartitionName=$part_name
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -418,8 +403,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test3.6 b/testsuite/expect/test3.6
index ffc77c1510..f7ccec7cdf 100755
--- a/testsuite/expect/test3.6
+++ b/testsuite/expect/test3.6
@@ -58,8 +58,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -77,8 +76,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -112,8 +110,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -142,8 +139,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -170,8 +166,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -191,8 +186,7 @@ if {$hidden == 0} {
 spawn $scontrol delete PartitionName=$part_name
 expect {
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -215,8 +209,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test3.7 b/testsuite/expect/test3.7
index 9b7ebc1c10..1b75841060 100755
--- a/testsuite/expect/test3.7
+++ b/testsuite/expect/test3.7
@@ -40,6 +40,12 @@ set job_id2        0
 set host_name      ""
 set not_supported  0
 
+proc cleanup {} {
+	global bin_rm file_out1 file_out2 file_prog file_prog_sh1 file_prog_sh2
+
+	exec $bin_rm -f $file_out1 $file_out2 $file_prog $file_prog_sh1 $file_prog_sh2
+}
+
 if [param_contains [get_config_param "PreemptMode"] "GANG"] {
 	skip "This test can't be run with gang scheduling"
 }
@@ -63,8 +69,7 @@ proc suspend_job { job_id operation } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -88,8 +93,7 @@ proc check_output { file_name } {
 			exp_continue
 		}
 		timeout {
-			log_error "cat not responding"
-			set exit_code 1
+			fail "cat not responding"
 		}
 		eof {
 			wait
@@ -237,8 +241,6 @@ if {$not_supported == 0} {
 	check_output $file_out2
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_out1 $file_out2 $file_prog $file_prog_sh1 $file_prog_sh2
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code). Failure may be due to use of gang scheduler, a race conditions, or the ProcTrack plugin not identifying the application as part of the job"
 }
diff --git a/testsuite/expect/test3.8 b/testsuite/expect/test3.8
index 71bb27df99..193378ce95 100755
--- a/testsuite/expect/test3.8
+++ b/testsuite/expect/test3.8
@@ -39,6 +39,14 @@ set file_flag_4   "test$test_id.run.4"
 set job_id        0
 set node_cnt 1-4
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+	global file_flag_1 file_flag_2 file_flag_3 file_flag_4
+
+	exec $bin_rm -f $file_in $file_out $file_err
+	exec $bin_rm -f $file_flag_1 $file_flag_2 $file_flag_3 $file_flag_4
+}
+
 if {![is_super_user]} {
 	skip "This test can't be run except as SlurmUser"
 }
@@ -76,9 +84,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -104,8 +111,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -128,8 +134,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -180,9 +185,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -214,8 +218,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -240,9 +243,6 @@ if {[file exists $file_flag_2]} {
 	fail "File $file_flag_2 is found"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-	exec $bin_rm -f $file_flag_1 $file_flag_2 $file_flag_3 $file_flag_4
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test3.9 b/testsuite/expect/test3.9
index 53c0f4ca9e..f56b4f75ad 100755
--- a/testsuite/expect/test3.9
+++ b/testsuite/expect/test3.9
@@ -28,8 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 if {[get_config_param "LaunchType"] ne "launch/slurm"} {
 	skip "This test is only compatible with systems using launch/slurm"
 }
@@ -47,8 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -57,7 +54,3 @@ expect {
 if {$matches != 2} {
 	fail "Unexpected output. Got $matches"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test31.1 b/testsuite/expect/test31.1
index 8a87a2a00d..53a05cfd2c 100755
--- a/testsuite/expect/test31.1
+++ b/testsuite/expect/test31.1
@@ -34,6 +34,9 @@ set make_file        0
 set exit_code        0
 set pcmd_prog        "/opt/cray/nodehealth/default/bin/pcmd"
 
+# Use PID to avoid issues with ps aux killall
+set test_pid         [pid]
+
 if {[get_config_param "SwitchType"] eq "switch/cray"} {
 	set make_file 1
 	if { ![file exists $pcmd_prog] } {
@@ -62,8 +65,8 @@ proc cleanup { } {
 set timeout $max_job_delay
 
 proc change_pro_epi { arg program_name conf_change task_pro } {
-
 	global inc_slurm bin_chmod bin_rm test_dir pro_epi_prog bin_echo test_name bin_pwd re_word_str make_file bin_bash exit_code file_dir bin_ln
+	global bin_sleep
 
 	if {$conf_change == 0} {
 		exec $bin_echo $arg=$test_dir/$pro_epi_prog > $test_dir/$inc_slurm
@@ -71,7 +74,7 @@ proc change_pro_epi { arg program_name conf_change task_pro } {
 
 	set make_ln 0
 	exec $bin_rm -f $test_dir/$program_name
-	spawn $bin_bash -c "$bin_ln -sv /bin/sleep $test_dir/$program_name"
+	spawn $bin_bash -c "$bin_ln -sv $bin_sleep $test_dir/$program_name"
 	expect {
 		-re "$program_name" {
 			set make_ln 1
@@ -106,7 +109,7 @@ proc change_pro_epi { arg program_name conf_change task_pro } {
 }
 
 proc check_file { file_name } {
-	global test_name exit_code file_dir run_host pcmd_prog
+	global exit_code file_dir run_host pcmd_prog
 
 	sleep 1
 
@@ -118,8 +121,7 @@ proc check_file { file_name } {
 			exp_continue
 		}
 		timeout {
-			log_error "find is not responding"
-			set exit_code 1
+			fail "find is not responding"
 		}
 		eof {
 			wait
@@ -135,7 +137,6 @@ proc check_file { file_name } {
 }
 
 proc check_proc {program_name} {
-
 	global bin_ps bin_bash bin_grep exit_code
 
 	set proc_exist 0
@@ -146,8 +147,7 @@ proc check_proc {program_name} {
 			exp_continue
 		}
 		timeout {
-			log_error "Timed out while looking for process"
-			set exit_code 1
+			fail "Timed out while looking for process"
 		}
 		eof {
 			wait
@@ -161,7 +161,6 @@ proc check_proc {program_name} {
 }
 
 proc run_job { file_type program_name conf_change task_pro} {
-
 	global srun run_host make_file exit_code bin_rm bin_printenv bin_sleep test_dir test_name
 
 	# Change the included file to epilog in the slurm.conf
@@ -171,7 +170,7 @@ proc run_job { file_type program_name conf_change task_pro} {
 	$bin_sleep 10
 
 	# Update config file
-	reconfigure
+	reconfigure -fail
 
 	set sub_job 0
 	spawn $srun -t1 -w$run_host $bin_printenv SLURMD_NODENAME
@@ -181,8 +180,7 @@ proc run_job { file_type program_name conf_change task_pro} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun is not responding"
-			set exit_code 1
+			fail "srun is not responding"
 		}
 		eof {
 			wait
@@ -213,7 +211,6 @@ proc run_job { file_type program_name conf_change task_pro} {
 # Copy slurm.conf file
 #
 set config_dir [get_conf_path]
-fail_on_error "Unable to get config path"
 set config_file $config_dir/slurm.conf
 
 save_conf $config_file
@@ -243,9 +240,9 @@ if {$get_name != 1} {
 #
 # Test srun --task-epilog
 #
-change_pro_epi srun-task-epilog srun--task-epilog_$test_name 1 0
+change_pro_epi srun-task-epilog srun--task-epilog_${test_name}_${test_pid} 1 0
 
-reconfigure
+reconfigure -fail
 
 set sub_job 0
 set invalid_node 0
@@ -256,8 +253,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -274,10 +270,10 @@ if {$make_file == 1} {
 
 
 # Check to see if the child process still exist
-check_proc srun--task-epilog_$test_name
+check_proc srun--task-epilog_${test_name}_${test_pid}
 
 # Remove link
-exec $bin_rm -rf $test_dir/srun--task-epilog_$test_name
+exec $bin_rm -rf $test_dir/srun--task-epilog_${test_name}_${test_pid}
 
 #
 # Task Prolog Test
@@ -294,7 +290,7 @@ if {$make_file == 1} {
 	# Test srun --task-prolog
 	change_pro_epi srun-task-prolog srun--task-prolog_$test_name 1 1
 
-	reconfigure
+	reconfigure -fail
 
 	set sub_job 0
 	set sbcast_file      "$file_dir/${test_name}_sbcast"
@@ -312,8 +308,7 @@ if {$make_file == 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "salloc is not responding"
-			set exit_code 1
+			fail "salloc is not responding"
 		}
 		eof {
 			wait
@@ -337,7 +332,7 @@ if {$make_file == 1} {
 	#
 	# Test TaskProlog
 	#
-	run_job taskprolog taskprolog_$test_name 0 1
+	run_job taskprolog taskprolog_${test_name}_${test_pid} 0 1
 
 } else {
 	# Add a line in the slurm.conf file to include the epilogs and prologs
@@ -349,19 +344,19 @@ if {$make_file == 1} {
 #
 # Test Epilog param
 #
-run_job epilog epilog_$test_name 0 0
+run_job epilog epilog_${test_name}_${test_pid} 0 0
 
 #
 # Test TaskEpilog param
 #
-run_job taskepilog taskepilog_$test_name 0 0
+run_job taskepilog taskepilog_${test_name}_${test_pid} 0 0
 
 ###############Prolog Test###############
 
 #
 # Test Prolog param
 #
-run_job prolog prolog_$test_name 0 0
+run_job prolog prolog_${test_name}_${test_pid} 0 0
 
 if {$exit_code} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
diff --git a/testsuite/expect/test31.2 b/testsuite/expect/test31.2
index ee486701d3..86034953c4 100755
--- a/testsuite/expect/test31.2
+++ b/testsuite/expect/test31.2
@@ -30,7 +30,7 @@ source ./globals
 set exit_code       0
 set good_prolog     "test$test_id\_good.sh"
 set bad_prolog      "test$test_id\_bad.sh"
-set test_node       [get_idle_node_in_part]
+set test_node       [lindex [get_nodes_by_state] 0]
 set job_id          0
 set job_list        {}
 set test_script     "test$test_id\.sh"
@@ -56,8 +56,7 @@ proc cleanup { } {
 	spawn $scontrol update node=$test_node state=idle
 	expect {
 		timeout {
-			log_warn "scontrol is not responding"
-			set exit_code 1
+			log_error "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -77,7 +76,6 @@ sleep 20
 
 # Get the location of the slurm.conf file
 set config_dir [get_conf_path]
-fail_on_error "Unable to determine configuration directory"
 set config_file $config_dir/slurm.conf
 
 #
@@ -93,7 +91,7 @@ exec $bin_sed -i {s/nohold_on_prolog_fail//gI; \
 
 # Append Prolog config to the slurm.conf
 exec $bin_echo "Prolog=$cwd/$good_prolog" >> $config_file
-reconfigure
+reconfigure -fail
 
 spawn $sbatch -t1 -N1 -w$test_node --exclusive -o/dev/null $test_script
 expect {
@@ -122,7 +120,7 @@ exec $bin_sed -i {s/^\(Prolog=\)/#\1/gI} $config_file
 
 # Append Prolog config to the slurm.conf
 exec $bin_echo "Prolog=$cwd/$bad_prolog" >> $config_file
-reconfigure
+reconfigure -fail
 
 set job_id 0
 spawn $sbatch -t1 -N1 -w$test_node --exclusive -o/dev/null $test_script
@@ -172,12 +170,10 @@ if {$match == 0} {
 log_info "RESUMING NODE"
 spawn $scontrol update node=$test_node state=RESUME
 
-#Comment out SchedulerParameters
-exec $bin_sed -i {s/^\(SchedulerParameters=\)/#\1/gI} $config_dir/slurm.conf
 #Append SchedulerParameters=nohold_on_prolog_fail to SchedulerParameters
 exec $bin_echo "SchedulerParameters=nohold_on_prolog_fail" \
 	 >> $config_dir/slurm.conf
-reconfigure
+reconfigure -fail
 
 set job_id 0
 spawn $sbatch -t1 -N1 -w$test_node --exclusive -o/dev/null $test_script
diff --git a/testsuite/expect/test31.3 b/testsuite/expect/test31.3
index 945d6016cd..c16c64f74d 100755
--- a/testsuite/expect/test31.3
+++ b/testsuite/expect/test31.3
@@ -31,7 +31,7 @@ set prolog          "test$test_id\_prolog.sh"
 set epilog          "test$test_id\_epilog.sh"
 set prolog_out      "test$test_id\_prolog.out"
 set epilog_out      "test$test_id\_epilog.out"
-set test_node       [get_idle_node_in_part]
+set test_node       [lindex [get_nodes_by_state] 0]
 set job_id          0
 set skipped         ""
 
@@ -40,14 +40,14 @@ proc cleanup { } {
 	global prolog epilog prolog_out epilog_out
 
 	restore_conf $config_dir/slurm.conf
-	exec $bin_rm -f $prolog $epilog $prolog_out $epilog_out
-
 	reconfigure
+	exec $bin_rm -f $prolog $epilog $prolog_out $epilog_out
 }
 
 proc check_prolog { pattern } {
 	global prolog_out exit_code bin_grep
-	set rc [wait_for_command -timeout 5 "$bin_grep" "$pattern $prolog_out" $pattern]
+
+	set rc [wait_for_command_match -timeout 5 "$bin_grep $pattern $prolog_out" $pattern]
 	if { $rc == 0 } {
 		log_info "Prolog: Found '$pattern'"
 	} else {
@@ -58,7 +58,8 @@ proc check_prolog { pattern } {
 
 proc check_epilog { pattern } {
 	global epilog_out exit_code bin_grep
-	set rc [wait_for_command -timeout 5 "$bin_grep" "$pattern $epilog_out" $pattern]
+
+	set rc [wait_for_command_match -timeout 5 "$bin_grep $pattern $epilog_out" $pattern]
 	if { $rc == 0 } {
 		log_info "Epilog: Found '$pattern'"
 	} else {
@@ -69,7 +70,6 @@ proc check_epilog { pattern } {
 
 # Get the location of the slurm.conf file
 set config_dir [get_conf_path]
-fail_on_error "Error getting the config path"
 
 #
 # Copy slurm.conf file
@@ -95,8 +95,7 @@ exec $bin_echo "" >> $config_dir/slurm.conf
 # Append Prolog and Epilog config to the slurm.conf
 exec $bin_echo "Prolog=$cwd/$prolog" >> $config_dir/slurm.conf
 exec $bin_echo "Epilog=$cwd/$epilog" >> $config_dir/slurm.conf
-
-reconfigure
+reconfigure -fail
 
 # Test whether env vars exist in Prolog and Epilog
 log_info "Checking for regular env vars"
@@ -201,4 +200,3 @@ if {$exit_code != 0} {
 if {[llength $skipped]} {
 	skip [join $skipped "\n"]
 }
-
diff --git a/testsuite/expect/test32.1 b/testsuite/expect/test32.1
index 6925cee8ee..164b0a8720 100755
--- a/testsuite/expect/test32.1
+++ b/testsuite/expect/test32.1
@@ -26,8 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
-
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -40,8 +38,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sgather is not responding"
-		set exit_code 1
+		fail "sgather is not responding"
 	}
 	eof {
 		wait
@@ -50,7 +47,3 @@ expect {
 if {$matches != 1} {
 	fail "sgather failed to report usage ($matches != 1)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test32.10 b/testsuite/expect/test32.10
index ecbf4abd9e..441b882ed9 100755
--- a/testsuite/expect/test32.10
+++ b/testsuite/expect/test32.10
@@ -34,6 +34,12 @@ set sgather_tmp   "/tmp/test${test_id}"
 set sgather_out   "test${test_id}_sgather.out"
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -77,8 +83,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -123,8 +128,6 @@ if {$file_cnt != [expr $node_cnt * 2]} {
 	fail "Failed to gather files from all allocated nodes ($file_cnt != [expr $node_cnt * 2])"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test32.11 b/testsuite/expect/test32.11
index 5ae56189b9..82db621078 100755
--- a/testsuite/expect/test32.11
+++ b/testsuite/expect/test32.11
@@ -34,6 +34,12 @@ set sgather_tmp   "/tmp/test${test_id}"
 set sgather_out   "test${test_id}_sgather.out"
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -75,8 +81,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -138,8 +143,6 @@ if {$rm_cnt != $node_cnt} {
 	fail "Failed to remove gathered files from all allocated nodes ($rm_cnt != $node_cnt)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test32.12 b/testsuite/expect/test32.12
index c332503569..16ec1eb0f2 100755
--- a/testsuite/expect/test32.12
+++ b/testsuite/expect/test32.12
@@ -34,6 +34,12 @@ set sgather_tmp   "/tmp/test${test_id}"
 set sgather_out   "test${test_id}_sgather.out"
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -75,8 +81,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -130,8 +135,6 @@ if {$rm_cnt != $node_cnt} {
 	fail "Failed to remove gathered files from all allocated nodes ($rm_cnt != $node_cnt)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test32.2 b/testsuite/expect/test32.2
index 6786ada6e9..1c2d3bdb3f 100755
--- a/testsuite/expect/test32.2
+++ b/testsuite/expect/test32.2
@@ -26,8 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code  0
-
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -44,8 +42,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sgather is not responding"
-		set exit_code 1
+		fail "sgather is not responding"
 	}
 	eof {
 		wait
@@ -54,7 +51,3 @@ expect {
 if {$matches != 2} {
 	fail "sgather did not report the help message ($matches != 2)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test32.3 b/testsuite/expect/test32.3
index 1e33ad08a5..fbe6f13d73 100755
--- a/testsuite/expect/test32.3
+++ b/testsuite/expect/test32.3
@@ -26,8 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code  0
-
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -43,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sgather is not responding"
-		set exit_code 1
+		fail "sgather is not responding"
 	}
 	eof {
 		wait
@@ -53,7 +50,3 @@ expect {
 if {$matches != 1} {
 	fail "sgather did not report the version ($matches != 1)"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test32.4 b/testsuite/expect/test32.4
index 20e7a4c4d0..5d2ca2a624 100755
--- a/testsuite/expect/test32.4
+++ b/testsuite/expect/test32.4
@@ -34,6 +34,12 @@ set sgather_tmp   "/tmp/test${test_id}"
 set sgather_out   "test${test_id}_sgather.out"
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -75,8 +81,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -129,8 +134,6 @@ if {$rm_cnt != $node_cnt} {
 	fail "Failed to remove gathered files from all allocated nodes ($rm_cnt != $node_cnt)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test32.5 b/testsuite/expect/test32.5
index 5feafa6eab..e9472abf95 100755
--- a/testsuite/expect/test32.5
+++ b/testsuite/expect/test32.5
@@ -34,6 +34,12 @@ set sgather_tmp   "/tmp/test${test_id}"
 set sgather_out   "test${test_id}_sgather.out"
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -75,8 +81,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -126,8 +131,6 @@ if {$file_cnt != $node_cnt} {
 	fail "Failed to gather files from all allocated nodes ($file_cnt != $node_cnt)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test32.6 b/testsuite/expect/test32.6
index 05aef114d0..4e2aa67942 100755
--- a/testsuite/expect/test32.6
+++ b/testsuite/expect/test32.6
@@ -34,6 +34,12 @@ set sgather_tmp   "/tmp/test${test_id}"
 set sgather_out   "test${test_id}_sgather.out"
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -75,8 +81,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -130,8 +135,6 @@ if {$rm_cnt == 0} {
 	fail "Failed to remove gathered files from all allocated nodes ($rm_cnt == 0)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test32.7 b/testsuite/expect/test32.7
index 4f38cdb480..df4cfb808a 100755
--- a/testsuite/expect/test32.7
+++ b/testsuite/expect/test32.7
@@ -34,6 +34,12 @@ set sgather_tmp   "/tmp/test${test_id}"
 set sgather_out   "test${test_id}_sgather.out"
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -75,8 +81,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -114,8 +119,6 @@ if {$matches != 2} {
 	fail "Failed to ignore missing files ($matches != 2)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test32.8 b/testsuite/expect/test32.8
index d26f0d42d4..38bdc73ab4 100755
--- a/testsuite/expect/test32.8
+++ b/testsuite/expect/test32.8
@@ -34,6 +34,12 @@ set sgather_tmp   "/tmp/test${test_id}"
 set sgather_out   "test${test_id}_sgather.out"
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -75,8 +81,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -130,8 +135,6 @@ if {$rm_cnt != $node_cnt} {
 	fail "Failed to remove gathered files from all allocated nodes ($rm_cnt != $node_cnt)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test32.9 b/testsuite/expect/test32.9
index 533c0c7e6e..c3bbf24359 100755
--- a/testsuite/expect/test32.9
+++ b/testsuite/expect/test32.9
@@ -34,6 +34,12 @@ set sgather_tmp   "/tmp/test${test_id}"
 set sgather_out   "test${test_id}_sgather.out"
 set exit_code     0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {[file executable $sgather] == 0} {
 	skip "$sgather does not exist"
 }
@@ -77,8 +83,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -121,8 +126,6 @@ if {$matches != [expr $node_cnt * 2]} {
 	fail "Failed to preserve file time ($matches != [expr $node_cnt * 2])"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test33.1 b/testsuite/expect/test33.1
index 99896a5632..0abb17a3cf 100755
--- a/testsuite/expect/test33.1
+++ b/testsuite/expect/test33.1
@@ -39,7 +39,6 @@ source ./globals
 # -- The first line in the testcase is the node list expression to be split
 #    The following lines in the testcase are the expected resulting node lists.
 
-set exit_code   0
 set test_prog   "test$test_id.prog"
 
 if {[get_config_param "FrontendName"] ne "MISSING"} {
@@ -77,8 +76,9 @@ proc run_config { test_config } {
 #
 file delete $test_prog
 
-compile_against_libslurm ${test_prog} 1
-fail_on_error "Cannot compile test program"
+if [compile_against_libslurm -full $test_prog] {
+	fail "Cannot compile test program"
+}
 
 log_user 0
 set cfgcount 0
@@ -187,6 +187,3 @@ if {$cfgok != $cfgcount} {
 } else {
 	file delete $test_prog
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test34.1 b/testsuite/expect/test34.1
index ded4fafc9f..8c060fc5ca 100755
--- a/testsuite/expect/test34.1
+++ b/testsuite/expect/test34.1
@@ -29,9 +29,9 @@ source ./globals
 set exit_code      0
 set part_name_1    "test$test_id\_part1"
 set part_name_2    "test$test_id\_part2"
-set part_1_id      0
+set part_id_1      0
 set job1           "test$test_id\_job1_sc"
-set part_2_id      0
+set part_id_2      0
 set job2           "test$test_id\_job2_sc"
 set job_id         0
 set nodes          ""
@@ -42,7 +42,6 @@ if {[get_config_param "PreemptType"] ne "preempt/partition_prio"} {
 }
 
 proc create_part { part nodes priority pre_type } {
-
 	global sinfo scontrol exit_code
 
 	spawn $scontrol create partitionname=$part nodes=$nodes priority=$priority preemptmode=$pre_type
@@ -51,8 +50,7 @@ proc create_part { part nodes priority pre_type } {
 			skip "User not authorized to run this test"
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -68,8 +66,7 @@ proc create_part { part nodes priority pre_type } {
 			exp_continue
 		}
 		timeout {
-			log_error "sinfo is not responding"
-			set exit_code 1
+			fail "sinfo is not responding"
 		}
 		eof {
 			wait
@@ -85,14 +82,12 @@ proc create_part { part nodes priority pre_type } {
 }
 
 proc mod_part { part pre_type } {
-
 	global sinfo scontrol exit_code
 
 	spawn $scontrol update partitionname=$part preemptmode=$pre_type
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -108,8 +103,7 @@ proc mod_part { part pre_type } {
 			exp_continue
 		}
 		timeout {
-			log_error "sinfo is not responding"
-			set exit_code 1
+			fail "sinfo is not responding"
 		}
 		eof {
 			wait
@@ -122,18 +116,15 @@ proc mod_part { part pre_type } {
 		log_error "scontrol did not create partition $part"
 		set exit_code 1
 	}
-
 }
 
 proc delete_part { part } {
-
 	global sinfo scontrol exit_code
 
 	spawn $scontrol delete partitionname=$part
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -149,13 +140,11 @@ proc delete_part { part } {
 			exp_continue
 		}
 		timeout {
-			log_error "sinfo is not responding"
-			set exit_code 1
+			fail "sinfo is not responding"
 		}
 		eof {
 			wait
 		}
-
 	}
 	log_user 1
 
@@ -163,11 +152,9 @@ proc delete_part { part } {
 		log_error "scontrol did not delete partition $part"
 		set exit_code 1
 	}
-
 }
 
 proc sub_job { part job } {
-
 	global sbatch number exit_code
 
 	set job_id 0
@@ -178,8 +165,7 @@ proc sub_job { part job } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -187,15 +173,19 @@ proc sub_job { part job } {
 	}
 
 	if { $job_id == 0 } {
-		log_error "sbatch did not submit job"
-		cleanup 1
+		fail "sbatch did not submit job"
 	} else {
 		return $job_id
 	}
 }
 
-proc clean_up { rc } {
+if {![is_super_user]} {
+	skip "This test can't be run except as SlurmUser"
+}
+
+proc cleanup {} {
 	global part_id_1 part_id_2 part_name_1 part_name_2
+	global bin_rm job1 job2 file_in
 
 	cancel_job $part_id_1
 	cancel_job $part_id_2
@@ -203,13 +193,7 @@ proc clean_up { rc } {
 	delete_part $part_name_1
 	delete_part $part_name_2
 
-	if {$rc != 0} {
-		fail "Test failed due to previous errors (\$rc = $rc)"
-	}
-}
-
-if {![is_super_user]} {
-	skip "This test can't be run except as SlurmUser"
+	exec $bin_rm -f $job1 $job2 $file_in
 }
 
 make_bash_script $file_in "sleep 5"
@@ -224,8 +208,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not reponding"
-		set exit_code 1
+		fail "sbatch is not reponding"
 	}
 	eof {
 		wait
@@ -250,8 +233,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -271,14 +253,12 @@ create_part $part_name_2 $nodes 2 off
 
 set part_id_1 [sub_job $part_name_1 $job1]
 if { [wait_for_job $part_id_1 "RUNNING"] != 0} {
-	log_error "Job $part_id_1 failed to start"
-	clean_up 1
+	fail "Job $part_id_1 failed to start"
 }
 
 set part_id_2 [sub_job $part_name_2 $job2]
 if { [wait_for_job $part_id_2 "RUNNING"] != 0} {
-	log_error "Job $part_id_1 failed to start"
-	clean_up 1
+	fail "Job $part_id_1 failed to start"
 }
 
 sleep 5
@@ -296,30 +276,25 @@ if [param_contains [get_config_param "PreemptMode"] "GANG"] {
 	mod_part $part_name_1 suspend
 	set part_id_1 [sub_job $part_name_1 $job1]
 	if { [wait_for_job $part_id_1 "RUNNING"] != 0} {
-		log_error "Job $part_id_1 failed to start"
-		clean_up 1
+		fail "Job $part_id_1 failed to start"
 	}
 
 	set part_id_2 [sub_job $part_name_2 $job2]
 	# Wait for the job to start
 	if { [wait_for_job $part_id_2 "RUNNING"] != 0} {
-		log_error "Job $part_id_2 failed to start"
-		clean_up 1
+		fail "Job $part_id_2 failed to start"
 	}
 
 	sleep 5
 	if {![check_job_state $part_id_1 SUSPENDED]} {
-		log_error "Job was not on the desired state"
-		clean_up 1
+		fail "Job was not on the desired state"
 	}
 
 	if { [wait_for_job $part_id_2 "DONE"] != 0} {
-		log_error "Job $part_id_2 failed to complete"
-		clean_up 1
+		fail "Job $part_id_2 failed to complete"
 	}
 	if { [wait_for_job $part_id_1 "RUNNING"] != 0} {
-		log_error "Job $part_id_1 failed to start"
-		clean_up 1
+		fail "Job $part_id_1 failed to start"
 	}
 
 	cancel_job $part_id_1
@@ -332,42 +307,32 @@ log_info "*** TEST PREEMPT REQUEUE ***"
 mod_part $part_name_1 requeue
 set part_id_1 [sub_job $part_name_1 $job1]
 if { [wait_for_job $part_id_1 "RUNNING"] != 0} {
-	log_error "Job $part_id_1 failed to start"
-	clean_up 1
+	fail "Job $part_id_1 failed to start"
 }
 
 set part_id_2 [sub_job $part_name_2 $job2]
 if { [wait_for_job $part_id_2 "RUNNING"] != 0} {
-	log_error "Job $part_id_2 failed to start"
-	clean_up 1
+	fail "Job $part_id_2 failed to start"
 }
 
 sleep 5
 if {![check_job_state $part_id_1 PENDING]} {
-	log_error "Job was not on the desired state"
-	clean_up 1
+	fail "Job was not on the desired state"
 }
 
 # Wait for job 1 to be requeued
 if { [wait_for_job $part_id_2 "DONE"] != 0} {
-	clean_up 0
 	fail "Job $part_id_2 failed to complete"
 }
 if { [wait_for_job $part_id_1 "RUNNING"] != 0} {
-	clean_up 0
 	fail "Job $part_id_1 failed to start"
 }
 
 sleep 5
 if {![check_job_state $part_id_1 RUNNING]} {
-	log_error "Job was not on the desired state"
-	clean_up 1
+	fail "Job was not on the desired state"
 }
 
-clean_up 0
-
-if {$exit_code == 0} {
-	exec $bin_rm $job1 $job2 $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test34.2 b/testsuite/expect/test34.2
index 3daa1450a9..6214296e7b 100755
--- a/testsuite/expect/test34.2
+++ b/testsuite/expect/test34.2
@@ -36,7 +36,7 @@ set qos_2       "test$test_id\_qos2"
 set qos_1_id    0
 set qos_2_id    0
 set file_in     "test$test_id\_sc"
-set nodes       [available_nodes idle]
+set nodes       [llength [get_nodes_by_state]]
 set job_id      0
 
 # job states
@@ -63,8 +63,7 @@ if {$min_job_age < 10} {
 }
 
 proc acct_setup { acct_name qos_name pre_qos pre_mode } {
-
-	global user nodes sacctmgr exit_code
+	global user nodes sacctmgr
 
 	set added 0
 	spawn $sacctmgr -i create qos $qos_name preempt=$pre_qos preemptmode=$pre_mode maxnodes=$nodes
@@ -74,8 +73,7 @@ proc acct_setup { acct_name qos_name pre_qos pre_mode } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -89,8 +87,7 @@ proc acct_setup { acct_name qos_name pre_qos pre_mode } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -104,8 +101,7 @@ proc acct_setup { acct_name qos_name pre_qos pre_mode } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr is not responding"
-			set exit_code 1
+			fail "sacctmgr is not responding"
 		}
 		eof {
 			wait
@@ -118,8 +114,7 @@ proc acct_setup { acct_name qos_name pre_qos pre_mode } {
 }
 
 proc sub_job { acct1 {het_job false} } {
-
-	global nodes file_in sbatch number exit_code
+	global nodes file_in sbatch number
 
 	set job_id 0
 	if { $het_job } {
@@ -134,8 +129,7 @@ proc sub_job { acct1 {het_job false} } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -150,7 +144,6 @@ proc sub_job { acct1 {het_job false} } {
 }
 
 proc cleanup {} {
-
 	global acct_1 acct_2 qos_1 qos_2 qos_1_id qos_2_id sacctmgr exit_code
 	global user bin_rm file_in
 
@@ -174,8 +167,7 @@ proc cleanup {} {
 				exp_continue
 			}
 			timeout {
-				log_error "sacctmgr is not responding"
-				set exit_code 1
+				fail "sacctmgr is not responding"
 			}
 			eof {
 				wait
@@ -189,8 +181,7 @@ proc cleanup {} {
 				exp_continue
 			}
 			timeout {
-				log_error "sacctmgr is not responding"
-				set exit_code 1
+				fail "sacctmgr is not responding"
 			}
 			eof {
 				wait
@@ -202,7 +193,6 @@ proc cleanup {} {
 		log_error "Unable to clean up accounts and qos"
 		set exit_code 1
 	}
-
 }
 
 cleanup
diff --git a/testsuite/expect/test35.1 b/testsuite/expect/test35.1
index ab19b1807b..a13e88ae40 100755
--- a/testsuite/expect/test35.1
+++ b/testsuite/expect/test35.1
@@ -34,6 +34,14 @@ set script_mk   "test$test_id.mk.bash"
 set script_rm   "test$test_id.rm.bash"
 set script_use  "test$test_id.use.bash"
 
+proc cleanup {} {
+	global bin_rm output_mk output_rm output_use
+	global script_mk script_rm script_use
+
+	exec $bin_rm -f $output_mk $output_rm $output_use
+	exec $bin_rm -f $script_mk $script_rm $script_use
+}
+
 proc find_bb_name { fname bb_name } {
 	global bin_cat
 
@@ -51,11 +59,15 @@ proc find_bb_name { fname bb_name } {
 	return $found
 }
 
+if {[get_my_uid] == 0} {
+	skip "This test can't be run as user root"
+}
+
 set bb_types [get_bb_types]
 if {[string first "datawarp" $bb_types] == -1} {
 	skip "This test can only be run with the burst_buffer/datawarp plugin"
 }
-if {[get_config_param "EnablePersistent"] eq "MISSING"} {
+if {![check_bb_persistent]} {
 	skip "This test can only be run if persistent burst_buffers can be created/deleted"
 }
 
@@ -80,8 +92,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -110,8 +121,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -126,8 +136,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -173,8 +182,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -191,9 +199,6 @@ if {$job_id_rm == 0} {
 	fail "Job deleting burst buffer failed to do so"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $output_mk $output_rm $output_use
-	exec $bin_rm -f $script_mk $script_rm $script_use
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test35.2 b/testsuite/expect/test35.2
index 2b66978351..49588d71ad 100755
--- a/testsuite/expect/test35.2
+++ b/testsuite/expect/test35.2
@@ -35,6 +35,14 @@ set output_use  "test$test_id.use.output"
 set script_use  "test$test_id.use.bash"
 set tmp_file    "test$test_id"
 
+proc cleanup {} {
+	global bin_rm input_data output_data
+	global output_use script_use
+
+	exec $bin_rm -f $input_data $output_data
+	exec $bin_rm -f $output_use $script_use
+}
+
 proc find_bb_jobid { fname bb_jobid } {
 	global bin_cat
 
@@ -71,7 +79,9 @@ proc find_bb_data { file_name string_seek } {
 	return $found
 }
 
-stop_root_user
+if {[get_my_uid] == 0} {
+	skip "This test can't be run as user root"
+}
 
 set bb_types [get_bb_types]
 if {[string first "datawarp" $bb_types] == -1} {
@@ -82,7 +92,7 @@ set cwd [$bin_pwd]
 exec $bin_rm -f $input_data $output_data $output_use
 exec $bin_echo $data_in >$cwd/$input_data
 
-if {[get_config_param "EmulateCray"] ne "MISSING"} {
+if [check_bb_emulate] {
 make_bash_script $script_use "#DW jobdw type=scratch capacity=1GiB access_mode=striped,private type=scratch
 #DW stage_in type=file source=$cwd/$input_data destination=\$DW_JOB_STRIPED/$tmp_file
 #DW stage_out type=file destination=$cwd/$output_data source=\$DW_JOB_STRIPED/$tmp_file
@@ -108,8 +118,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -147,8 +156,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -162,9 +170,6 @@ if {[find_bb_data $output_data $data_out] == 0} {
 	fail "Job output burst buffer data not correct"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $input_data $output_data
-	exec $bin_rm -f $output_use $script_use
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test35.3 b/testsuite/expect/test35.3
index 20385d3814..6eb084aaa6 100755
--- a/testsuite/expect/test35.3
+++ b/testsuite/expect/test35.3
@@ -36,6 +36,12 @@ set output_use  "test$test_id-%A_%a.output"
 set script_use  "test$test_id.use.bash"
 set tmp_file    "test$test_id"
 
+proc cleanup {} {
+	global bin_rm input_data output_data script_use
+
+	exec $bin_rm -f $input_data $output_data $script_use
+}
+
 proc find_bb_jobid { fname bb_jobid } {
 	global bin_cat
 
@@ -72,7 +78,9 @@ proc find_bb_data { file_name string_seek } {
 	return $found
 }
 
-stop_root_user
+if {[get_my_uid] == 0} {
+	skip "This test can't be run as user root"
+}
 
 set bb_types [get_bb_types]
 if {[string first "datawarp" $bb_types] == -1} {
@@ -83,7 +91,7 @@ set cwd [$bin_pwd]
 exec $bin_rm -f $input_data $output_data
 exec $bin_echo $data_in >$cwd/$input_data
 
-if {[get_config_param "EmulateCray"] ne "MISSING"} {
+if [check_bb_emulate] {
 make_bash_script $script_use "#DW jobdw type=scratch capacity=1GiB access_mode=striped,private type=scratch
 #DW stage_in type=file source=$cwd/$input_data destination=\$DW_JOB_STRIPED/$tmp_file
 #DW stage_out type=file destination=$cwd/$output_data source=\$DW_JOB_STRIPED/$tmp_file
@@ -109,8 +117,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -159,8 +166,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -170,8 +176,6 @@ if {$found != 0} {
 	fail "Job burst buffer not removed"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $input_data $output_data $script_use
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test35.4 b/testsuite/expect/test35.4
index 4a8999a7f1..3a30f9bbf4 100755
--- a/testsuite/expect/test35.4
+++ b/testsuite/expect/test35.4
@@ -32,6 +32,12 @@ set script_mk   "test$test_id.mk.bash"
 set script_rm   "test$test_id.rm.bash"
 set script_use  "test$test_id.use.bash"
 
+proc cleanup {} {
+	global bin_rm output_use script_mk script_rm script_use
+
+	exec $bin_rm -f $output_use $script_mk $script_rm $script_use
+}
+
 proc find_bb_name { fname bb_name } {
 	global bin_cat
 
@@ -49,11 +55,15 @@ proc find_bb_name { fname bb_name } {
 	return $found
 }
 
+if {[get_my_uid] == 0} {
+	skip "This test can't be run as user root"
+}
+
 set bb_types [get_bb_types]
 if {[string first "datawarp" $bb_types] == -1} {
 	skip "This test can only be run with the burst_buffer/datawarp plugin"
 }
-if {[get_config_param "EnablePersistent"] eq "MISSING"} {
+if {![check_bb_persistent]} {
 	skip "This test can only be run if persistent burst_buffers can be created/deleted"
 }
 
@@ -78,8 +88,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -108,8 +117,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -124,8 +132,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -166,8 +173,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -180,9 +186,6 @@ if {$job_id_rm == 0} {
 	fail "Job did not complete"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $output_use $script_mk $script_rm $script_use
-}
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test35.5 b/testsuite/expect/test35.5
index 2483fba239..386e8f9a9d 100755
--- a/testsuite/expect/test35.5
+++ b/testsuite/expect/test35.5
@@ -47,8 +47,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -68,8 +67,7 @@ if {$fail == 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -97,8 +95,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -121,8 +118,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test35.6 b/testsuite/expect/test35.6
index 7fabedff8d..02faa875aa 100755
--- a/testsuite/expect/test35.6
+++ b/testsuite/expect/test35.6
@@ -32,7 +32,17 @@ set output_parent  "test$test_id.parent.output"
 set script_child   "test$test_id.child.bash"
 set script_parent  "test$test_id.parent.bash"
 
-stop_root_user
+proc cleanup {} {
+	global bin_rm script_child script_parent
+	global output_child output_parent
+
+	exec $bin_rm -f $script_child $script_parent
+	exec $bin_rm -f $output_child $output_parent
+}
+
+if {[get_my_uid] == 0} {
+	skip "This test can't be run as user root"
+}
 
 set bb_types [get_bb_types]
 if {[string first "datawarp" $bb_types] == -1} {
@@ -56,8 +66,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -97,9 +106,6 @@ if {$found == 0} {
 	fail "Dependent job not completed"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $script_child $script_parent
-	exec $bin_rm -f $output_child $output_parent
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test36.1 b/testsuite/expect/test36.1
index 907951c3c6..a4efcc3c99 100755
--- a/testsuite/expect/test36.1
+++ b/testsuite/expect/test36.1
@@ -33,7 +33,7 @@ if {[file executable $lsid] == 0} {
 }
 
 set cluster_name [get_config_param "ClusterName"]
-set control_machine [get_control_machine]
+regsub {\(.*} [get_config_param {SlurmctldHost[0]}] {} control_machine
 set lsid_cluster_name ""
 set lsid_control_machine ""
 set cluster_name_ok 0
@@ -50,8 +50,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "lsid not responding"
-		set exit_code 1
+		fail "lsid not responding"
 	}
 	eof {
 		wait
@@ -69,5 +68,5 @@ if {[string compare $control_machine $lsid_control_machine]} {
 }
 
 if {$exit_code} {
-	fail "Test failed due to previous errors"
+	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test36.2 b/testsuite/expect/test36.2
index b25002c1be..8c7e61ee4e 100755
--- a/testsuite/expect/test36.2
+++ b/testsuite/expect/test36.2
@@ -28,7 +28,6 @@ source ./globals
 
 set file_in     "test$test_id.input"
 set job_id      0
-set exit_code   0
 
 if {[file executable $sbatch] == 0} {
 	skip "$sbatch does not exist"
diff --git a/testsuite/expect/test36.3 b/testsuite/expect/test36.3
index 9b90f20a10..7d293ae445 100755
--- a/testsuite/expect/test36.3
+++ b/testsuite/expect/test36.3
@@ -30,6 +30,12 @@ set file_in     "test$test_id.input"
 set job_id      0
 set exit_code   0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {[file executable $sbatch] == 0} {
 	skip "$sbatch does not exist"
 }
@@ -53,22 +59,20 @@ make_bash_script $file_in "
 set job_submitted 0
 spawn $sbatch -N1 -o /dev/null $file_in
 expect {
-        -re "Submitted batch job ($number)" {
-                set job_id $expect_out(1,string)
+	-re "Submitted batch job ($number)" {
+		set job_id $expect_out(1,string)
 		set job_submitted 1
-                exp_continue
-        }
-        timeout {
-                log_error "sbatch not responding"
-                set exit_code 1
-                exp_continue
-        }
-        eof {
-                wait
-        }
+		exp_continue
+	}
+	timeout {
+		fail "sbatch not responding"
+	}
+	eof {
+		wait
+	}
 }
 if { $job_id == 0 } {
-        fail "Failed to submit job"
+	fail "Failed to submit job"
 }
 
 if {$job_submitted == 1} {
@@ -100,26 +104,25 @@ if {$job_sent_kill == 1} {
 	set state_match 0
 	set cycle_count 8
 	for {set inx 0} {$inx < $cycle_count} {incr inx} {
-        	spawn $scontrol show job $job_id
-        	expect {
-        	        -re "JobState=CANCELLED" {
-        	                incr state_match
+		spawn $scontrol show job $job_id
+		expect {
+		        -re "JobState=CANCELLED" {
+		                incr state_match
 				set exit_code 0
 				break
-        	        }
+			}
 			-re "JobState=" {
 				sleep 2
 				set exit_code 1
 				exp_continue
 			}
-        	        timeout {
-        	                log_error "scontrol not responding"
-        	                set exit_code 1
-        	        }
-        	        eof {
-        	                wait
-        	        }
-        	}
+			timeout {
+				fail "scontrol not responding"
+			}
+			eof {
+				wait
+			}
+		}
 	}
 	if {$exit_code == 1} {
 		if {$cycle_count == 8} {
@@ -135,8 +138,6 @@ if {$state_match != 1} {
 	fail "Job should be CANCELLED, but is not"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test36.4 b/testsuite/expect/test36.4
index 274fba07ba..74b5f45ce1 100755
--- a/testsuite/expect/test36.4
+++ b/testsuite/expect/test36.4
@@ -32,6 +32,12 @@ set file_err	"test$test_id.error"
 set file_in	"test$test_id.input"
 set file_out	"test$test_id.output"
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 if {[file executable $bsub] == 0} {
 	skip "$bsub not found"
 }
@@ -50,8 +56,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "bsub not responding"
-		set exit_code 1
+		fail "bsub not responding"
 	}
 	eof {
 		wait
@@ -101,8 +106,6 @@ if {$matches != 1} {
 	fail "Unexpected bsub error file contents"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test37.1 b/testsuite/expect/test37.1
index 12de9d15d0..f5c7cc4a5e 100755
--- a/testsuite/expect/test37.1
+++ b/testsuite/expect/test37.1
@@ -28,9 +28,7 @@
 source ./globals
 source ./globals_accounting
 
-set test_id_2   "37_1"
-set exit_code   0
-
+set test_id_2       "37_1"
 set max_federations 64
 
 # Test Clusters
@@ -123,22 +121,19 @@ proc delete_federations { names } {
 }
 
 proc cleanup { } {
-	global tc1 tc2 tc3 tc4 tc5 fed1 fed2 fed3 exit_code test_id_2 max_federations
+	global tc1 tc2 tc3 tc4 tc5 fed1 fed2 fed3 test_id_2 max_federations
 
 	set tmp_clusters ""
 	for {set i 0} {$i <= $max_federations} {incr i} {
 		append  tmp_clusters "max${i}_$test_id_2,"
 	}
 
-	set exit_code [expr $exit_code + [delete_clusters "$tc1,$tc2,$tc3,$tc4,$tc5,${tmp_clusters}"]]
-	set exit_code [expr $exit_code + [delete_federations "$fed1,$fed2,$fed3"]]
-}
-
-proc end_it { exit_code } {
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+	if [delete_clusters "$tc1,$tc2,$tc3,$tc4,$tc5,${tmp_clusters}"] {
+		log_error "Unable to delete clusters ($tc1,$tc2,$tc3,$tc4,$tc5,${tmp_clusters})"
+	}
+	if [delete_federations "$fed1,$fed2,$fed3"] {
+		log_error "Unable to delete federations ($fed1,$fed2,$fed3)"
 	}
-	pass
 }
 
 #
@@ -147,10 +142,6 @@ proc end_it { exit_code } {
 set nothing 0
 set matches 0
 
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
-
 ######MAIN######
 #####################################
 # TEST: add federation with non-existant cluster(s)
@@ -163,17 +154,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches == 0} {
-	log_error "Adding invalid federation failed unpexectedly"
-	end_it 1
+if {$matches == 0} {
+	fail "Adding invalid federation failed unexpectedly"
 }
 
 set matches 0
@@ -188,17 +177,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Adding invalid federation failed unpexectedly"
-	end_it 1
+if {$matches != 2} {
+	fail "Adding invalid federation failed unexpectedly"
 }
 
 #####################################
@@ -212,17 +199,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 1} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 1} {
+	fail "Unexpected error"
 }
 
 #####################################
@@ -240,17 +225,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Adding federation failed unpexectedly"
-	end_it 1
+if {$matches != 2} {
+	fail "Adding federation failed unexpectedly"
 }
 
 set matches 0
@@ -265,17 +248,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Adding federation failed unpexectedly. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Adding federation failed unexpectedly. Got $matches"
 }
 
 #####################################
@@ -289,17 +270,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 1} {
-	log_error "Adding federation failed unpexectedly"
-	end_it 1
+if {$matches != 1} {
+	fail "Adding federation failed unexpectedly"
 }
 
 #####################################
@@ -317,17 +296,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Adding federation failed unpexectedly"
-	end_it 1
+if {$matches != 2} {
+	fail "Adding federation failed unexpectedly"
 }
 
 set matches 0
@@ -346,17 +323,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 3} {
-	log_error "Adding federation failed unpexectedly"
-	end_it 1
+if {$matches != 3} {
+	fail "Adding federation failed unexpectedly"
 }
 
 set matches 0
@@ -375,17 +350,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Adding federation failed unpexectedly"
-	end_it 1
+if {$matches != 2} {
+	fail "Adding federation failed unexpectedly"
 }
 
 #####################################
@@ -416,17 +389,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error"
 }
 
 #####################################
@@ -456,17 +427,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error"
 }
 
 set matches 0
@@ -489,17 +458,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error"
 }
 
 
@@ -524,17 +491,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error"
 }
 
 set matches 0
@@ -557,17 +522,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error"
 }
 
 # TEST tree option - shows one federation line per federation.
@@ -599,17 +562,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 6} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 6} {
+	fail "Unexpected error"
 }
 
 
@@ -624,17 +585,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 1} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 1} {
+	fail "Unexpected error"
 }
 
 #####################################
@@ -648,17 +607,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 1} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 1} {
+	fail "Unexpected error"
 }
 
 set matches 0
@@ -669,17 +626,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 1} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 1} {
+	fail "Unexpected error"
 }
 
 #####################################
@@ -709,17 +664,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error"
 }
 
 set matches 0
@@ -742,17 +695,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error"
 }
 
 set matches 0
@@ -775,17 +726,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error"
 }
 
 set matches 0
@@ -808,17 +757,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error"
 }
 
 ######################################
@@ -848,17 +795,15 @@ if {$exit_code || $matches != 4} {
 #		exp_continue
 #	}
 #	timeout {
-#		log_error "sacctmgr add not responding"
 #		slow_kill $my_pid
-#		set exit_code 1
+#		fail "sacctmgr add not responding"
 #	}
 #	eof {
 #		wait
 #	}
 #}
-#if {$exit_code || $matches != 5} {
-#	log_error "Unexpected error"
-#	end_it 1
+#if {$matches != 5} {
+#	fail "Unexpected error"
 #}
 #
 #set matches 0
@@ -881,17 +826,15 @@ if {$exit_code || $matches != 4} {
 #		exp_continue
 #	}
 #	timeout {
-#		log_error "sacctmgr add not responding"
 #		slow_kill $my_pid
-#		set exit_code 1
+#		fail "sacctmgr add not responding"
 #	}
 #	eof {
 #		wait
 #	}
 #}
-#if {$exit_code || $matches != 4} {
-#	log_error "Unexpected error"
-#	end_it 1
+#if {$matches != 4} {
+#	fail "Unexpected error"
 #}
 #
 #set matches 0
@@ -922,17 +865,15 @@ if {$exit_code || $matches != 4} {
 #		exp_continue
 #	}
 #	timeout {
-#		log_error "sacctmgr add not responding"
 #		slow_kill $my_pid
-#		set exit_code 1
+#		fail "sacctmgr add not responding"
 #	}
 #	eof {
 #		wait
 #	}
 #}
-#if {$exit_code || $matches != 6} {
-#	log_error "Unexpected error"
-#	end_it 1
+#if {$matches != 6} {
+#	fail "Unexpected error"
 #}
 #
 ######################################
@@ -962,17 +903,15 @@ if {$exit_code || $matches != 4} {
 #		exp_continue
 #	}
 #	timeout {
-#		log_error "sacctmgr add not responding"
 #		slow_kill $my_pid
-#		set exit_code 1
+#		fail "sacctmgr add not responding"
 #	}
 #	eof {
 #		wait
 #	}
 #}
-#if {$exit_code || $matches != 5} {
-#	log_error "Unexpected error"
-#	end_it 1
+#if {$matches != 5} {
+#	fail "Unexpected error"
 #}
 #
 ## Verify that LLC is removed and that only the federations are listed since no
@@ -993,17 +932,15 @@ if {$exit_code || $matches != 4} {
 #		exp_continue
 #	}
 #	timeout {
-#		log_error "sacctmgr add not responding"
 #		slow_kill $my_pid
-#		set exit_code 1
+#		fail "sacctmgr add not responding"
 #	}
 #	eof {
 #		wait
 #	}
 #}
-#if {$exit_code || $matches != 3} {
-#	log_error "Unexpected error"
-#	end_it 1
+#if {$matches != 3} {
+#	fail "Unexpected error"
 #}
 
 #####################################
@@ -1034,17 +971,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error"
 }
 
 set matches 0
@@ -1067,17 +1002,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error"
 }
 
 # move tc1 into whole.
@@ -1105,17 +1038,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error"
 }
 
 set matches 0
@@ -1138,17 +1069,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error"
 }
 
 # move tc2 back to fed2 and get new id -- 3.
@@ -1176,17 +1105,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error"
 }
 
 set matches 0
@@ -1209,17 +1136,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error"
 }
 
 
@@ -1246,17 +1171,15 @@ expect {
 		send "y"
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Adding invalid federation failed unpexectedly"
-	end_it 1
+if {$matches != 4} {
+	fail "Adding invalid federation failed unexpectedly"
 }
 
 set matches 0
@@ -1290,9 +1213,8 @@ expect {
 		send "y"
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -1300,17 +1222,15 @@ expect {
 }
 expect {
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 7} {
-	log_error "Adding invalid federation failed unpexectedly"
-	end_it 1
+if {$matches != 7} {
+	fail "Adding invalid federation failed unexpectedly"
 }
 
 set matches 0
@@ -1337,17 +1257,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error"
 }
 
 #####################################
@@ -1373,17 +1291,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -1398,17 +1314,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 #####################################
@@ -1430,17 +1344,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 3} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 3} {
+	fail "Unexpected error. Got $matches"
 }
 
 
@@ -1460,17 +1372,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 # New clusters should have fed_id=0, federation="", fed_state=NA
@@ -1486,17 +1396,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 # Test adding cluster to federation sets state to ACTIVE
@@ -1520,17 +1428,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -1545,17 +1451,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 
@@ -1565,9 +1469,8 @@ set matches 0
 set my_pid [spawn $sacctmgr -i modify cluster $tc4 set fedstate=DRAIN]
 expect {
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -1585,17 +1488,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -1610,17 +1511,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 #same thing for modifying the federaiton.
@@ -1636,17 +1535,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -1661,17 +1558,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 # changing from one federation to another should set the state to active
@@ -1699,17 +1594,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -1724,17 +1617,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 
@@ -1742,9 +1633,8 @@ if {$exit_code || $matches != 2} {
 set my_pid [spawn $sacctmgr -i modify cluster $tc4 set fedstate=DRAIN]
 expect {
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -1775,17 +1665,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -1800,17 +1688,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 # Test setting state to INACTIVE
@@ -1834,17 +1720,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -1859,17 +1743,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 # Test invalid state
@@ -1881,17 +1763,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 1} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 1} {
+	fail "Unexpected error. Got $matches"
 }
 
 #####################################
@@ -1905,9 +1785,8 @@ if {$exit_code || $matches != 1} {
 set my_pid [spawn $sacctmgr -i modify cluster $tc1 $tc2 $tc3 set federation=]
 expect {
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -1938,17 +1817,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -1967,17 +1844,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 3} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 3} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2008,17 +1883,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 6} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 6} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2037,17 +1910,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 3} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 3} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2070,17 +1941,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2100,17 +1969,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2137,17 +2004,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2165,17 +2030,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2202,17 +2065,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2227,17 +2088,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 #####################################
@@ -2251,17 +2110,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 1} {
-	log_error "Failed testing mod with + and ="
-	end_it 1
+if {$matches != 1} {
+	fail "Failed testing mod with + and ="
 }
 
 set matches 0
@@ -2272,17 +2129,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 1} {
-	log_error "Failed testing mod with - and ="
-	end_it 1
+if {$matches != 1} {
+	fail "Failed testing mod with - and ="
 }
 
 
@@ -2317,17 +2172,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 6} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 6} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2358,17 +2211,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 6} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 6} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2383,17 +2234,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 # Verify clusters fed_id=0, federation="", fed_state=NA after being removed from
@@ -2410,17 +2259,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 
@@ -2430,9 +2277,8 @@ if {$exit_code || $matches != 4} {
 set my_pid [spawn $sacctmgr -i delete federation $fed2 $fed3]
 expect {
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -2463,17 +2309,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Adding federation with clusters failed. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Adding federation with clusters failed. Got $matches"
 }
 
 # add second cluster to make sure selectin only on federation
@@ -2501,17 +2345,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Adding federation with clusters failed. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Adding federation with clusters failed. Got $matches"
 }
 
 set matches 0
@@ -2530,17 +2372,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 3} {
-	log_error "Deleting clusters with federation=. Got $matches"
-	end_it 1
+if {$matches != 3} {
+	fail "Deleting clusters with federation=. Got $matches"
 }
 
 # add back clusters back to federation to verify both federation clusters are
@@ -2569,17 +2409,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2606,17 +2444,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr delete cluster not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr delete cluster not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Deleting clusters with federation=. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Deleting clusters with federation=. Got $matches"
 }
 
 
@@ -2627,9 +2463,8 @@ if {$exit_code || $matches != 5} {
 set my_pid [spawn $sacctmgr -i modify federation $fed1 set clusters=]
 expect {
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
@@ -2664,17 +2499,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 66} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 66} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2702,17 +2535,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2731,17 +2562,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2760,17 +2589,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 3} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 3} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2785,17 +2612,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != $max_federations} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != $max_federations} {
+	fail "Unexpected error. Got $matches"
 }
 
 #####################################
@@ -2811,17 +2636,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches } {
-	log_error "Found cluster still on federation when it should have been deleted. Got $matches"
-	end_it 1
+if {$matches } {
+	fail "Found cluster still on federation when it should have been deleted. Got $matches"
 }
 
 
@@ -2838,17 +2661,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches } {
-	log_error "Found federation when it should have been deleted. Got $matches"
-	end_it 1
+if {$matches } {
+	fail "Found federation when it should have been deleted. Got $matches"
 }
 
 set matches 0
@@ -2859,17 +2680,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches } {
-	log_error "Found federation on cluster when it was deleted. Got $mattches"
-	end_it 1
+if {$matches } {
+	fail "Found federation on cluster when it was deleted. Got $mattches"
 }
 
 
@@ -2891,17 +2710,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != $max_federations} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != $max_federations} {
+	fail "Unexpected error. Got $matches"
 }
 
 
@@ -2932,18 +2749,17 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error. Got $matches"
 }
+
 set matches 0
 set my_pid [spawn $sacctmgr show cluster $tc5 format="cluster%20,features%20"]
 expect {
@@ -2956,17 +2772,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -2993,18 +2807,17 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error. Got $matches"
 }
+
 set matches 0
 set my_pid [spawn $sacctmgr show cluster $tc5 format="cluster%20,features%20"]
 expect {
@@ -3017,17 +2830,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -3050,18 +2861,17 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
+
 set matches 0
 set my_pid [spawn $sacctmgr show cluster $tc5 format="cluster%20,features%20"]
 expect {
@@ -3074,17 +2884,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -3107,18 +2915,17 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
+
 set matches 0
 set my_pid [spawn $sacctmgr show cluster $tc5 format="cluster%20,features%20"]
 expect {
@@ -3131,17 +2938,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -3168,18 +2973,17 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 5} {
+	fail "Unexpected error. Got $matches"
 }
+
 set matches 0
 set my_pid [spawn $sacctmgr show cluster $tc5 format="cluster%20,features%20"]
 expect {
@@ -3192,17 +2996,13 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 2} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 2} {
+	fail "Unexpected error. Got $matches"
 }
-
-end_it 0
diff --git a/testsuite/expect/test37.10 b/testsuite/expect/test37.10
index ea4e36ad94..4d07538f0f 100755
--- a/testsuite/expect/test37.10
+++ b/testsuite/expect/test37.10
@@ -1,7 +1,6 @@
 #!/usr/bin/env expect
 ############################################################################
 # Purpose: Federated job cancellations
-
 # Reqs:    1. Using slurmdbd accounting storage type and is up
 #          2. fed_slurm_base is defined in globals.local - set to directory that
 #          has access to each federation configure (fedc1, fedc2, fedc3).
@@ -41,7 +40,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code    0
 set fed_name     "feda"
 set user_name    ""
 set srun_job_cnt 0
@@ -123,16 +121,14 @@ proc sbatch { args } {
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure"
-		end_it 1
+		fail "batch submit failure"
 	}
 	return $job_id
 }
@@ -155,8 +151,7 @@ proc squeue { options regex } {
 		}
 	}
 	if {$matches != 1} {
-		log_error "unexpected error in squeue. expected $regex"
-		end_it 1
+		fail "Unexpected error in squeue. expected $regex"
 	}
 }
 
@@ -196,14 +191,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id my_squeue
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 #start test
 
 if {![check_federation_setup]} {
@@ -218,18 +205,16 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "failed to setup federation"
 }
 
 # get number of nodes per cluster
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state idle,alloc,comp]]
 
 log_info "################################################################"
 log_info "Setup cluster features"
@@ -255,17 +240,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -288,17 +271,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -322,17 +303,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 make_bash_script $file_in "sleep 900"
@@ -542,6 +521,3 @@ wait_for_fed_job $ji3 DONE $fedc1
 set regex [mod_regex $regs $regex]
 
 squeue " -M$fedc1,$fedc2,$fedc3 " $regex
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test37.11 b/testsuite/expect/test37.11
index 082c6b274e..46b7845477 100755
--- a/testsuite/expect/test37.11
+++ b/testsuite/expect/test37.11
@@ -41,7 +41,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code   0
 set fed_name    "feda"
 set user_name   ""
 set srun_job_cnt 0
@@ -169,7 +168,7 @@ if {[setup_federation $fed_name]} {
 }
 
 # get number of nodes per cluster
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state idle,alloc,comp]]
 
 log_info "################################################################"
 log_info "Setup cluster features"
@@ -195,15 +194,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
+if {$matches != 4} {
 	fail "Unexpected error. Got $matches"
 }
 
@@ -227,15 +225,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
+if {$matches != 4} {
 	fail "Unexpected error. Got $matches"
 }
 
@@ -260,15 +257,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
+if {$matches != 4} {
 	fail "Unexpected error. Got $matches"
 }
 
diff --git a/testsuite/expect/test37.12 b/testsuite/expect/test37.12
index a94ea23d58..10125c5629 100755
--- a/testsuite/expect/test37.12
+++ b/testsuite/expect/test37.12
@@ -41,7 +41,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code   0
 set fed_name    "feda"
 set user_name   ""
 set srun_job_cnt 0
@@ -90,16 +89,14 @@ proc sbatch_to { options regex } {
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure: expected $regex"
-		end_it 1
+		fail "Batch submit failure: expected $regex"
 	}
 
 	return $job_id
@@ -122,16 +119,14 @@ proc srun { options regex } {
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "srun not responding"
-			end_it 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "srun failure: expected $regex"
-		end_it 1
+		fail "srun failure: expected $regex"
 	}
 	return $job_id
 
@@ -160,15 +155,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id my_squeue
-	cleanup
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 #start test
 
 if {![check_federation_setup]} {
@@ -183,18 +169,16 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 
 # get number of nodes per cluster
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state idle,alloc,comp]]
 
 log_info "################################################################"
 log_info "Setup cluster features"
@@ -220,17 +204,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error: Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error: Got $matches"
 }
 
 set matches 0
@@ -253,17 +235,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -286,17 +266,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 make_bash_script $file_in2 "sleep 900"
@@ -349,8 +327,7 @@ sbatch_to "--test-only -M$f2,$f3" [build_regex $f2]
 set pend_job [sbatch_to "-M$f1 -t50" $reg_default]
 set pend_cluster [wait_for_fed_job $pend_job PENDING $f1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 set regex [build_regex $f2]
@@ -362,8 +339,7 @@ sbatch_to "--test-only -M$f2,$f3" [build_regex $f2]
 set pend_job [sbatch_to "-M$f2 -t50" $reg_default]
 set pend_cluster [wait_for_fed_job $pend_job PENDING $f2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 set regex [build_regex $f3]
@@ -376,8 +352,7 @@ sbatch_to "--test-only -M$f2,$f3" [build_regex $f3]
 set pend_job [sbatch_to "-M$f3 -t50" $reg_default]
 set pend_cluster [wait_for_fed_job $pend_job PENDING $f3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 set regex [build_regex $f1]
@@ -394,16 +369,14 @@ expect {
 		incr matches
 	}
 	timeout {
-		log_error "sbatch not responding"
-		end_it 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "batch submit failure"
-	end_it 1
+	fail "Batch submit failure"
 }
 
 
@@ -455,8 +428,7 @@ srun "--test-only -M$f2,$f3" [build_regex $f2]
 set pend_job [srun "-M$f1 -t50"  $reg_default]
 set pend_cluster [wait_for_fed_job $pend_job PENDING $f1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 set regex [build_regex $f2]
@@ -468,8 +440,7 @@ srun "--test-only -M$f2,$f3" [build_regex $f2]
 set pend_job [srun "-M$f2 -t50"  $reg_default]
 set pend_cluster [wait_for_fed_job $pend_job PENDING $f2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 set regex [build_regex $f3]
@@ -482,8 +453,7 @@ srun "--test-only -M$f2,$f3" [build_regex $f3]
 set pend_job [srun "-M$f3 -t50"  $reg_default]
 set pend_cluster [wait_for_fed_job $pend_job PENDING $f3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 set regex [build_regex $f1]
@@ -499,19 +469,12 @@ expect {
 		incr matches
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "srun failure"
-	end_it 1
+	fail "srun failure"
 }
-
-
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test37.13 b/testsuite/expect/test37.13
index df8354ebbf..cc1a940e1f 100755
--- a/testsuite/expect/test37.13
+++ b/testsuite/expect/test37.13
@@ -41,7 +41,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code    0
 set fed_name     "feda"
 set user_name    ""
 set srun_job_cnt 0
@@ -81,16 +80,14 @@ proc sbatch { options regex } {
 			}
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure: expected $regex"
-		end_it 1
+		fail "batch submit failure: expected $regex"
 	}
 
 	return $job_id
@@ -111,8 +108,7 @@ proc squeue { regex } {
 		}
 	}
 	if {$matches != 1} {
-		log_error "unexpected error in squeue. expected $regex"
-		end_it 1
+		fail "Unexpected error in squeue. expected $regex"
 	}
 }
 
@@ -138,14 +134,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id my_squeue
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 #start test
 
 if {![check_federation_setup]} {
@@ -160,14 +148,12 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 
 log_info "################################################################"
@@ -194,17 +180,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -227,17 +211,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -260,17 +242,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 log_info "################################################################"
@@ -328,6 +308,3 @@ set regf3 "CLUSTER: $fedc3$eol\\s*"
 squeue "$regf1$regf2$regf3"
 
 sbatch "--cluster-constraint=fa -M$fedc2" "sbatch: error: Batch.+"
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test37.14 b/testsuite/expect/test37.14
index 3df647adb7..15fd6feb27 100755
--- a/testsuite/expect/test37.14
+++ b/testsuite/expect/test37.14
@@ -41,7 +41,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code   0
 set fed_name    "feda"
 set user_name   ""
 set srun_job_cnt 0
@@ -81,16 +80,14 @@ proc srun { regex } {
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "srun not responding"
-			end_it 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "srun failure: expected $regex"
-		end_it 1
+		fail "srun failure: expected $regex"
 	}
 	return $job_id
 }
@@ -111,16 +108,14 @@ proc sbatch { options } {
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure: expected $regex"
-		end_it 1
+		fail "Batch submit failure: expected $regex"
 	}
 
 	sleep 2
@@ -143,8 +138,7 @@ proc squeue { regex } {
 		}
 	}
 	if {$matches != 1} {
-		log_error "unexpected error in squeue. expected $regex"
-		end_it 1
+		fail "Unexpected error in squeue. expected $regex"
 	}
 }
 
@@ -163,16 +157,14 @@ proc scontrol { fed id regex } {
 				incr matches
 			}
 			timeout {
-				log_error "scontrol not responding"
-				end_it 1
+				fail "scontrol not responding"
 			}
 			eof {
 				wait
 			}
 		}
 		if {$matches != 1} {
-			log_error "scontrol failure: expected $regex"
-			end_it 1
+			fail "scontrol failure: expected $regex"
 		}
 	}
 }
@@ -189,13 +181,11 @@ proc my_cat { id } {
 			exp_continue
 		}
 		timeout {
-			log_error "cat not responding"
-			end_it 1
+			fail "cat not responding"
 		}
 	}
 	if {$matches != 3} {
-		log_error "cat failure: expected .+error: from ($fedc1|$fedc2|$fedc3). matches=$matches"
-		end_it 1
+		fail "cat failure: expected .+error: from ($fedc1|$fedc2|$fedc3). matches=$matches"
 	}
 }
 
@@ -222,16 +212,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id my_squeue
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
-#start test
-
 if {![check_federation_setup]} {
 	skip "This test can't be run without fed_slurm_base, fedc1, fedc2, fedc3 setup in globals.local"
 }
@@ -244,18 +224,16 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 
 # get number of nodes per cluster
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state idle,allocm,comp]]
 
 log_info "################################################################"
 log_info "Setup cluster features"
@@ -281,17 +259,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -314,17 +290,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -347,17 +321,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 make_bash_script $file_in "sleep 300"
@@ -406,6 +378,3 @@ set spawn_id $srun_spawn_id
 scontrol $fedc1 $jid(2) "srun: from $fedc1"
 scontrol $fedc2 $jid(2) "srun: from $fedc2"
 scontrol $fedc3 $jid(2) "srun: from $fedc3"
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test37.15 b/testsuite/expect/test37.15
index 55cbd3d5fe..1386946fb6 100755
--- a/testsuite/expect/test37.15
+++ b/testsuite/expect/test37.15
@@ -41,7 +41,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code    0
 set fed_name     "feda"
 set user_name    ""
 set srun_job_cnt 0
@@ -77,16 +76,14 @@ proc sbatch { options } {
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure: expected $regex"
-		end_it 1
+		fail "Batch submit failure: expected $regex"
 	}
 
 	return $job_id
@@ -107,8 +104,7 @@ proc squeue { fed regex } {
 		}
 	}
 	if {$matches != 1} {
-		log_error "unexpected error in squeue. expected $regex"
-		end_it 1
+		fail "Unexpected error in squeue. expected $regex"
 	}
 }
 
@@ -127,8 +123,7 @@ proc scontrol { command job_id option regex } {
 		}
 	}
 	if {$matches != 1} {
-		log_error "unexpected error in scontrol. expected $regex"
-		end_it 1
+		fail "Unexpected error in scontrol. expected $regex"
 	}
 
 	sleep 2
@@ -156,15 +151,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id my_squeue
-	cleanup
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 #start test
 
 if {![check_federation_setup]} {
@@ -179,14 +165,12 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 
 log_info "################################################################"
@@ -213,17 +197,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -246,17 +228,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -279,17 +259,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 log_info "################################################################"
@@ -345,16 +323,14 @@ expect {
 		set jid(1) $expect_out(1,string)
 	}
 	timeout {
-		log_error "sbatch not responding"
-		end_it 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "batch submit failure: expected $regex"
-	end_it 1
+	fail "Batch submit failure: expected $regex"
 }
 
 wait_for_fed_job $jid(1)_1 RUNNING $job2_cluster
@@ -387,7 +363,3 @@ scontrol "resume"  "$jid(1)_2" "-M$fedc2" ""
 squeue $job2_cluster "$jid(1)_2.+R"
 scontrol "resume"  "$jid(1)_3" "-M$fedc3" ""
 squeue $job2_cluster "$jid(1)_3.+R"
-
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test37.16 b/testsuite/expect/test37.16
index 9c6c260429..faa6b35021 100755
--- a/testsuite/expect/test37.16
+++ b/testsuite/expect/test37.16
@@ -41,7 +41,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code    0
 set fed_name     "feda"
 set user_name    ""
 set srun_job_cnt 0
@@ -67,7 +66,6 @@ if {[string compare [get_admin_level] "Administrator"]} {
 
 proc setup_cluster_features {} {
 	global sacctmgr fedc1 fedc2 fedc3 eol
-	set exit_code 0
 	set matches 0
 	set my_pid [spawn $sacctmgr -i modify cluster $fedc1 set features=fa]
 	expect {
@@ -88,17 +86,15 @@ proc setup_cluster_features {} {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr mod not responding"
 			slow_kill $my_pid
-			set exit_code 1
+			fail "sacctmgr mod not responding"
 		}
 		eof {
 			wait
 		}
 	}
-	if {$exit_code || $matches != 4} {
-		log_error "Unexpected error. Got $matches"
-		end_it 1
+	if {$matches != 4} {
+		fail "Unexpected error. Got $matches"
 	}
 
 	set matches 0
@@ -121,17 +117,15 @@ proc setup_cluster_features {} {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr mod not responding"
 			slow_kill $my_pid
-			set exit_code 1
+			fail "sacctmgr mod not responding"
 		}
 		eof {
 			wait
 		}
 	}
-	if {$exit_code || $matches != 4} {
-		log_error "Unexpected error. Got $matches"
-		end_it 1
+	if {$matches != 4} {
+		fail "Unexpected error. Got $matches"
 	}
 
 	set matches 0
@@ -154,17 +148,15 @@ proc setup_cluster_features {} {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr mod not responding"
 			slow_kill $my_pid
-			set exit_code 1
+			fail "sacctmgr mod not responding"
 		}
 		eof {
 			wait
 		}
 	}
-	if {$exit_code || $matches != 4} {
-		log_error "Unexpected error. Got $matches"
-		end_it 1
+	if {$matches != 4} {
+		fail "Unexpected error. Got $matches"
 	}
 }
 
@@ -182,16 +174,14 @@ proc scontrol { fed job_id index regex } {
 			incr matches
 		}
 		timeout {
-			log_error "srun not responding"
-			end_it 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "srun failure: expected $regex"
-		end_it 1
+		fail "srun failure: expected $regex"
 	}
 }
 
@@ -211,16 +201,14 @@ proc sbatch { options } {
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure: expected $regex"
-		end_it 1
+		fail "batch submit failure: expected $regex"
 	}
 
 	return $job_id
@@ -243,16 +231,14 @@ proc srun { options index } {
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "srun not responding"
-			end_it 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "srun failure: expected $regex"
-		end_it 1
+		fail "srun failure: expected $regex"
 	}
 
 	return $job_id
@@ -271,8 +257,7 @@ proc squeue { fed m regex } {
 		}
 	}
 	if {$matches != $m} {
-		log_error "unexpected error in squeue. expected $regex.  Matched $matches/$m times."
-		end_it 1
+		fail "Unexpected error in squeue. expected $regex.  Matched $matches/$m times."
 	}
 }
 
@@ -308,15 +293,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id my_squeue
-	cleanup
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 #start test
 
 if {![check_federation_setup]} {
@@ -331,14 +307,12 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 setup_cluster_features
 
@@ -485,8 +459,7 @@ expect {
 	}
 }
 if {$matches != 3} {
-	log_error "unexpected error in sacct. $matches/3"
-	end_it 1
+	fail "Unexpected error in sacct. $matches/3"
 }
 
 # Test that job3 is marked REVOKED on the siblings clusters (fed2,fed3) and
@@ -505,8 +478,7 @@ expect {
 	}
 }
 if {$matches != 3} {
-	log_error "unexpected error in sacct."
-	end_it 1
+	fail "Unexpected error in sacct."
 }
 
 
@@ -516,8 +488,7 @@ cancel_job $j(1) "-M$fedc2"
 
 set run_cluster [wait_for_fed_job $j(6) RUNNING $fedc2]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find running job on cluster"
-	end_it 1
+	fail "Didn't find running job on cluster"
 }
 
 
@@ -556,8 +527,7 @@ expect {
 	eof {}
 }
 if {$matches != 0} {
-	log_error "srun got signaled when it shouldn't have."
-	end_it 1
+	fail "srun got signaled when it shouldn't have."
 }
 set timeout $old_timeout
 
@@ -576,8 +546,7 @@ cancel_job $j(2) "-M$fedc3"
 
 set run_cluster [wait_for_fed_job $j(7) RUNNING $fedc3]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find running job on cluster"
-	end_it 1
+	fail "Didn't find running job on cluster"
 }
 
 log_info "################################################################"
@@ -674,6 +643,3 @@ spawn $my_sacctmgr mod fed $fed_name set -i clusters-=$fedc1
 scontrol $fedc1 $j(0) 1 "srun: I'm Alive"
 scontrol $clus1 $j(1) 2 "srun: I'm Alive"
 scontrol $clus2 $j(2) 3 "srun: I'm Alive"
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test37.17 b/testsuite/expect/test37.17
index e86c819ea6..962c9732b0 100755
--- a/testsuite/expect/test37.17
+++ b/testsuite/expect/test37.17
@@ -44,7 +44,6 @@ source ./globals_federation
 set c1 $fedc1
 set c2 $fedc2
 set c3 $fedc3
-set exit_code 0
 set job_id1 0
 set job_id2 0
 set user_name [get_my_user_name]
@@ -85,15 +84,6 @@ proc cancel_job { job_id clusters } {
 	wait_for_fed_job $job_id "DONE" $clusters
 }
 
-proc cleanup {} {
-	global bin_rm file_in_long file_in_short fed_name test_id
-
-	delete_federations $fed_name
-	cancel_federation_jobs
-	exec $bin_rm -f $file_in_long
-	exec $bin_rm -f $file_in_short
-}
-
 proc submit_job { options cdir file_in } {
 	global bin_sleep sbatch number fed_slurm_base slow_kill test_id
 
@@ -1023,10 +1013,6 @@ proc test_remote_and_dependencies { } {
 	cancel_job $job_id1 $c1
 }
 
-###############################################################################
-# Begin test
-###############################################################################
-
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "This test can't be run without a usable AccountStorageType"
 }
@@ -1048,6 +1034,19 @@ if {[check_federation_setup]} {
 	set my_scontrol $scontrol
 }
 
+proc cleanup {} {
+	global bin_rm file_in_long file_in_short fed_name test_id
+
+	delete_federations $fed_name
+	cancel_federation_jobs
+	exec $bin_rm -f $file_in_long
+	exec $bin_rm -f $file_in_short
+}
+
+###############################################################################
+# Begin test
+###############################################################################
+
 # Use file_in_short when we have to wait for the job to end.
 # Use file_in_long everywhere else.
 make_bash_script $file_in_long "$bin_sleep 60"
diff --git a/testsuite/expect/test37.2 b/testsuite/expect/test37.2
index c81de390a1..a57d0c5463 100755
--- a/testsuite/expect/test37.2
+++ b/testsuite/expect/test37.2
@@ -42,9 +42,7 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code   0
 set fed_name    "feda"
-
 set timeout	5
 
 #
@@ -63,15 +61,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id
-	cleanup
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 # submit jobs to each cluster and ensure that they return a unique job id
 # job id should be cluster_id + job_id
 # local_id:   bits 0-25
@@ -170,14 +159,12 @@ if {![check_federation_up]} {
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "Failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "Failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 
 # Get cluster/fed info from db
@@ -187,15 +174,14 @@ log_info "Verify federation ids are returned when cluster is part of federation"
 if {[test_fed_job_id $fedc1 [dict get $clusters($fedc1) id]] ||
     [test_fed_job_id $fedc2 [dict get $clusters($fedc2) id]] ||
     [test_fed_job_id $fedc3 [dict get $clusters($fedc3) id]]} {
-	end_it 1
+	fail "Federation id was not returned"
 }
 
 
 # Verify that after clusters are removed from federation that they give normal
 # job ids again.
 if {[delete_federations $fed_name]} {
-	log_error "Failed delete federation $fed_name"
-	end_it 1
+	fail "Failed delete federation $fed_name"
 }
 
 sleep 2
@@ -204,7 +190,5 @@ log_info "Verify local ids after being removed from federation"
 if {[test_loc_job_id $fedc1] ||
     [test_loc_job_id $fedc2] ||
     [test_loc_job_id $fedc3]} {
-	end_it 1
+	fail "Local ids could not be verified"
 }
-
-end_it 0
diff --git a/testsuite/expect/test37.3 b/testsuite/expect/test37.3
index 6dde3a5e50..bba16a704f 100755
--- a/testsuite/expect/test37.3
+++ b/testsuite/expect/test37.3
@@ -43,9 +43,7 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code   0
 set fed_name    "feda"
-
 set timeout	5
 
 #
@@ -253,15 +251,14 @@ test_fed_status $fedc1 $fed_flags [array get clusters]
 #		exp_continue
 #	}
 #	timeout {
-#		log_error "sacctmgr add not responding"
 #		slow_kill $my_pid
-#		set exit_code 1
+#		fail "sacctmgr add not responding"
 #	}
 #	eof {
 #		wait
 #	}
 #}
-#if {$exit_code || $matches != 4} {
+#if {$matches != 4} {
 #	fail "Setting LLC flag"
 #}
 #
@@ -294,15 +291,14 @@ test_fed_status $fedc1 $fed_flags [array get clusters]
 #		exp_continue
 #	}
 #	timeout {
-#		log_error "sacctmgr add not responding"
 #		slow_kill $my_pid
-#		set exit_code 1
+#		fail "sacctmgr add not responding"
 #	}
 #	eof {
 #		wait
 #	}
 #}
-#if {$exit_code || $matches != 4} {
+#if {$matches != 4} {
 #	fail "Removing federation flags. Got $matches"
 #}
 #
@@ -339,15 +335,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 5} {
+if {$matches != 5} {
 	fail "Unexpected error. Got $matches"
 }
 
@@ -378,15 +373,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
+if {$matches != 4} {
 	fail "Unexpected error. Got $matches"
 }
 
@@ -417,15 +411,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
+if {$matches != 4} {
 	fail "Unexpected error. Got $matches"
 }
 
@@ -457,15 +450,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr add not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr add not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
+if {$matches != 4} {
 	fail "Unexpected error. Got $matches"
 }
 
diff --git a/testsuite/expect/test37.4 b/testsuite/expect/test37.4
index df17de1af9..b7e2186ac2 100755
--- a/testsuite/expect/test37.4
+++ b/testsuite/expect/test37.4
@@ -41,7 +41,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code   0
 set fed_name    "feda"
 set file_in     "test$test_id.in"
 set user_name   ""
@@ -83,15 +82,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id
-	cleanup
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 proc submit_fed_batch_job { cname expected_origin expected_sib extra_args expected_state } {
 	global fed_slurm_base file_in node_count number squeue
 
@@ -114,24 +104,21 @@ proc submit_fed_batch_job { cname expected_origin expected_sib extra_args expect
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
 			slow_kill $sbatch_pid
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$job_id == 0} {
-		log_error "batch submit failure"
-		end_it 1
+		fail "Batch submit failure"
 	}
 
 	if {[string compare $expected_state ""]} {
 		set run_cluster [wait_for_fed_job $job_id $expected_state ""]
 		if {[string compare $run_cluster ""] == 0} {
-			log_error "Didn't find cluster with $expected_state job"
-				end_it 1
+			fail "Didn't find cluster with $expected_state job"
 		}
 	}
 
@@ -157,8 +144,7 @@ proc submit_fed_srun_job { cname expected_origin expected_sib extra_args check_e
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "srun not responding"
-			end_it 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -168,15 +154,13 @@ proc submit_fed_srun_job { cname expected_origin expected_sib extra_args check_e
 	if {[string compare $expected_state ""]} {
 		set run_cluster [wait_for_fed_job $job_id $expected_state ""]
 		if {[string compare $run_cluster ""] == 0} {
-			log_error "Didn't find cluster with $expected_state job"
-				end_it 1
+			fail "Didn't find cluster with $expected_state job"
 		}
 	}
 
 	if {$check_env} {
 		if {[wait_for_file $file_out]} {
-			log_error "failed waiting for file '$file_out'"
-			end_it 1
+			fail "Failed waiting for file '$file_out'"
 		}
 
 		spawn grep SLURM_CLUSTER_NAME $file_out
@@ -184,8 +168,7 @@ proc submit_fed_srun_job { cname expected_origin expected_sib extra_args check_e
 			-re "SLURM_CLUSTER_NAME=(\\S+)" {
 				set submit_cluster $expect_out(1,string)
 				if {$submit_cluster ne $expected_sib} {
-					log_error "SLURM_CLUSTER_NAME=$submit_cluster != $expected_sib"
-					end_it 1
+					fail "SLURM_CLUSTER_NAME=$submit_cluster != $expected_sib"
 				}
 			}
 			eof {
@@ -195,8 +178,7 @@ proc submit_fed_srun_job { cname expected_origin expected_sib extra_args check_e
 	}
 
 	if {$job_id == 0} {
-		log_error "srun submit failure"
-		end_it 1
+		fail "srun submit failure"
 	}
 
 	return [validate_fed_job $cname $job_id $expected_origin $expected_sib $submit_cluster]
@@ -225,8 +207,7 @@ proc submit_fed_salloc_job { cname expected_origin expected_sib extra_args check
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "salloc not responding"
-			end_it 1
+			fail "salloc not responding"
 		}
 		eof {
 			wait
@@ -236,15 +217,13 @@ proc submit_fed_salloc_job { cname expected_origin expected_sib extra_args check
 	if {[string compare $expected_state ""]} {
 		set run_cluster [wait_for_fed_job $job_id $expected_state ""]
 		if {[string compare $run_cluster ""] == 0} {
-			log_error "Didn't find cluster with $expected_state job"
-				end_it 1
+			fail "Didn't find cluster with $expected_state job"
 		}
 	}
 
 	if {$check_env} {
 		if {[wait_for_file $file_out]} {
-			log_error "failed waiting for file '$file_out'"
-			end_it 1
+			fail "failed waiting for file '$file_out'"
 		}
 
 		spawn grep SLURM_CLUSTER_NAME $file_out
@@ -252,8 +231,7 @@ proc submit_fed_salloc_job { cname expected_origin expected_sib extra_args check
 			-re "SLURM_CLUSTER_NAME=(\\S+)" {
 				set submit_cluster $expect_out(1,string)
 				if {$submit_cluster ne $expected_sib} {
-					log_error "SLURM_CLUSTER_NAME=$submit_cluster != $expected_sib"
-					end_it 1
+					fail "SLURM_CLUSTER_NAME=$submit_cluster != $expected_sib"
 				}
 			}
 			eof {
@@ -263,8 +241,7 @@ proc submit_fed_salloc_job { cname expected_origin expected_sib extra_args check
 	}
 
 	if {$job_id == 0} {
-		log_error "salloc submit failure"
-		end_it 1
+		fail "salloc submit failure"
 	}
 
 	return [validate_fed_job $cname $job_id $expected_origin $expected_sib $submit_cluster]
@@ -293,13 +270,11 @@ proc validate_fed_job { cname job_id expected_origin expected_sib submit_cluster
 	log_info "origin:$origin sibling:$sibling"
 
 	if {($expected_origin ne "") && ($origin ne $expected_origin)} {
-		log_error "origin:$origin != expected_origin:$expected_origin"
-		end_it 1
+		fail "origin:$origin != expected_origin:$expected_origin"
 	}
 
 	if {($expected_sib ne "") && ($sibling ne $expected_sib)} {
-		log_error "sibling:$sibling != expected_sib:$expected_sib"
-		end_it 1
+		fail "sibling:$sibling != expected_sib:$expected_sib"
 	}
 
 
@@ -315,17 +290,14 @@ proc validate_fed_job { cname job_id expected_origin expected_sib submit_cluster
 			-re "(\\S+)\\s+(\\S+)" {
 				set match 1
 				if {$origin ne $expect_out(1,string)} {
-					log_error "origin not the same on $sibling"
-					end_it 1
+					fail "Origin not the same on $sibling"
 				}
 				if {$expect_out(2,string) ne "NA" && $sibling ne $expect_out(2,string)} {
-					log_error "sibling not the same on $sibling"
-					end_it 1
+					fail "Sibling not the same on $sibling"
 				}
 			}
 			timeout {
-				log_error "$my_squeue not responding"
-					end_it 1
+				fail "$my_squeue not responding"
 			}
 			eof {
 				wait
@@ -333,8 +305,7 @@ proc validate_fed_job { cname job_id expected_origin expected_sib submit_cluster
 		}
 
 		if {!$match} {
-			log_error "didn't find origin or sibling from job"
-			end_it 1
+			fail "Didn't find origin or sibling from job"
 		}
 	}
 
@@ -352,17 +323,15 @@ proc validate_cluster_features { cname job_id expected_features } {
 			incr matches
 		}
 		timeout {
-			log_error "scontrol not responding"
 			slow_kill $scontrol_pid
-			end_it 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "$matches didn't find ClusterFeatures=$expected_features on job"
-		end_it 1
+		fail "$matches didn't find ClusterFeatures=$expected_features on job"
 	}
 }
 
@@ -378,19 +347,17 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 
 # get number of nodes per cluster
 # devide by 2 to get 2 jobs per clusters
-set node_count [expr [available_nodes] / 2]
+set node_count [expr [llength [get_nodes_by_state idle,alloc,comp]] / 2]
 
 make_bash_script $file_in "env; $bin_sleep 300"
 
@@ -412,20 +379,16 @@ incr job_counts($ret_sib)
 parray job_counts
 
 if {$job_counts($fedc1) != 2} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 if {$job_counts($fedc2) != 2} {
-	log_error "$fedc2 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc2 doesn't have 2 jobs running on it"
 }
 if {$job_counts($fedc3) != 2} {
-	log_error "$fedc3 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc3 doesn't have 2 jobs running on it"
 }
 if {$job_counts($fedc1,$fedc2,$fedc3) != 1} {
-	log_error "$fedc1,$fedc2,$fedc3 don't have a pending job on it"
-	end_it 1
+	fail "$fedc1,$fedc2,$fedc3 don't have a pending job on it"
 }
 
 
@@ -445,20 +408,16 @@ incr job_counts($ret_sib)
 parray job_counts
 
 if {$job_counts($fedc1) != 2} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 if {$job_counts($fedc2) != 2} {
-	log_error "$fedc2 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc2 doesn't have 2 jobs running on it"
 }
 if {$job_counts($fedc3) != 2} {
-	log_error "$fedc3 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc3 doesn't have 2 jobs running on it"
 }
 if {$job_counts($fedc1,$fedc2,$fedc3) != 1} {
-	log_error "$fedc1,$fedc2,$fedc3 don't have a pending job on it"
-	end_it 1
+	fail "$fedc1,$fedc2,$fedc3 don't have a pending job on it"
 }
 
 log_info "################################################################"
@@ -477,20 +436,16 @@ incr job_counts($ret_sib)
 parray job_counts
 
 if {$job_counts($fedc1) != 2} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 if {$job_counts($fedc2) != 2} {
-	log_error "$fedc2 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc2 doesn't have 2 jobs running on it"
 }
 if {$job_counts($fedc3) != 2} {
-	log_error "$fedc3 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc3 doesn't have 2 jobs running on it"
 }
 if {$job_counts($fedc1,$fedc2,$fedc3) != 1} {
-	log_error "$fedc1,$fedc2,$fedc3 don't have a pending job on it"
-	end_it 1
+	fail "$fedc1,$fedc2,$fedc3 don't have a pending job on it"
 }
 
 log_info "################################################################"
@@ -528,28 +483,23 @@ incr job_counts($ret_sib)
 parray job_counts
 
 if {$job_counts($fedc1) != 3} {
-	log_error "$fedc1 doesn't have 3 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 3 jobs running on it"
 }
 
 if {$job_counts($fedc2) != 2} {
-	log_error "$fedc2 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc2 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc1,$fedc2) != 1} {
-	log_error "$fedc1,$fedc2 doesn't have 1 jobs running on it"
-	end_it 1
+	fail "$fedc1,$fedc2 doesn't have 1 jobs running on it"
 }
 
 if {$job_counts($fedc3) != 2} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc2,$fedc3) != 1} {
-	log_error "$fedc2,$fedc3 doesn't have 1 jobs running on it"
-	end_it 1
+	fail "$fedc2,$fedc3 doesn't have 1 jobs running on it"
 }
 
 log_info "################################################################"
@@ -587,28 +537,23 @@ incr job_counts($ret_sib)
 parray job_counts
 
 if {$job_counts($fedc1) != 3} {
-	log_error "$fedc1 doesn't have 3 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 3 jobs running on it"
 }
 
 if {$job_counts($fedc2) != 2} {
-	log_error "$fedc2 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc2 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc1,$fedc2) != 1} {
-	log_error "$fedc1,$fedc2 doesn't have 1 jobs running on it"
-	end_it 1
+	fail "$fedc1,$fedc2 doesn't have 1 jobs running on it"
 }
 
 if {$job_counts($fedc3) != 2} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc2,$fedc3) != 1} {
-	log_error "$fedc2,$fedc3 doesn't have 1 jobs running on it"
-	end_it 1
+	fail "$fedc2,$fedc3 doesn't have 1 jobs running on it"
 }
 
 
@@ -647,28 +592,23 @@ incr job_counts($ret_sib)
 parray job_counts
 
 if {$job_counts($fedc1) != 3} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc2) != 2} {
-	log_error "$fedc2 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc2 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc1,$fedc2) != 1} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc3) != 2} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc2,$fedc3) != 1} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 
 
@@ -697,17 +637,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -730,17 +668,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -763,17 +699,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 log_info "################################################################"
@@ -799,23 +733,19 @@ incr job_counts($ret_sib)
 parray job_counts
 
 if {$job_counts($fedc1) != 2} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc2) != 2} {
-	log_error "$fedc2 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc2 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc3) != 2} {
-	log_error "$fedc3 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc3 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc1,$fedc2,$fedc3) != 1} {
-	log_error "$fedc1,$fedc2,$fedc3 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1,$fedc2,$fedc3 doesn't have 2 jobs running on it"
 }
 
 log_info "################################################################"
@@ -842,23 +772,19 @@ incr job_counts($ret_sib)
 parray job_counts
 
 if {$job_counts($fedc1) != 2} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc2) != 2} {
-	log_error "$fedc2 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc2 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc3) != 2} {
-	log_error "$fedc3 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc3 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc1,$fedc2,$fedc3) != 1} {
-	log_error "$fedc1,$fedc2,$fedc3 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1,$fedc2,$fedc3 doesn't have 2 jobs running on it"
 }
 
 log_info "################################################################"
@@ -885,23 +811,19 @@ incr job_counts($ret_sib)
 parray job_counts
 
 if {$job_counts($fedc1) != 2} {
-	log_error "$fedc1 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc2) != 2} {
-	log_error "$fedc2 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc2 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc3) != 2} {
-	log_error "$fedc3 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc3 doesn't have 2 jobs running on it"
 }
 
 if {$job_counts($fedc1,$fedc2,$fedc3) != 1} {
-	log_error "$fedc1,$fedc2,$fedc3 doesn't have 2 jobs running on it"
-	end_it 1
+	fail "$fedc1,$fedc2,$fedc3 doesn't have 2 jobs running on it"
 }
 
 log_info "################################################################"
@@ -915,18 +837,13 @@ expect {
 		incr matches
 	}
 	timeout {
-		log_error "sbatch not responding"
 		slow_kill $sbatch_pid
-		end_it 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "Invalid cluster features sbatch didn't fail. Got $matches"
-	end_it 1
+	fail "Invalid cluster features sbatch didn't fail. Got $matches"
 }
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test37.5 b/testsuite/expect/test37.5
index 71989fe5c9..bed2056896 100755
--- a/testsuite/expect/test37.5
+++ b/testsuite/expect/test37.5
@@ -94,15 +94,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id
-	cleanup
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 proc check_ctl_state { job_id state cluster } {
 	global scontrol
 
@@ -114,8 +105,7 @@ proc check_ctl_state { job_id state cluster } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			end_it 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -123,8 +113,7 @@ proc check_ctl_state { job_id state cluster } {
 	}
 
 	if {$job_state != 1} {
-		log_error "Job $job_id state was not $state on $cluster"
-		end_it 1
+		fail "Job $job_id state was not $state on $cluster"
 	}
 }
 
@@ -139,8 +128,7 @@ proc check_missing_job { job_id cluster } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			end_it 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -148,8 +136,7 @@ proc check_missing_job { job_id cluster } {
 	}
 
 	if {$matched != 1} {
-		log_error "Found an actual job $job_id on $cluster, not supposed to happen"
-		end_it 1
+		fail "Found an actual job $job_id on $cluster, not supposed to happen"
 	}
 }
 
@@ -168,8 +155,7 @@ proc check_dbd_states { job_id states cluster min_cnt } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacct is not responding"
-			end_it 1
+			fail "sacct is not responding"
 		}
 		eof {
 			wait
@@ -177,10 +163,9 @@ proc check_dbd_states { job_id states cluster min_cnt } {
 	}
 
 	if {$state_num < $min_cnt} {
-		log_error "didn't find expected count $min_cnt\
+		fail "didn't find expected count $min_cnt\
 			(>$state_num) for state '$states' for job_id '$job_id'\
 			on cluster '$cluster'"
-		end_it 1
 	}
 
 	return 0
@@ -193,8 +178,7 @@ proc requeue_job { id } {
 	spawn $scontrol requeue $id
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			end_it 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -209,8 +193,7 @@ proc requeuehold_job { id } {
 	spawn $scontrol requeuehold $id
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			end_it 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -224,8 +207,7 @@ proc requeuehold_se_job { id } {
 	spawn $scontrol requeuehold state=specialexit $id
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			end_it 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -239,8 +221,7 @@ proc release_job { id } {
 	spawn $scontrol release $id
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			end_it 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -249,8 +230,7 @@ proc release_job { id } {
 }
 
 proc check_hold { job } {
-
-	global scontrol number exit_code
+	global scontrol number
 
 	set matches 0
 	spawn $scontrol -a --local show job $job
@@ -264,8 +244,7 @@ proc check_hold { job } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			end_it 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -273,14 +252,12 @@ proc check_hold { job } {
 	}
 
 	if { $matches != 2 } {
-		log_error "priority was not set to a non zero value after it was released"
-		end_it 1
+		fail "Priority was not set to a non zero value after it was released"
 	}
 }
 
 proc check_exit_hold { job } {
-
-	global scontrol number exit_code
+	global scontrol number
 
 	set matches 0
 	spawn $scontrol -a --local show job $job
@@ -294,8 +271,7 @@ proc check_exit_hold { job } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			end_it 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -303,8 +279,7 @@ proc check_exit_hold { job } {
 	}
 
 	if { $matches != 2 } {
-		log_error "priority was not set to a non zero value after it was released"
-		end_it 1
+		fail "Priority was not set to a non zero value after it was released"
 	}
 }
 
@@ -322,16 +297,14 @@ proc check_restart_cnt { file cnt } {
 			exp_continue
 		}
 		timeout {
-			log_error "grep $file not respoding"
-			end_it 1
+			fail "grep $file not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {!$match} {
-		log_error "Failed to find SLURM_RESTART_COUNT=$cnt in output file"
-		end_it 1
+		fail "Failed to find SLURM_RESTART_COUNT=$cnt in output file"
 	}
 }
 
@@ -346,7 +319,7 @@ expect {
 }
 
 proc get_slurm_conf { cluster } {
-	global scontrol exit_code
+	global scontrol
 
 	log_user 1
 	set conf ""
@@ -357,9 +330,8 @@ proc get_slurm_conf { cluster } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
 			slow_kill $scon_pid
-			set exit_code 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -373,14 +345,12 @@ proc get_slurm_conf { cluster } {
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 
 set requeue_exit_num [get_config_param "RequeueExit"]
@@ -407,7 +377,7 @@ if {$requeue_exithold_num ne "(null)"} {
 
 
 # get number of nodes per cluster
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state idle,alloc,comp]]
 
 set origin_cluster [get_config_param "ClusterName"]
 set all_cluster_list [list $fedc1 $fedc2 $fedc3]
@@ -428,8 +398,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -437,8 +406,7 @@ expect {
 }
 set run_cluster [wait_for_fed_job $long_running_job_id RUNNING $fedc2]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 spawn $sbatch -N$node_count --exclusive -o /dev/null -e /dev/null -t999999 --requeue -M$fedc3 $long_script
@@ -448,8 +416,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -457,8 +424,7 @@ expect {
 }
 set run_cluster [wait_for_fed_job $long_running_job_id2 RUNNING $fedc3]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 spawn $sbatch -N$node_count --exclusive -o /dev/null -e /dev/null -t1 --requeue $complete_script
@@ -468,8 +434,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -477,15 +442,13 @@ expect {
 }
 
 if { $job_id == 0 } {
-	log_error "sbatch did not submit job"
-	end_it 1
+	fail "sbatch did not submit job"
 }
 
 # Wait for the job to be in the running state
 set run_cluster [wait_for_fed_job $job_id RUNNING $origin_cluster]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 # Requeue the job while it is running
@@ -493,18 +456,15 @@ requeue_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 # Check to see if the job state is PENDING after the requeue
@@ -515,7 +475,7 @@ check_ctl_state $job_id PENDING $fedc2
 check_ctl_state $job_id PENDING $fedc3
 
 if {[cancel_job $job_id]} {
-	end_it 1
+	fail "Unable to cancel job ($job_id)"
 }
 
 log_info "################################################################"
@@ -529,8 +489,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -538,20 +497,17 @@ expect {
 }
 
 if { $job_id == 0 } {
-	log_error "sbatch did not submit job"
-	end_it 1
+	fail "sbatch did not submit job"
 }
 set run_cluster [wait_for_fed_job $job_id RUNNING ""]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 # Wait for the job to be in the complete state
 set done_cluster [wait_for_fed_job $job_id DONE $run_cluster]
 if {[string compare $done_cluster ""] == 0} {
-	log_error "Didn't find cluster with completed job"
-	end_it 1
+	fail "Didn't find cluster with completed job"
 }
 
 # Requeue the job when it is complete
@@ -559,18 +515,15 @@ requeue_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 # Check to see if the job state is PENDING after the requeue
@@ -581,7 +534,7 @@ check_ctl_state $job_id PENDING $fedc2
 check_ctl_state $job_id PENDING $fedc3
 
 if {[cancel_job $job_id]} {
-	end_it 1
+	fail "Unable to cancel job ($job_id)"
 }
 
 log_info "################################################################"
@@ -595,8 +548,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -604,15 +556,13 @@ expect {
 }
 
 if { $job_id == 0 } {
-	log_error "sbatch did not submit job"
-	end_it 1
+	fail "sbatch did not submit job"
 }
 
 # Wait for the job to be in the complete state
 set run_cluster [wait_for_fed_job $job_id DONE $origin_cluster]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 # Requeue the job when it is complete
@@ -620,18 +570,15 @@ requeue_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 # Check to see if the job state is PENDING after the requeue
@@ -642,13 +589,13 @@ check_ctl_state $job_id PENDING $fedc2
 check_ctl_state $job_id PENDING $fedc3
 
 if {[cancel_job $job_id]} {
-	end_it 1
+	fail "Unable to cancel_job ($job_id)"
 }
 if {[cancel_job $long_running_job_id]} {
-	end_it 1
+	fail "Unable to cancel_job ($long_running_job_id)"
 }
 if {[cancel_job $long_running_job_id2]} {
-	end_it 1
+	fail "Unable to cancel_job ($long_running_job_id2)"
 }
 
 log_info "################################################################"
@@ -663,8 +610,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -672,8 +618,7 @@ expect {
 }
 set run_cluster [wait_for_fed_job $long_running_job_id RUNNING $origin_cluster]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 spawn $sbatch -N$node_count --exclusive -o /dev/null -e /dev/null -t1 --requeue $complete_script
@@ -683,8 +628,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -692,14 +636,12 @@ expect {
 }
 
 if { $job_id == 0 } {
-	log_error "sbatch did not submit job"
-	end_it 1
+	fail "sbatch did not submit job"
 }
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 log_info "$run_cluster is running job"
@@ -708,8 +650,7 @@ log_info "$run_cluster is running job"
 # origin revokes the job.
 set rv_origin_cluster [wait_for_fed_job $job_id REVOKED $origin_cluster]
 if {[string compare $rv_origin_cluster ""] == 0} {
-	log_error "origin cluster hasn't revoked job"
-	end_it 1
+	fail "Origin cluster hasn't revoked job"
 }
 
 # Requeue the job while it is running
@@ -717,18 +658,15 @@ requeue_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 # Give time for states to be updated in the db.
@@ -745,7 +683,7 @@ check_ctl_state $job_id PENDING $fedc2
 check_ctl_state $job_id PENDING $fedc3
 
 if {[cancel_job $job_id]} {
-	end_it 1
+	fail "Unable to cancel job ($job_id)"
 }
 
 log_info "################################################################"
@@ -759,8 +697,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -768,14 +705,12 @@ expect {
 }
 
 if { $job_id == 0 } {
-	log_error "sbatch did not submit job"
-	end_it 1
+	fail "sbatch did not submit job"
 }
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 log_info "$run_cluster is running job"
@@ -784,8 +719,7 @@ log_info "$run_cluster is running job"
 # origin revokes the job.
 set rv_origin_cluster [wait_for_fed_job $job_id REVOKED $origin_cluster]
 if {[string compare $rv_origin_cluster ""] == 0} {
-	log_error "origin cluster hasn't revoked job"
-	end_it 1
+	fail "Origin cluster hasn't revoked job"
 }
 
 # Requeue the job while it is running
@@ -793,13 +727,11 @@ requeue_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 # Give time for states to be updated in the db.
@@ -816,7 +748,7 @@ check_ctl_state $job_id PENDING $fedc2
 check_missing_job $job_id $fedc3
 
 if {[cancel_job $job_id]} {
-	end_it 1
+	fail "Unable to cancel job ($job_id)"
 }
 
 log_info "################################################################"
@@ -833,8 +765,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -842,22 +773,19 @@ expect {
 }
 
 if { $job_id == 0 } {
-	log_error "sbatch did not submit job"
-	end_it 1
+	fail "sbatch did not submit job"
 }
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 log_info "$run_cluster is running job"
 
 set ret_cluster [wait_for_fed_job $job_id DONE $run_cluster]
 if {[string compare $ret_cluster ""] == 0} {
-	log_error "Didn't find cluster with completed job"
-	end_it 1
+	fail "Didn't find cluster with completed job"
 }
 
 # Requeue the job when it is complete
@@ -865,18 +793,15 @@ requeue_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 # Give time for states to be updated in the db.
@@ -903,13 +828,11 @@ log_info "################################################################"
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 if {[string compare $run_cluster $origin_cluster] == 0} {
-	log_error "requeued job ran on origin cluster -- expected to run on a different cluster"
-	end_it 1
+	fail "Requeued job ran on origin cluster -- expected to run on a different cluster"
 }
 
 check_restart_cnt $file_out 1
@@ -930,7 +853,7 @@ if {[string compare $fedc1 $origin_cluster] &&
 check_dbd_states $job_id REVOKED $revoked_sib 1
 
 if {[cancel_job $job_id]} {
-	end_it 1
+	fail "Unable to cancel job ($job_id)"
 }
 
 log_info "################################################################"
@@ -947,8 +870,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -956,14 +878,12 @@ expect {
 }
 
 if { $job_id == 0 } {
-	log_error "sbatch did not submit job"
-	end_it 1
+	fail "sbatch did not submit job"
 }
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 # Give time for origin to know that the job was started. If the cancel comes
 # before it knows that the job started then the origin will cancel the local
@@ -975,13 +895,12 @@ $bin_sleep 2
 log_info "$run_cluster is running job"
 
 if {[cancel_job $job_id]} {
-	end_it 1
+	fail "Unable to cancel job ($job_id)"
 }
 
 set ret_cluster [wait_for_fed_job $job_id DONE $run_cluster]
 if {[string compare $ret_cluster ""] == 0} {
-	log_error "Didn't find cluster with completed job"
-	end_it 1
+	fail "Didn't find cluster with completed job"
 }
 
 # Requeue the job when it is complete
@@ -989,18 +908,15 @@ requeue_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 # Give time for states to be updated in the db.
@@ -1016,8 +932,7 @@ check_ctl_state $job_id PENDING $fedc3
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 if {[string compare $run_cluster $origin_cluster] == 0} {
@@ -1027,7 +942,7 @@ if {[string compare $run_cluster $origin_cluster] == 0} {
 check_restart_cnt $file_out 1
 
 if {[cancel_job $job_id]} {
-	end_it 1
+	fail "Unable to cancel job ($job_id)"
 }
 
 
@@ -1045,8 +960,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -1054,14 +968,12 @@ expect {
 }
 
 if { $job_id == 0 } {
-	log_error "sbatch did not submit job"
-	end_it 1
+	fail "sbatch did not submit job"
 }
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 log_info "$run_cluster is running job"
@@ -1070,8 +982,7 @@ log_info "$run_cluster is running job"
 # origin revokes the job.
 set rv_origin_cluster [wait_for_fed_job $job_id REVOKED $origin_cluster]
 if {[string compare $rv_origin_cluster ""] == 0} {
-	log_error "origin cluster hasn't revoked job"
-	end_it 1
+	fail "Origin cluster hasn't revoked job"
 }
 
 # Requeue the job while it is running
@@ -1079,8 +990,7 @@ requeuehold_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $origin_cluster]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 check_hold $job_id
@@ -1098,18 +1008,15 @@ release_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 check_ctl_state $job_id PENDING $fedc1
@@ -1118,8 +1025,7 @@ check_ctl_state $job_id PENDING $fedc3
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 if {[string compare $run_cluster $origin_cluster] == 0} {
@@ -1136,8 +1042,7 @@ log_info "################################################################"
 
 set run_cluster [wait_for_fed_job $job_id DONE $run_cluster]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with completed job"
-	end_it 1
+	fail "Didn't find cluster with completed job"
 }
 
 # Requeue the job when it is complete
@@ -1145,8 +1050,7 @@ requeuehold_job $job_id
 
 set run_cluster [wait_for_fed_job $job_id PENDING $origin_cluster]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 check_hold $job_id
@@ -1163,18 +1067,15 @@ release_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 check_ctl_state $job_id PENDING $fedc1
@@ -1183,8 +1084,7 @@ check_ctl_state $job_id PENDING $fedc3
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 if {[string compare $run_cluster $origin_cluster] == 0} {
@@ -1193,7 +1093,7 @@ if {[string compare $run_cluster $origin_cluster] == 0} {
 
 check_restart_cnt $file_out 2
 if {[cancel_job $job_id]} {
-	end_it 1
+	fail "Unable to cancel job ($job_id)"
 }
 
 log_info "################################################################"
@@ -1210,8 +1110,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		end_it 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -1219,14 +1118,12 @@ expect {
 }
 
 if { $job_id == 0 } {
-	log_error "sbatch did not submit job"
-	end_it 1
+	fail "sbatch did not submit job"
 }
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 log_info "$run_cluster is running job"
@@ -1235,8 +1132,7 @@ log_info "$run_cluster is running job"
 # origin revokes the job.
 set rv_origin_cluster [wait_for_fed_job $job_id REVOKED $origin_cluster]
 if {[string compare $rv_origin_cluster ""] == 0} {
-	log_error "origin cluster hasn't revoked job"
-	end_it 1
+	fail "Origin cluster hasn't revoked job"
 }
 
 # Requeue the job when it is complete
@@ -1244,8 +1140,7 @@ requeuehold_se_job $job_id
 
 set se_cluster [wait_for_fed_job $job_id SPECIAL_EXIT $origin_cluster]
 if {[string compare $se_cluster ""] == 0} {
-	log_error "Didn't find job in SE state"
-	end_it 1
+	fail "Didn't find job in SE state"
 }
 check_hold $job_id
 check_ctl_state $job_id SPECIAL_EXIT $origin_cluster
@@ -1262,18 +1157,15 @@ release_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 check_ctl_state $job_id PENDING $fedc1
@@ -1282,13 +1174,11 @@ check_ctl_state $job_id PENDING $fedc3
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 if {[string compare $run_cluster $origin_cluster] == 0} {
-	log_error "requeued job ran on origin cluster -- expected to run on a different cluster"
-	end_it 1
+	fail "Requeued job ran on origin cluster -- expected to run on a different cluster"
 }
 
 check_restart_cnt $file_out 1
@@ -1301,8 +1191,7 @@ log_info "################################################################"
 
 set run_cluster [wait_for_fed_job $job_id DONE $run_cluster]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with completed job"
-	end_it 1
+	fail "Didn't find cluster with completed job"
 }
 
 # Requeue the job when it is complete
@@ -1310,8 +1199,7 @@ requeuehold_se_job $job_id
 
 set se_cluster [wait_for_fed_job $job_id SPECIAL_EXIT $origin_cluster]
 if {[string compare $se_cluster ""] == 0} {
-	log_error "Didn't find job in SE state"
-	end_it 1
+	fail "Didn't find job in SE state"
 }
 check_hold $job_id
 check_ctl_state $job_id SPECIAL_EXIT $origin_cluster
@@ -1328,18 +1216,15 @@ release_job $job_id
 
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 if {[string compare $pend_cluster ""] == 0} {
-	log_error "Didn't find cluster with pending job"
-	end_it 1
+	fail "Didn't find cluster with pending job"
 }
 
 check_ctl_state $job_id PENDING $fedc1
@@ -1348,18 +1233,16 @@ check_ctl_state $job_id PENDING $fedc3
 
 set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 if {[string compare $run_cluster ""] == 0} {
-	log_error "Didn't find cluster with running job"
-	end_it 1
+	fail "Didn't find cluster with running job"
 }
 
 if {[string compare $run_cluster $origin_cluster] == 0} {
-	log_error "requeued job ran on origin cluster -- expected to run on a different cluster"
-	end_it 1
+	fail "Requeued job ran on origin cluster -- expected to run on a different cluster"
 }
 
 check_restart_cnt $file_out 2
 if {[cancel_job $job_id]} {
-	end_it 1
+	fail "Unable to cancel job ($job_id)"
 }
 
 if {$requeue_exit_num ne "(null)"} {
@@ -1374,8 +1257,7 @@ if {$requeue_exit_num ne "(null)"} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			end_it 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -1383,37 +1265,31 @@ if {$requeue_exit_num ne "(null)"} {
 	}
 
 	if { $job_id == 0 } {
-		log_error "sbatch did not submit job"
-		end_it 1
+		fail "sbatch did not submit job"
 	}
 
 	set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 	if {[string compare $run_cluster ""] == 0} {
-		log_error "Didn't find cluster with running job"
-		end_it 1
+		fail "Didn't find cluster with running job"
 	}
 
 	if {[string compare $run_cluster $origin_cluster] == 0} {
-		log_error "requeued job ran on origin cluster -- expected to run on a different cluster"
-		end_it 1
+		fail "Requeued job ran on origin cluster -- expected to run on a different cluster"
 	}
 
 	log_info "$run_cluster is running job"
 
 	set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 	if {[string compare $pend_cluster ""] == 0} {
-		log_error "Didn't find job in pending state"
-		end_it 1
+		fail "Didn't find job in pending state"
 	}
 	set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 	if {[string compare $pend_cluster ""] == 0} {
-		log_error "Didn't find job in pending state"
-		end_it 1
+		fail "Didn't find job in pending state"
 	}
 	set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 	if {[string compare $pend_cluster ""] == 0} {
-		log_error "Didn't find job in pending state"
-		end_it 1
+		fail "Didn't find job in pending state"
 	}
 
 	# Give time for states to be updated in the db.
@@ -1427,13 +1303,12 @@ if {$requeue_exit_num ne "(null)"} {
 
 	set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 	if {[string compare $run_cluster ""] == 0} {
-		log_error "Didn't find cluster with running job"
-		end_it 1
+		fail "Didn't find cluster with running job"
 	}
 
 	check_restart_cnt $file_out 1
 	if {[cancel_job $job_id]} {
-		end_it 1
+		fail "Unable to cancel job ($job_id)"
 	}
 }
 
@@ -1449,8 +1324,7 @@ if {$requeue_exit_num ne "(null)"} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			end_it 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -1458,27 +1332,23 @@ if {$requeue_exit_num ne "(null)"} {
 	}
 
 	if { $job_id == 0 } {
-		log_error "sbatch did not submit job"
-		end_it 1
+		fail "sbatch did not submit job"
 	}
 
 	set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 	if {[string compare $run_cluster ""] == 0} {
-		log_error "Didn't find cluster with running job"
-		end_it 1
+		fail "Didn't find cluster with running job"
 	}
 
 	if {[string compare $run_cluster $origin_cluster] == 0} {
-		log_error "requeued job ran on origin cluster -- expected to run on a different cluster"
-		end_it 1
+		fail "Requeued job ran on origin cluster -- expected to run on a different cluster"
 	}
 
 	log_info "$run_cluster is running job"
 
 	set pend_cluster [wait_for_fed_job $job_id SPECIAL_EXIT $origin_cluster]
 	if {[string compare $pend_cluster ""] == 0} {
-		log_error "Didn't find job in pending state"
-		end_it 1
+		fail "Didn't find job in pending state"
 	}
 
 	check_exit_hold $job_id
@@ -1494,18 +1364,15 @@ if {$requeue_exit_num ne "(null)"} {
 
 	set pend_cluster [wait_for_fed_job $job_id PENDING $fedc1]
 	if {[string compare $pend_cluster ""] == 0} {
-		log_error "Didn't find cluster with pending job"
-		end_it 1
+		fail "Didn't find cluster with pending job"
 	}
 	set pend_cluster [wait_for_fed_job $job_id PENDING $fedc2]
 	if {[string compare $pend_cluster ""] == 0} {
-		log_error "Didn't find cluster with pending job"
-		end_it 1
+		fail "Didn't find cluster with pending job"
 	}
 	set pend_cluster [wait_for_fed_job $job_id PENDING $fedc3]
 	if {[string compare $pend_cluster ""] == 0} {
-		log_error "Didn't find cluster with pending job"
-		end_it 1
+		fail "Didn't find cluster with pending job"
 	}
 
 	check_ctl_state $job_id PENDING $fedc1
@@ -1514,24 +1381,17 @@ if {$requeue_exit_num ne "(null)"} {
 
 	set run_cluster [wait_for_fed_job $job_id RUNNING $non_origin_clusters]
 	if {[string compare $run_cluster ""] == 0} {
-		log_error "Didn't find cluster with running job"
-		end_it 1
+		fail "Didn't find cluster with running job"
 	}
 
 	if {[string compare $run_cluster $origin_cluster] == 0} {
-		log_error "requeued job ran on origin cluster -- expected to run on a different cluster"
+		fail "Requeued job ran on origin cluster -- expected to run on a different cluster"
 	}
 
 	check_restart_cnt $file_out 1
 
 	if {[cancel_job $job_id]} {
-		end_it 1
+		fail "Unable to cancel job ($job_id)"
 	}
 }
 
-
-
-
-# All Done
-end_it 0
-
diff --git a/testsuite/expect/test37.6 b/testsuite/expect/test37.6
index 8c8a4f09aa..38b49d2bf7 100755
--- a/testsuite/expect/test37.6
+++ b/testsuite/expect/test37.6
@@ -41,7 +41,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code   0
 set fed_name    "feda"
 set file_in     "test$test_id.in"
 set user_name   ""
@@ -70,16 +69,14 @@ proc modify {job_id constraint reg_ex error_message} {
 			incr matches
 		}
 		timeout {
-			log_error "scontrol not responding"
-			end_it 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {![string match "" $reg_ex] && $matches != 1} {
-		log_error "didn't match regex $reg_ex: $matches"
-		end_it 1
+		fail "Didn't match regex $reg_ex: $matches"
 	}
 
 	$bin_sleep 3
@@ -97,16 +94,14 @@ proc modify_with_clusters {job_id constraint reg_ex error_message} {
 			incr matches
 		}
 		timeout {
-			log_error "scontrol not responding"
-			end_it 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {![string match "" $reg_ex] && $matches != 1} {
-		log_error "didn't match regex $reg_ex: $matches"
-		end_it 1
+		fail "Didn't match regex $reg_ex: $matches"
 	}
 
 	$bin_sleep 3
@@ -129,16 +124,14 @@ proc sbatch {my_sbatch script constraint args} {
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$job_id == 0} {
-		log_error "batch submit failure"
-		end_it 1
+		fail "Batch submit failure"
 	}
 
 	$bin_sleep 3
@@ -161,8 +154,7 @@ proc verify {fed job_id pattern error_message} {
 		}
 	}
 	if {$matches != 1} {
-		log_error "$error_message"
-		end_it 1
+		fail "$error_message"
 	}
 }
 
@@ -189,14 +181,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 #start test
 
 if {![check_federation_setup]} {
@@ -211,18 +195,16 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 
 # get number of nodes per cluster
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state]]
 
 make_bash_script $file_in "env; $bin_sleep 300"
 
@@ -250,17 +232,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -283,17 +263,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -316,17 +294,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set my_scontrol "${fed_slurm_base}/$fedc1/bin/scontrol"
@@ -368,8 +344,7 @@ modify $job_id fb "" "did not allow user to modify features of pending job"
 
 set run_cluster [wait_for_fed_job $job_id RUNNING ""]
 if {[string compare $run_cluster $fedc2]} {
-	log_error "Job not running on $fedc2"
-	end_it 1
+	fail "Job not running on $fedc2"
 }
 verify $fedc1 $job_id "RV\\s+$fedc2\\s+$fedc2" "Job not revoked"
 verify $fedc2 $job_id "R\\s+$fedc2\\s+$fedc2" "Job not running on designated cluster"
@@ -385,8 +360,7 @@ modify $job_id "fb,fc" "" "did not allow user to modify features of pending job"
 
 set run_cluster [wait_for_fed_job $job_id RUNNING ""]
 if {[string compare $run_cluster $fedc3]} {
-	log_error "Job not running on $fedc3"
-	end_it 1
+	fail "Job not running on $fedc3"
 }
 verify $fedc1 $job_id "RV\\s+$fedc2,$fedc3\\s+$fedc3" "Job not revoked"
 verify $fedc3 $job_id "R\\s+$fedc2,$fedc3\\s+$fedc3" "Job not running on designated cluster"
@@ -471,8 +445,7 @@ sleep 3
 
 set run_cluster [wait_for_fed_job $job_id RUNNING ""]
 if {[string compare $run_cluster $fedc3]} {
-	log_error "Job not running on $fedc3"
-	end_it 1
+	fail "Job not running on $fedc3"
 }
 verify $fedc1 $job_id "RV\\s+$fedc3\\s+$fedc3" "Job not running on designated cluster"
 verify $fedc2 $job_id ".+Invalid.+" "Job found on wrong cluster"
@@ -702,8 +675,7 @@ expect {
 		incr matches
 	}
 	timeout {
-		log_error "sbatch not responding"
-		end_it 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -711,9 +683,5 @@ expect {
 }
 
 if {$matches != 1} {
-	log_error "batch submit failure"
-	end_it 1
+	fail "Batch submit failure"
 }
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test37.7 b/testsuite/expect/test37.7
index cca1a68b24..07da064324 100755
--- a/testsuite/expect/test37.7
+++ b/testsuite/expect/test37.7
@@ -41,7 +41,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code    0
 set fed_name     "feda"
 set file_in      "test$test_id.in"
 set user_name    ""
@@ -76,16 +75,14 @@ proc sacctmgr_show { regex } {
 			incr matches
 		}
 		timeout {
-			log_error "scontrol not responding"
-			end_it 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "didn't match regex $regex: $matches"
-		end_it 1
+		fail "Didn't match regex $regex: $matches"
 	}
 }
 
@@ -93,7 +90,6 @@ proc sacctmgr_mod { state } {
 	global my_sacctmgr eol fedc1
 
 	set matches 0
-	set exit_code 0
 
 	spawn $my_sacctmgr mod cluster $fedc1 set fedstate=$state -i
 	expect {
@@ -114,17 +110,15 @@ proc sacctmgr_mod { state } {
 			exp_continue
 		}
 		timeout {
-			log_error "sacctmgr mod not responding"
 			slow_kill $my_pid
-			set exit_code 1
+			fail "sacctmgr mod not responding"
 		}
 		eof {
 			wait
 		}
 	}
-	if {$exit_code || $matches != 4} {
-		log_error "Unexpected error. Got $matches"
-		end_it 1
+	if {$matches != 4} {
+		fail "Unexpected error. Got $matches"
 	}
 
 }
@@ -140,16 +134,14 @@ proc scontrol { category regex } {
 			incr matches
 		}
 		timeout {
-			log_error "scontrol not responding"
-			end_it 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "didn't match regex $regex: $matches"
-		end_it 1
+		fail "Didn't match regex $regex: $matches"
 	}
 
 }
@@ -183,16 +175,14 @@ proc sbatch { mfed error } {
 
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure"
-		end_it 1
+		fail "Batch submit failure"
 	}
 
 	$bin_sleep 3
@@ -214,8 +204,7 @@ proc squeue { regex } {
 		}
 	}
 	if {$matches != 1} {
-		log_error "unexpected error in squeue. expected $regex"
-		end_it 1
+		fail "Unexpected error in squeue. expected $regex"
 	}
 }
 
@@ -242,15 +231,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id
-	cleanup
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 #start test
 
 if {![check_federation_setup]} {
@@ -265,12 +245,11 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # get number of nodes per cluster
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state idle,alloc,comp]]
 
 make_bash_script $file_in "env; $bin_sleep 300"
 
@@ -317,17 +296,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 1} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 1} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -339,17 +316,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 1} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 1} {
+	fail "Unexpected error. Got $matches"
 }
 
 sacctmgr_mod ACTIVE
@@ -398,7 +373,6 @@ sbatch 1 0
 squeue "R\\s+"
 
 set matches 0
-set exit_code 0
 
 spawn $my_sacctmgr mod cluster $fedc1 set fedstate=DRAIN+REMOVE -i
 expect {
@@ -419,17 +393,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 sbatch  1 1
@@ -452,8 +424,7 @@ scontrol jobs "Requeue=0.+"
 set job_id [sbatch 1 0]
 
 if {[expr $job_id >> 26]} {
-	log_warn "Removed cluster still giving federated job id"
-	end_it 1
+	fail "Removed cluster still giving federated job id"
 }
 
 wait_for_fed_job $job_id DONE $fedc1
@@ -479,24 +450,21 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 
 sacctmgr_show "\\s+ACTIVE.+ACTIVE\\s+"
 
 set matches 0
-set exit_code 0
 
 spawn $my_sacctmgr mod cluster $fedc2 set fedstate=DRAIN -i
 expect {
@@ -517,17 +485,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 sacctmgr_show "\\s+ACTIVE.+DRAIN\\s+"
@@ -541,7 +507,3 @@ squeue "R\\s+"
 sbatch 0 0
 
 squeue "PD\\s+R\\s+"
-
-# All Done
-end_it 0
- 0
diff --git a/testsuite/expect/test37.8 b/testsuite/expect/test37.8
index ed727ffeeb..c09a339c03 100755
--- a/testsuite/expect/test37.8
+++ b/testsuite/expect/test37.8
@@ -42,7 +42,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code   0
 set fed_name    "feda"
 set user_name   ""
 set srun_job_cnt 0
@@ -85,16 +84,14 @@ proc scontrol { option job_id regex args } {
 			incr matches
 		}
 		timeout {
-			log_error "scontrol not responding"
-			end_it 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "didn't match regex $regex: $matches"
-		end_it 1
+		fail "Didn't match regex $regex: $matches"
 	}
 
 }
@@ -123,16 +120,14 @@ proc sbatch { } {
 
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure"
-		end_it 1
+		fail "Batch submit failure"
 	}
 
 	$bin_sleep 2
@@ -163,8 +158,7 @@ proc squeue { job_id regex args } {
 		}
 	}
 	if {$matches != 1} {
-		log_error "unexpected error in squeue. expected $regex"
-		end_it 1
+		fail "Unexpected error in squeue. expected $regex"
 	}
 }
 
@@ -204,16 +198,14 @@ proc scancel_mod { sibling job_id regex} {
 			incr matches
 		}
 		timeout {
-			log_error "scancel not responding"
-			end_it 1
+			fail "scancel not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "scancel failure, expected $regex"
-		end_it 1
+		fail "scancel failure, expected $regex"
 	}
 }
 
@@ -239,15 +231,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id
-	cleanup
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 #start test
 
 if {![check_federation_setup]} {
@@ -262,18 +245,16 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 
 # get number of nodes per cluster
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state idle,alloc,comp]]
 
 log_info "################################################################"
 log_info "Setup cluster features"
@@ -299,17 +280,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -332,17 +311,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -365,17 +342,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 log_info "################################################################"
@@ -457,6 +432,3 @@ scancel_mod $fedc3 $job_id ""
 squeue $job_id "\\s+RV\\s+" $fedc1
 squeue $job_id "slurm_load_jobs error: Invalid job id specified\\s+" $fedc2
 squeue $job_id "slurm_load_jobs error: Invalid job id specified\\s+" $fedc3
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test37.9 b/testsuite/expect/test37.9
index 84bb38c428..ba194dcbab 100755
--- a/testsuite/expect/test37.9
+++ b/testsuite/expect/test37.9
@@ -41,7 +41,6 @@ source ./globals
 source ./globals_accounting
 source ./globals_federation
 
-set exit_code   0
 set fed_name    "feda"
 set user_name   ""
 set srun_job_cnt 0
@@ -85,16 +84,14 @@ proc sbatch { args } {
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure"
-		end_it 1
+		fail "Batch submit failure"
 	}
 	return $job_id
 }
@@ -115,8 +112,7 @@ proc squeue { options regex } {
 		}
 	}
 	if {$matches != 1} {
-		log_error "unexpected error in squeue. expected $regex"
-		end_it 1
+		fail "Unexpected error in squeue. expected $regex"
 	}
 }
 
@@ -154,8 +150,7 @@ proc sinfo { options regex } {
 		}
 	}
 	if {$matches != 1} {
-		log_error "unexpected error in sinfo. expected $regex"
-		end_it 1
+		fail "Unexpected error in sinfo. expected $regex"
 	}
 }
 
@@ -176,8 +171,7 @@ proc sprio { options regex {match_cnt 1} } {
 		}
 	}
 	if {$matches != $match_cnt} {
-		log_error "unexpected error in sprio. expected $regex ($matches != $match_cnt)"
-		end_it 1
+		fail "Unexpected error in sprio. expected $regex ($matches != $match_cnt)"
 	}
 }
 
@@ -200,9 +194,8 @@ proc scontrol_show { category tasks regex option } {
 		}
 	}
 	if {$matches != 1} {
-		log_error "unexpected error in scontrol_show. expected $regex \
+		fail Uunexpected error in scontrol_show. expected $regex \
 			$matches matches"
-		end_it 1
 	}
 
 }
@@ -230,15 +223,6 @@ proc cleanup { } {
 	return [delete_federations $fed_name]
 }
 
-proc end_it { exit_code } {
-	global test_id
-	cleanup
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 #start test
 
 if {![check_federation_setup]} {
@@ -253,18 +237,16 @@ set user_name [get_my_user_name]
 
 # Remove existing setup
 if {[cleanup] != 0} {
-	log_error "failed to cleanup"
-	end_it 1
+	fail "Failed to cleanup"
 }
 
 # add clusters to federation
 if {[setup_federation $fed_name]} {
-	log_error "failed to setup federation"
-	end_it 1
+	fail "Failed to setup federation"
 }
 
 # get number of nodes per cluster
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state idle,alloc,comp]]
 
 log_info "################################################################"
 log_info "Setup cluster features"
@@ -290,17 +272,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -323,17 +303,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 set matches 0
@@ -356,17 +334,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr mod not responding"
 		slow_kill $my_pid
-		set exit_code 1
+		fail "sacctmgr mod not responding"
 	}
 	eof {
 		wait
 	}
 }
-if {$exit_code || $matches != 4} {
-	log_error "Unexpected error. Got $matches"
-	end_it 1
+if {$matches != 4} {
+	fail "Unexpected error. Got $matches"
 }
 
 make_bash_script $file_in "env; $my_srun sleep 900 & $my_srun sleep 900"
@@ -572,6 +548,3 @@ scontrol_show "steps" $tasks "$reg4{2}" "--local"
 scontrol_show "steps" $tasks "$reg4{2}" "-M$fedc1"
 scontrol_show "steps" $tasks "$reg5{2}" "-M$fedc2"
 scontrol_show "steps" $tasks "$reg6{2}" "-M$fedc3"
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test38.1 b/testsuite/expect/test38.1
index 348c4f898b..f818291894 100755
--- a/testsuite/expect/test38.1
+++ b/testsuite/expect/test38.1
@@ -34,7 +34,6 @@ if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
-set exit_code    0
 set file_in      "test$test_id.in"
 set job_id       0
 
@@ -47,25 +46,22 @@ proc sbatch {} {
 	set sbatch_pid [spawn $sbatch -t1 -o /dev/null $file_in]
 	expect {
 		-re "Batch job submission failed" {
-			log_warn "Unable to execute test due to system configuration"
-			end_it 0
+			skip "Unable to execute test due to system configuration"
 		}
 		-re "Submitted batch job ($number)" {
 			incr matches
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "sbatch not responding"
 			slow_kill $sbatch_pid
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure"
-		end_it 1
+		fail "batch submit failure"
 	}
 
 	return $job_id
@@ -83,22 +79,12 @@ proc cleanup { } {
 	global scancel user_name bin_rm file_in
 	global test_id bin_bash
 
+	cancel_job_id
+
 	exec $bin_rm -f $file_in test$test_id*.out
 	return 0
 }
 
-proc end_it { exit_code } {
-	global test_id
-	cancel_job_id
-	if {$exit_code == 0} {
-		cleanup
-	}
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
 #start test
 
 make_bash_script $file_in "#SBATCH --cpus-per-task=4 --mem-per-cpu=10 --ntasks=1
@@ -147,16 +133,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 7 } {
-	log_error "Problem with scontrol ($matches != 7)"
-	end_it 1
+	fail "Problem with scontrol ($matches != 7)"
 }
 
 set js [parse_id_set $id_set $job_id]
@@ -189,16 +173,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 5} {
-	log_error "Problem with scontrol ($matches != 5)"
-	end_it 1
+	fail "Problem with scontrol ($matches != 5)"
 }
 
 set matches 0
@@ -226,17 +208,12 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 5} {
-	log_error "Problem with scontrol ($matches != 5)"
-	end_it 1
+	fail "Problem with scontrol ($matches != 5)"
 }
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test38.10 b/testsuite/expect/test38.10
index 34a880ef6c..51742f8eaa 100755
--- a/testsuite/expect/test38.10
+++ b/testsuite/expect/test38.10
@@ -26,8 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code	0
-
 if {[get_config_param "FrontendName"] ne "MISSING"} {
         skip "This test is incompatible with front-end systems"
 } else {
@@ -38,20 +36,17 @@ if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 3} {
 	skip "Need 3 or more nodes in default partition"
 }
 
-proc end_it { exit_code } {
+proc cleanup {} {
 	global het_job_id scancel
+
 	if {$het_job_id > 0} {
 		exec $scancel $het_job_id
 	}
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
 }
 
 proc check { id tl matches } {
@@ -66,16 +61,14 @@ proc check { id tl matches } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
-			end_it 1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$count != $matches} {
-		log_error "scontrol failure ($count != 3)"
-		end_it 1
+		fail "scontrol failure ($count != 3)"
 	}
 }
 
@@ -96,16 +89,14 @@ expect {
 		#log_debug "Job initiated"
 	}
 	timeout {
-		log_error "salloc : allocation not granted in $timeout seconds"
-		end_it 1
+		fail "salloc : allocation not granted in $timeout seconds"
 	}
 	eof {
 		wait
 	}
 }
 if {$het_job_id == 0} {
-	log_error "salloc failure"
-	end_it 1
+	fail "salloc failure"
 }
 
 expect *
@@ -128,5 +119,3 @@ check $het_job_id+2 7 1
 
 check $het_job_id+1 6 1
 check $het_job_id+0 5 1
-
-end_it 0
diff --git a/testsuite/expect/test38.11 b/testsuite/expect/test38.11
index f3d2b8a27f..fc9d10d467 100755
--- a/testsuite/expect/test38.11
+++ b/testsuite/expect/test38.11
@@ -36,10 +36,12 @@ set node2      ""
 set het_job_id 0
 
 proc cleanup { } {
-	global het_job_id scancel
+	global bin_rm script1 het_job_id scancel
+
 	if {$het_job_id > 0} {
 		exec $scancel $het_job_id
 	}
+	exec $bin_rm -rf $script1
 }
 
 set accounting_storage_enforce [get_config_param "AccountingStorageEnforce"]
@@ -50,7 +52,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 } elseif {[get_config_param "SlurmdUser"] ne "root(0)"} {
 	skip "This test requires that the SlurmdUser be root"
-} elseif {[get_node_cnt_in_part] < 2} {
+} elseif {[get_partition_param [default_partition] "TotalNodes"] < 2} {
 	skip "This test requires that the configuration has at least 2 nodes"
 }
 if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
@@ -66,8 +68,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -192,8 +193,7 @@ expect {
 		#log_debug "Job initiated"
 	}
 	timeout {
-		log_error "salloc is not responding"
-		set exit_code 1
+		fail "salloc is not responding"
 	}
 	eof {
 		wait
@@ -203,8 +203,6 @@ if {$matches != 4} {
 	fail "sbcast did not copy the file(s) to the correct nodes ($matches != 4)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -rf $script1
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test38.12 b/testsuite/expect/test38.12
index 7157d8b5d9..8d02db11ec 100755
--- a/testsuite/expect/test38.12
+++ b/testsuite/expect/test38.12
@@ -26,7 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code	0
 set timeout	60
 
 if {[get_config_param "FrontendName"] ne "MISSING"} {
@@ -36,20 +35,17 @@ if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 3} {
 	skip "Need 3 or more nodes in default partition"
 }
 
-proc end_it { exit_code } {
+proc cleanup {} {
 	global het_job_id scancel
+
 	if {$het_job_id > 0} {
 		exec $scancel $het_job_id
 	}
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
 }
 
 set het_job_id 0
@@ -72,16 +68,14 @@ expect {
 		#log_debug "Job initiated"
 	}
 	timeout {
-		log_error "salloc: allocation not granted in $timeout seconds"
-		end_it 1
+		fail "salloc: allocation not granted in $timeout seconds"
 	}
 	eof {
 		wait
 	}
 }
 if {$het_job_id == 0} {
-	log_error "salloc failure"
-	end_it 1
+	fail "salloc failure"
 }
 
 log_debug "Collect Nodenames"
@@ -100,13 +94,11 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "squeue not responding"
-		end_it 1
+		fail "squeue not responding"
 	}
 }
 if {$index != 3} {
-	log_error "squeue failure ($index != 3)"
-	end_it 1
+	fail "squeue failure ($index != 3)"
 }
 
 log_info "Test Sending Srun w/ --label To Various Components"
@@ -122,16 +114,14 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "srun failure ($matches != 1)"
-	end_it 1
+	fail "srun failure ($matches != 1)"
 }
 
 set matches 0
@@ -145,16 +135,14 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "srun failure ($matches != 1)"
-	end_it 1
+	fail "srun failure ($matches != 1)"
 }
 
 set matches 0
@@ -168,16 +156,14 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "srun failure ($matches != 1)"
-	end_it 1
+	fail "srun failure ($matches != 1)"
 }
 
 set matches 0
@@ -191,16 +177,14 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 4} {
-	log_error "srun failure ($matches != 4)"
-	end_it 1
+	fail "srun failure ($matches != 4)"
 }
 
 set matches 0
@@ -214,16 +198,14 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 3} {
-	log_error "srun failure ($matches != 3)"
-	end_it 1
+	fail "srun failure ($matches != 3)"
 }
 
 
@@ -239,28 +221,23 @@ for {set inx 0} {$inx < 3} {incr inx} {
 			#break
 		}
 		timeout {
-			log_error "srun not responding"
-			end_it 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 3} {
-		log_error "srun failure ($matches != 3)"
-		end_it 1
+		fail "srun failure ($matches != 3)"
 	}
 }
 
 send "exit\r"
 expect {
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
-
-end_it 0
diff --git a/testsuite/expect/test38.13 b/testsuite/expect/test38.13
index 8cd2a0873c..81e06c14ba 100755
--- a/testsuite/expect/test38.13
+++ b/testsuite/expect/test38.13
@@ -26,10 +26,15 @@
 ############################################################################
 source ./globals
 
-set exit_code	0
 set matches	0
 set het_job_id	0
 
+proc cleanup {} {
+	global het_job_id
+
+	cancel_job $het_job_id
+}
+
 if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
@@ -45,22 +50,17 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$het_job_id != 0} {
-	cancel_job $pack_job_id
 	fail "Heterogeneous job array should not be accepted"
 } elseif {$matches != 1} {
 	fail "Heterogeneous job array should not be accepted ($matches != 1)"
 } else {
 	log_debug "No worries. This error is expected"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test38.14 b/testsuite/expect/test38.14
index ceb23acaa9..f28b05db5d 100755
--- a/testsuite/expect/test38.14
+++ b/testsuite/expect/test38.14
@@ -26,15 +26,20 @@
 ############################################################################
 source ./globals
 
-set exit_code	0
 set file_out    test${test_id}.output
 set het_job_id	0
 
+proc cleanup {} {
+	global bin_rm file_out
+
+	exec $bin_rm -f $file_out
+}
+
 if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 2} {
 	skip "Need 2 or more nodes in default partition"
 }
@@ -44,9 +49,8 @@ set timeout $max_job_delay
 set srun_pid [spawn $srun -t1 -n1 -l -o $file_out --mpi=none $bin_echo one : -n1 $bin_echo two]
 expect {
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -74,9 +78,3 @@ if {[wait_for_file $file_out] == 0} {
 } else {
 	fail "File not found ($file_out)"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_out
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test38.15 b/testsuite/expect/test38.15
index eb84f3c786..d9a1191e6d 100755
--- a/testsuite/expect/test38.15
+++ b/testsuite/expect/test38.15
@@ -25,9 +25,19 @@
 ############################################################################
 source ./globals
 
-set exit_code	0
 set file_in	"test$test_id.input"
 set timeout	60
+set het_job_id  0
+
+proc cleanup {} {
+	global het_job_id scancel bin_rm file_in
+
+	if {$het_job_id > 0} {
+		exec $scancel $het_job_id
+	}
+
+	exec $bin_rm -f $file_in
+}
 
 if {[get_config_param "FrontendName"] ne "MISSING"} {
     skip "This test is incompatible with front-end systems"
@@ -36,23 +46,11 @@ if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 3} {
 	skip "Need 3 or more nodes in default partition"
 }
 
-proc end_it { exit_code } {
-	global het_job_id scancel
-	if {$het_job_id > 0} {
-		exec $scancel $het_job_id
-	}
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
-set het_job_id 0
 set component(0) 0
 set matches 0
 set index 0
@@ -72,16 +70,14 @@ expect {
 		#log_debug "Job initiated"
 	}
 	timeout {
-		log_error "salloc: allocation not granted in $timeout seconds"
-		end_it 1
+		fail "salloc: allocation not granted in $timeout seconds"
 	}
 	eof {
 		wait
 	}
 }
 if {$het_job_id == 0} {
-	log_error "salloc failure"
-	end_it 1
+	fail "salloc failure"
 }
 
 make_bash_script $file_in "
@@ -102,16 +98,14 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 3} {
-	log_error "srun output failure ($matches != 3)"
-	end_it 1
+	fail "srun output failure ($matches != 3)"
 }
 
 make_bash_script $file_in "
@@ -132,28 +126,22 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 3} {
-	log_error "srun output failure ($matches != 3)"
-	end_it 1
+	fail "srun output failure ($matches != 3)"
 }
 
 send "exit\r"
 expect {
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
-
-exec $bin_rm -f $file_in
-end_it 0
diff --git a/testsuite/expect/test38.16 b/testsuite/expect/test38.16
index c374494b5f..88851ac311 100755
--- a/testsuite/expect/test38.16
+++ b/testsuite/expect/test38.16
@@ -25,10 +25,19 @@
 ############################################################################
 source ./globals
 
-set exit_code	0
 set file_in	"test$test_id.bash"
 set file_out	"test$test_id.out"
 set timeout	60
+set het_job_id  0
+
+proc cleanup {} {
+	global het_job_id scancel bin_rm file_in file_out
+
+	if {$het_job_id > 0} {
+		exec $scancel $het_job_id
+	}
+	exec $bin_rm -f $file_in $file_out
+}
 
 if {[get_config_param "FrontendName"] ne "MISSING"} {
     skip "This test is incompatible with front-end systems"
@@ -37,7 +46,7 @@ if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 2} {
 	skip "Need 2 or more nodes in default partition"
 }
@@ -50,18 +59,6 @@ make_bash_script $file_in "
 "
 exec $bin_rm -f $file_out
 
-proc end_it { exit_code } {
-	global het_job_id scancel
-	if {$het_job_id > 0} {
-		exec $scancel $het_job_id
-	}
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
-}
-
-set het_job_id 0
 set component(0) 0
 set matches 0
 set index 0
@@ -81,16 +78,14 @@ expect {
 		#log_debug "Job initiated"
 	}
 	timeout {
-		log_error "salloc : allocation not granted in $timeout seconds"
-		end_it 1
+		fail "salloc : allocation not granted in $timeout seconds"
 	}
 	eof {
 		wait
 	}
 }
 if {$het_job_id == 0} {
-	log_error "salloc failure"
-	end_it 1
+	fail "salloc failure"
 }
 
 log_debug "Collect Nodename for each job component"
@@ -109,13 +104,11 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "squeue not responding"
-		end_it 1
+		fail "squeue not responding"
 	}
 }
 if {$index != 2} {
-	log_error "squeue failure ($index != 2)"
-	end_it 1
+	fail "squeue failure ($index != 2)"
 }
 
 log_info "Test environment variables needed by MPI"
@@ -127,16 +120,14 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {[wait_for_file $file_out] != 0} {
-	log_error "srun output file not found"
-	end_it 1
+	fail "srun output file not found"
 }
 
 set het_nodelist ""
@@ -162,8 +153,7 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "sort not responding"
-		end_it 1
+		fail "sort not responding"
 	}
 	eof {
 		wait
@@ -185,8 +175,7 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "sort not responding"
-		end_it 1
+		fail "sort not responding"
 	}
 	eof {
 		wait
@@ -194,15 +183,13 @@ expect {
 }
 log_user 1
 if {$matches != 6} {
-	log_error "srun failure ($matches != 6)"
-	end_it 1
+	fail "srun failure ($matches != 6)"
 }
 
 send "exit\r"
 expect {
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -219,14 +206,9 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 }
 if {$matches != 2} {
-	log_error "srun combined hostlist is bad ($matches != 2)"
-	end_it 1
+	fail "srun combined hostlist is bad ($matches != 2)"
 }
-
-exec $bin_rm -f $file_in $file_out
-end_it 0
diff --git a/testsuite/expect/test38.17 b/testsuite/expect/test38.17
index 9b3415f8d0..412374410e 100755
--- a/testsuite/expect/test38.17
+++ b/testsuite/expect/test38.17
@@ -26,27 +26,23 @@
 
 source ./globals
 
-set exit_code    0
 set file_in1     "test$test_id.in1"
 set file_in2     "test$test_id.in2"
 set file_in3     "test$test_id.in3"
 set job_id       0
 set matches      0
 
-proc end_it { exit_code } {
+proc cleanup {} {
 	global job_id scancel bin_rm file_in1 file_in2 file_in3 test_id
+
 	if {$job_id != 0} {
 		exec $scancel $job_id
 	}
 	exec $bin_rm -f $file_in1 $file_in2 $file_in3
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
 }
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 3 } {
 	skip "Insufficient nodes in default partition ($node_count < 3)"
 }
@@ -66,8 +62,7 @@ set timeout $max_job_delay
 spawn $salloc -t1 -N1 : -N1 : -N1 ./$file_in1
 expect {
 	-re "Job submit/allocate failed" {
-		log_warn "Unable to execute test due to system configuration"
-		end_it 0
+		skip "Unable to execute test due to system configuration"
 	}
 	-re "Granted job allocation ($number)" {
 		incr matches
@@ -85,25 +80,20 @@ expect {
 		} elseif {$expect_out(1,string) == 2 && $expect_out(2,string) == 2} {
 			incr matches
 		} else {
-			log_error "Invalid output ($expect_out(1,string): FILE$expect_out(2,string))"
-			set exit_code 1
+			fail "Invalid output ($expect_out(1,string): FILE$expect_out(2,string))"
 		}
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		end_it 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$job_id == 0} {
-	log_error "Error submitting job"
-	end_it 1
+	fail "Error submitting job"
 }
 if {$matches != 4} {
-	log_error "Invalid output ($matches != 4)"
-	end_it 1
+	fail "Invalid output ($matches != 4)"
 }
-end_it $exit_code
diff --git a/testsuite/expect/test38.18 b/testsuite/expect/test38.18
index e57d608847..49f58f9b5a 100755
--- a/testsuite/expect/test38.18
+++ b/testsuite/expect/test38.18
@@ -26,7 +26,6 @@
 
 source ./globals
 
-set exit_code    0
 set is_skip      false
 
 if {[get_highest_gres_count 1 "gpu"] < 2} {
@@ -502,10 +501,6 @@ if {[check_config_select "cons_tres"]} {
 	set is_skip true
 }
 
-if {$exit_code} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
-
 if {$is_skip} {
 	skip "Some tests were skipped"
 }
diff --git a/testsuite/expect/test38.2 b/testsuite/expect/test38.2
index 8eccb9ef5c..cfc190b176 100755
--- a/testsuite/expect/test38.2
+++ b/testsuite/expect/test38.2
@@ -29,7 +29,7 @@
 
 source ./globals
 
-set exit_code    0
+set job_id       0
 set file_in      "test$test_id.in"
 set file_out     "test$test_id.out"
 
@@ -38,7 +38,7 @@ if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 }
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 3 } {
 	skip "Insufficient nodes in default partition ($node_count < 3)"
 }
@@ -54,8 +54,7 @@ proc sbatch {} {
 	spawn {*}$command
 	expect {
 		-re "Batch job submission failed" {
-			log_warn "Unable to execute test due to system configuration"
-			end_it 0
+			skip "Unable to execute test due to system configuration"
 		}
 		-re "$regex" {
 			incr matches
@@ -63,16 +62,14 @@ proc sbatch {} {
 
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure"
-		end_it 1
+		fail "Batch submit failure"
 	}
 }
 
@@ -93,34 +90,16 @@ proc test_env {value} {
 	}
 	log_user 1
 	if {$matches != 1} {
-		log_error "output of env incorrect matches: $value ($matches != 1)"
-		end_it 1
-	}
-}
-
-proc cancel_job_id { } {
-	global scancel job_id
-
-	if {$job_id != 0} {
-		exec $scancel $job_id
+		fail "Output of env incorrect matches: $value ($matches != 1)"
 	}
 }
 
 proc cleanup { } {
-	global bin_rm file_in file_out
-	global test_id
+	global job_id bin_rm file_in file_out test_id
 
-	exec $bin_rm -f $file_in $file_out test$test_id*.out
-	return 0
-}
+	cancel_job $job_id
 
-proc end_it { exit_code } {
-	global test_id
-	cancel_job_id
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
+	exec $bin_rm -f $file_in $file_out test$test_id*.out
 }
 
 #start test
@@ -138,7 +117,6 @@ log_info "\n################################################################\n"
 log_info "Submit hetjob and verify output from scontrol show job"
 log_info "\n################################################################\n"
 
-set job_id 0
 sbatch
 if {$job_id == 0} {
 	fail "Error submitting job $job_id"
@@ -169,8 +147,7 @@ expect {
 	}
 }
 if {$matches != 1} {
-	log_error "output of env incorrect matches: SLURM_HET_SIZE=3 ($matches != 1)"
-	end_it 1
+	fail "Output of env incorrect matches: SLURM_HET_SIZE=3 ($matches != 1)"
 }
 
 set matches 0
@@ -188,8 +165,7 @@ expect {
 }
 log_user 1
 if {$matches != 3} {
-	log_error "output of env incorrect matches: SLURM_JOB_PARTITION_HET_GROUP ($matches != 3)"
-	end_it 1
+	fail "Output of env incorrect matches: SLURM_JOB_PARTITION_HET_GROUP ($matches != 3)"
 }
 
 test_env "SLURM_CPUS_PER_TASK_HET_GROUP_0=4"
@@ -207,6 +183,3 @@ test_env "SLURM_MEM_PER_CPU_HET_GROUP_2=6"
 test_env "SLURM_NTASKS_HET_GROUP_0=1"
 test_env "SLURM_NTASKS_HET_GROUP_1=1"
 test_env "SLURM_NTASKS_HET_GROUP_2=1"
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test38.3 b/testsuite/expect/test38.3
index 6b57c5a110..a7eaa3b0c8 100755
--- a/testsuite/expect/test38.3
+++ b/testsuite/expect/test38.3
@@ -32,7 +32,6 @@ source ./globals_het_jobs
 
 set timeout 60
 
-set exit_code    0
 set file_in      "test$test_id.in"
 set job_id       0
 
@@ -55,8 +54,7 @@ proc salloc {} {
 	spawn {*}$command
 	expect {
 		-re "Job submit/allocate failed" {
-			log_warn "Unable to execute test due to system configuration"
-			end_it 0
+			skip "Unable to execute test due to system configuration"
 		}
 		-re "Pending job allocation ($number)" {
 			set job_id $expect_out(1,string)
@@ -69,44 +67,25 @@ proc salloc {} {
 #			exp_continue
 		}
 		timeout {
-			log_error "salloc not responding"
-			end_it 1
+			fail "salloc not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$job_id == 0} {
-		log_error "salloc failure"
-		end_it 1
+		fail "salloc failure"
 	}
 
 	return $job_id
 }
 
-proc cancel_job_id { } {
-	global scancel job_id
-
-	if {$job_id != 0} {
-		exec $scancel $job_id
-	}
-}
-
 proc cleanup { } {
-	global bin_rm file_in
-	global test_id
+	global job_id bin_rm file_in test_id
 
-	exec $bin_rm -f $file_in test$test_id*.out
-	return 0
-}
+	cancel_job $job_id
 
-proc end_it { exit_code } {
-	global test_id
-	cancel_job_id
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
+	exec $bin_rm -f $file_in test$test_id*.out
 }
 
 #start test
@@ -115,7 +94,6 @@ log_info "\n################################################################\n"
 log_info "Salloc hetjob and verify output from scontrol show job"
 log_info "\n################################################################\n"
 
-set job_id 0
 set matches 0
 
 set job_id [salloc]
@@ -142,16 +120,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 3} {
-	log_error "Problem with scontrol ($matches != 3)"
-	end_it 1
+	fail "Problem with scontrol ($matches != 3)"
 }
 
 set js [parse_id_set $id_set $job_id]
@@ -184,13 +160,11 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 }
 if {$matches != 5} {
-	log_error "Problem with scontrol ($matches != 5)"
-	end_it 1
+	fail "Problem with scontrol ($matches != 5)"
 }
 
 set matches 0
@@ -218,17 +192,12 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		end_it 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 5} {
-	log_error "Problem with scontrol ($matches != 5)"
-	end_it 1
+	fail "Problem with scontrol ($matches != 5)"
 }
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test38.4 b/testsuite/expect/test38.4
index 9421725d1e..ce930b0d48 100755
--- a/testsuite/expect/test38.4
+++ b/testsuite/expect/test38.4
@@ -29,17 +29,16 @@
 
 source ./globals
 
-set timeout 60
-
-set exit_code    0
-set file_out     "test$test_id.out"
+set timeout     60
+set job_id      0
+set file_out    "test$test_id.out"
 
 if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
 # find out if we have enough nodes to test functionality
-set node_count [get_node_cnt_in_part]
+set node_count [get_partition_param [default_partition] "TotalNodes"]
 if { $node_count < 3 } {
 	skip "Insufficient nodes in default partition ($node_count < 3)"
 }
@@ -47,20 +46,18 @@ if { $node_count < 3 } {
 proc salloc {} {
 	global number salloc bin_sleep file_out job_id
 
-	set file [open $file_out w]
 	set matches 0
 	set job_id  0
-	log_file -noappend $file_out
 	set command "$salloc --cpus-per-task=4 --mem-per-cpu=10 --ntasks=1 -t1 :\
 			     --cpus-per-task=2 --mem-per-cpu=2  --ntasks=1 -t1 :\
 			     --cpus-per-task=1 --mem-per-cpu=6  --ntasks=1 -t1 \
 				env"
 
+	log_file -noappend $file_out
 	spawn {*}$command
 	expect {
 		-re "Job submit/allocate failed" {
-			log_warn "Unable to execute test due to system configuration"
-			end_it 0
+			skip "Unable to execute test due to system configuration"
 		}
 		-re "Granted job allocation ($number)" {
 			incr matches
@@ -71,12 +68,10 @@ proc salloc {} {
 		}
 
 		timeout {
-			log_error "salloc not responding"
-			end_it 1
+			fail "salloc not responding"
 		}
 	}
-
-	close $file
+	log_file
 }
 
 proc test_env {value} {
@@ -96,42 +91,24 @@ proc test_env {value} {
 	}
 	log_user 1
 	if {$matches != 1} {
-		log_error "output of env incorrect matches: $value ($matches != 1)"
-		end_it 1
-	}
-}
-
-proc cancel_job_id { } {
-	global scancel job_id
-	if {$job_id != 0} {
-		exec $scancel $job_id
+		fail "Output of env incorrect matches: $value ($matches != 1)"
 	}
 }
 
 proc cleanup { } {
-	global bin_rm file_out
-	global test_id
+	global job_id bin_rm file_out test_id
 
-	exec $bin_rm -f $file_out test$test_id*.out
-	return 0
-}
+	cancel_job $job_id
 
-proc end_it { exit_code } {
-	global test_id job_id
-	cancel_job_id
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
+	exec $bin_rm -f $file_out test$test_id*.out
 }
 
-#start test
+# Start test
 
 log_info "\n################################################################\n"
 log_info "Salloc hetjob and verify output from scontrol show job"
 log_info "\n################################################################\n"
 
-set job_id 0
 salloc
 if {$job_id == 0} {
 	fail "Error submitting job $job_id"
@@ -141,7 +118,6 @@ if {$job_id == 0} {
 # Check for desired output
 #
 if {[wait_for_job $job_id DONE] != 0} {
-	cancel_job $job_id
 	fail "Error completing job $job_id"
 }
 if {[wait_for_file $file_out] != 0} {
@@ -161,8 +137,7 @@ expect {
 	}
 }
 if {$matches != 1} {
-	log_error "output of env incorrect matches: SLURM_HET_SIZE=3 ($matches != 1)"
-	end_it 1
+	fail "Output of env incorrect matches: SLURM_HET_SIZE=3 ($matches != 1)"
 }
 
 set matches 0
@@ -180,8 +155,7 @@ expect {
 }
 log_user 1
 if {$matches != 3} {
-	log_error "output of env incorrect matches: SLURM_JOB_PARTITION_HET_GROUP ($matches != 3)"
-	end_it 1
+	fail "Output of env incorrect matches: SLURM_JOB_PARTITION_HET_GROUP ($matches != 3)"
 }
 
 test_env "SLURM_CPUS_PER_TASK_HET_GROUP_0=4"
@@ -199,6 +173,3 @@ test_env "SLURM_MEM_PER_CPU_HET_GROUP_2=6"
 test_env "SLURM_NTASKS_HET_GROUP_0=1"
 test_env "SLURM_NTASKS_HET_GROUP_1=1"
 test_env "SLURM_NTASKS_HET_GROUP_2=1"
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test38.5 b/testsuite/expect/test38.5
index 2d3e305d3c..28c0c2d063 100755
--- a/testsuite/expect/test38.5
+++ b/testsuite/expect/test38.5
@@ -30,10 +30,9 @@
 source ./globals
 source ./globals_het_jobs
 
-set exit_code    0
 set file_in      "test$test_id.in"
 set file_out     "test$test_id.out"
-set job_id 0
+set job_id       0
 
 if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
@@ -52,52 +51,32 @@ proc sbatch {} {
 	spawn {*}$command
 	expect {
 		-re "Batch job submission failed" {
-			log_warn "Unable to execute test due to system configuration"
-			end_it 0
+			skip "Unable to execute test due to system configuration"
 		}
 		-re "Submitted batch job ($number)" {
 			incr matches
 			set job_id $expect_out(1,string)
 		}
 		timeout {
-			log_error "sbatch not responding"
-			end_it 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != 1} {
-		log_error "batch submit failure"
-		end_it 1
+		fail "batch submit failure"
 	}
 
 	return $job_id
 }
 
-proc cancel_job_id { } {
-	global scancel job_id
-
-	if {$job_id != 0} {
-		exec $scancel $job_id
-	}
-}
-
 proc cleanup { } {
-	global scancel user_name bin_rm file_in file_out
-	global test_id bin_bash
+	global job_id user_name bin_rm file_in file_out
 
-	exec $bin_rm -f $file_in $file_out
-	return 0
-}
+	cancel_job $job_id
 
-proc end_it { exit_code } {
-	global test_id
-	cancel_job_id
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
+	exec $bin_rm -f $file_in $file_out
 }
 
 #start test
@@ -136,16 +115,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		end_it 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 2 } {
-	log_error "Problem with squeue test 1 ($matches != 2)"
-	end_it 1
+	fail "Problem with squeue test 1 ($matches != 2)"
 } else {
 	log_debug "Test 1 OK"
 }
@@ -165,16 +142,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		end_it 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1 } {
-	log_error "Problem with squeue test 2 ($matches != 1)"
-	end_it 1
+	fail "Problem with squeue test 2 ($matches != 1)"
 } else {
 	log_debug "Test 2 OK"
 }
@@ -189,19 +164,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		end_it 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1 } {
-	log_error "Problem with squeue test 3 ($matches != 1)"
-	end_it 1
+	fail "Problem with squeue test 3 ($matches != 1)"
 } else {
 	log_debug "Test 3 OK"
 }
-
-# All Done
-end_it 0
diff --git a/testsuite/expect/test38.6 b/testsuite/expect/test38.6
index f61a85f1ef..3c8538f315 100755
--- a/testsuite/expect/test38.6
+++ b/testsuite/expect/test38.6
@@ -25,7 +25,6 @@
 source ./globals
 
 set cwd		    "[$bin_pwd]"
-set exit_code	    0
 set file_in         "${cwd}/test${test_id}.in"
 set file_out	    "${cwd}/test${test_id}.out"
 set file_prog	    "${cwd}/test${test_id}.prog"
@@ -63,7 +62,7 @@ proc end_it { exit_code } {
 	}
 }
 
-set node_count [available_nodes]
+set node_count [llength [get_nodes_by_state idle,alloc,comp]]
 if {$node_count < 2} {
     skip "Insufficient node count to run test"
 }
@@ -360,4 +359,4 @@ if {[wait_for_file $spank_out] == 0} {
 	end_it 1
 }
 
-end_it $exit_code
+end_it 0
diff --git a/testsuite/expect/test38.7 b/testsuite/expect/test38.7
index ed6274d255..c3dbb729ad 100755
--- a/testsuite/expect/test38.7
+++ b/testsuite/expect/test38.7
@@ -29,11 +29,37 @@
 source ./globals
 
 set exit_code          0
+set skips              0
 set file_in            "test$test_id.input"
 set file_out           "test$test_id.output"
 set file_err           "test$test_id.error"
 set test_prog          "test$test_id.prog"
 
+proc run_pmix_het_job {comp_count} {
+	global eol max_job_delay number srun
+
+	# since het jobs are started by the backfill scheduler, they
+	# may need a bit more time to start
+	set timeout [expr $max_job_delay * 2]
+	set het_comps ""
+	set sep ""
+	for {set i 1} {$i <= $comp_count} {incr i} {
+		set het_comps "${het_comps}${sep}echo J$i"
+		set sep " : "
+	}
+	set output [run_command_output -fail "$srun --mpi=pmix $het_comps"]
+	set comp_found [regexp -all "J$number$eol" $output]
+	if {$comp_found != $comp_count} {
+		fail "srun hetjob failed with $comp_count components"
+	}
+}
+
+proc cleanup {} {
+	global bin_rm file_in file_out file_err test_prog
+
+	exec $bin_rm -f $file_in $file_out $file_err $test_prog ${test_prog}.o
+}
+
 #
 # Test for existence of mpi compiler
 #
@@ -51,7 +77,7 @@ if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 2} {
 	skip "Need 2 or more nodes in default partition"
 }
@@ -119,9 +145,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -129,9 +154,7 @@ expect {
 }
 
 if {$no_start != 0} {
-	if {$job_id != 0} {
-		cancel_job $job_id
-	}
+	cancel_job $job_id
 	skip "Partition too small for test"
 }
 if {$job_id == 0} {
@@ -228,9 +251,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -238,9 +260,7 @@ expect {
 }
 
 if {$no_start != 0} {
-	if {$job_id != 0} {
-		cancel_job $job_id
-	}
+	cancel_job $job_id
 	skip "Partition too small for test"
 }
 if {$job_id == 0} {
@@ -302,6 +322,21 @@ if {[wait_for_file $file_out] == 0} {
 # TEST OF HET GROUP 0,1
 ########################################################################
 
+########################################################################
+# TEST OF HET JOB WITH PMIX (to reproduce bug 8990)
+########################################################################
+
+set output [run_command_output "$srun --mpi=list"]
+if {![regexp "pmix$eol" $output]} {
+	log_warn "SKIP: pmix not configured"
+	incr skips
+} else {
+	log_info "TEST OF SRUN HETJOB WITH PMIX"
+	foreach comp_count {2 3 4} {
+		run_pmix_het_job $comp_count
+	}
+}
+
 #
 # OpenMPI can only run in multi-slurmd mode if no more than one node has
 # more than one task. Individual nodes with more than one task use shared
@@ -312,9 +347,6 @@ if {[wait_for_file $file_out] == 0} {
 # mode.
 #
 if {[get_config_param "MULTIPLE_SLURMD"] eq "Yes"} {
-	if {$exit_code == 0} {
-		exec $bin_rm -f $file_in $file_out $file_err $test_prog ${test_prog}.o
-	}
 	skip "This test is incompatible with multiple slurmd systems"
 }
 
@@ -353,9 +385,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -363,9 +394,7 @@ expect {
 }
 
 if {$no_start != 0} {
-	if {$job_id != 0} {
-		cancel_job $job_id
-	}
+	cancel_job $job_id
 	skip "Partition too small for test"
 }
 if {$job_id == 0} {
@@ -464,9 +493,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -474,9 +502,7 @@ expect {
 }
 
 if {$no_start != 0} {
-	if {$job_id != 0} {
-		cancel_job $job_id
-	}
+	cancel_job $job_id
 	skip "Partition too small for test"
 }
 if {$job_id == 0} {
@@ -534,9 +560,7 @@ if {[wait_for_file $file_out] == 0} {
 	set exit_code 1
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err $test_prog ${test_prog}.o
-} else {
+if {$exit_code != 0} {
 	set matches 0
 	spawn head $file_err
 	expect {
@@ -553,8 +577,6 @@ if {$exit_code == 0} {
 	} else {
 		log_debug "Check contents of $file_err"
 	}
-}
 
-if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test38.8 b/testsuite/expect/test38.8
index a2e9855c61..8620873878 100755
--- a/testsuite/expect/test38.8
+++ b/testsuite/expect/test38.8
@@ -27,7 +27,6 @@
 ############################################################################
 source ./globals
 
-set exit_code	0
 set task_num	2
 set timeout	60
 
@@ -45,20 +44,17 @@ if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 3} {
 	skip "Need 3 or more nodes in default partition"
 }
 
-proc end_it { exit_code } {
+proc cleanup {} {
 	global het_job_id scancel
+
 	if {$het_job_id > 0} {
 		exec $scancel $het_job_id
 	}
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
 }
 
 set het_job_id 0
@@ -81,16 +77,14 @@ expect {
 		#log_debug "Job initiated"
 	}
 	timeout {
-		log_error "salloc: allocation not granted in $timeout seconds"
-		end_it 1
+		fail "salloc: allocation not granted in $timeout seconds"
 	}
 	eof {
 		wait
 	}
 }
 if {$het_job_id == 0} {
-	log_error "salloc failure"
-	end_it 1
+	fail "salloc failure"
 }
 
 expect *
@@ -113,8 +107,7 @@ expect {
 		set has_prolog_flags 1
 	}
 	timeout {
-		log_error "scontrol show config not responding"
-		end_it 1
+		fail "scontrol show config not responding"
 	}
 	eof {
 		wait
@@ -129,16 +122,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacct not responding"
-		end_it 1
+		fail "sacct not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != $expected_matches} {
-	log_error "sacct failure ($matches != $expected_matches)"
-	end_it 1
+	fail "sacct failure ($matches != $expected_matches)"
 }
 
 set expected_matches 1
@@ -160,17 +151,13 @@ for {set inx 0} {$inx < 3} {incr inx} {
 			exp_continue
 		}
 		timeout {
-			log_error "sacct not responding"
-			end_it 1
+			fail "sacct not responding"
 		}
 		eof {
 			wait
 		}
 	}
 	if {$matches != $expected_matches || $bad_matches != 0} {
-		log_error "sacct failure ($matches != 1 || $bad_matches != 0)"
-		end_it 1
+		fail "sacct failure ($matches != 1 || $bad_matches != 0)"
 	}
 }
-
-end_it 0
diff --git a/testsuite/expect/test38.9 b/testsuite/expect/test38.9
index 10d2bebaf8..22638e5be8 100755
--- a/testsuite/expect/test38.9
+++ b/testsuite/expect/test38.9
@@ -26,7 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code	0
 set task_num	2
 
 if {[get_config_param "FrontendName"] ne "MISSING"} {
@@ -36,20 +35,17 @@ if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 3} {
 	skip "Need 3 or more nodes in default partition"
 }
 
-proc end_it { exit_code } {
+proc cleanup {} {
 	global het_job_id scancel
+
 	if {$het_job_id > 0} {
 		exec $scancel $het_job_id
 	}
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
 }
 
 set het_job_id 0
@@ -71,14 +67,12 @@ expect {
 	-re "$test_prompt" {
 	}
 	timeout {
-		log_error "salloc : allocation not granted in $timeout seconds"
-		end_it 1
+		fail "salloc : allocation not granted in $timeout seconds"
 	}
 }
 
 if {$het_job_id == 0} {
-	log_error "salloc failure"
-	end_it 1
+	fail "salloc failure"
 }
 
 #
@@ -110,18 +104,15 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "squeue not responding"
-		end_it 1
+		fail "squeue not responding"
 	}
 }
 if {$index != 3} {
-	log_error "squeue failure ($index != 3)"
-	end_it 1
+	fail "squeue failure ($index != 3)"
 }
 
 log_info "Test Sending Jobs To Various Components"
 
-set timeout 3
 set matches 0
 
 send "$srun --mpi=none --het-group=0 printenv SLURMD_NODENAME\r"
@@ -134,13 +125,11 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 }
 if { $matches != 1} {
-	log_error "srun failure $matches $expect_out(buffer)"
-	end_it 1
+	fail "srun failure $matches $expect_out(buffer)"
 }
 
 set matches 0
@@ -155,13 +144,11 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 }
 if { $matches != 1} {
-	log_error "srun failure $matches $expect_out(buffer)"
-	end_it 1
+	fail "srun failure $matches $expect_out(buffer)"
 }
 
 set matches 0
@@ -176,13 +163,11 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 }
 if { $matches != 1} {
-	log_error "srun failure $matches $expect_out(buffer)"
-	end_it 1
+	fail "srun failure $matches $expect_out(buffer)"
 }
 
 set matches 0
@@ -197,13 +182,11 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 }
 if { $matches != 3} {
-	log_error "srun failure $matches $expect_out(buffer)"
-	end_it 1
+	fail "srun failure $matches $expect_out(buffer)"
 }
 
 set matches 0
@@ -218,13 +201,11 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 }
 if { $matches != 2} {
-	log_error "srun failure $matches $expect_out(buffer)"
-	end_it 1
+	fail "srun failure $matches $expect_out(buffer)"
 }
 
 log_info "Testing Error Messages"
@@ -242,13 +223,11 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 }
 if { $matches != 1} {
-	log_error "srun failure $matches $expect_out(buffer)"
-	end_it 1
+	fail "srun failure $matches $expect_out(buffer)"
 }
 
 set matches 0
@@ -263,13 +242,11 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 }
 if { $matches != 1} {
-	log_error "srun failure $matches $expect_out(buffer)"
-	end_it 1
+	fail "srun failure $matches $expect_out(buffer)"
 }
 
 set matches 0
@@ -284,13 +261,18 @@ expect {
 		#break
 	}
 	timeout {
-		log_error "srun not responding"
-		end_it 1
+		fail "srun not responding"
 	}
 }
 if { $matches != 1} {
-	log_error "srun failure $matches $expect_out(buffer)"
-	end_it 1
+	fail "srun failure $matches $expect_out(buffer)"
 }
 
 send "exit\r"
+expect {
+	timeout {
+		fail "salloc not ending"
+	}
+	eof {
+	}
+}
diff --git a/testsuite/expect/test39.1 b/testsuite/expect/test39.1
index f200163aa4..1984a88d19 100755
--- a/testsuite/expect/test39.1
+++ b/testsuite/expect/test39.1
@@ -31,11 +31,19 @@ set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set job_id      0
 
+proc cleanup {} {
+	global job_id bin_rm file_in file_out
+
+	cancel_job $job_id
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 if {![check_config_select "cons_tres"]} {
     skip "This test is only compatible with select/cons_tres"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes > 1} {
 	set nb_nodes 2
 }
@@ -93,8 +101,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -136,8 +143,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -163,8 +169,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -182,8 +187,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -192,10 +196,7 @@ expect {
 if {$match != 1} {
 	fail "sbatch gpu options not fully processed ($match != 8)"
 }
-cancel_job $job_id
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test39.10 b/testsuite/expect/test39.10
index 3bd9f2bee3..dfec54de1d 100755
--- a/testsuite/expect/test39.10
+++ b/testsuite/expect/test39.10
@@ -29,6 +29,12 @@ source ./globals
 set exit_code   0
 set file_in     "test$test_id.input"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 proc run_gpu_per_job { mem_per_gpu } {
 	global exit_code file_in number srun test_id
 
@@ -40,9 +46,8 @@ proc run_gpu_per_job { mem_per_gpu } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -65,9 +70,8 @@ proc run_gpu_per_node { mem_per_gpu } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -90,9 +94,8 @@ proc run_gpu_per_task { mem_per_gpu gpu_cnt } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -264,8 +267,6 @@ for {set inx 12} {$inx <= [expr $node_memory / $gpu_cnt]} {set inx [expr $inx *
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test39.11 b/testsuite/expect/test39.11
index 37d632aa2d..0993aa2fe9 100755
--- a/testsuite/expect/test39.11
+++ b/testsuite/expect/test39.11
@@ -30,6 +30,12 @@ set exit_code   0
 set file_in     "test$test_id.input"
 set number_commas  "\[0-9_,\]+"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {![check_config_select "cons_tres"]} {
     skip "This test is only compatible with select/cons_tres"
 }
@@ -40,7 +46,7 @@ if {$craynetwork_count < 1} {
 }
 log_debug "craynetwork count is $craynetwork_count"
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 
 #
 # Build input script file
@@ -68,9 +74,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -108,9 +113,8 @@ if {0} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -124,8 +128,6 @@ if {0} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test39.12 b/testsuite/expect/test39.12
index 9057167ef4..f104fa0a23 100755
--- a/testsuite/expect/test39.12
+++ b/testsuite/expect/test39.12
@@ -43,7 +43,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes > 1} {
 	set nb_nodes 2
 }
@@ -137,9 +137,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -175,9 +174,8 @@ if {[expr $use_gpus_per_job - 2] > $nb_nodes} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -220,9 +218,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -280,9 +277,8 @@ if { [llength $node_list] != $nb_nodes } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -324,9 +320,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -340,7 +335,9 @@ if {$match_gpu != $expected_gpus} {
 	fail "srun --gpus-per-task failure ($match_gpu != $expected_gpus)"
 }
 
-fail_on_error "Test failed due to previous errors (\$exit_code = $exit_code)"
+if {$exit_code != 0} {
+	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+}
 if {[llength $skipped] != 0} {
 	skip "Some tests skipped:\n[join $skipped \n]"
 }
diff --git a/testsuite/expect/test39.13 b/testsuite/expect/test39.13
index 94961387b2..640115d5af 100755
--- a/testsuite/expect/test39.13
+++ b/testsuite/expect/test39.13
@@ -30,8 +30,21 @@ set exit_code      0
 set file_in1       "test$test_id.input1"
 set file_in2       "test$test_id.input2"
 set file_out       "test$test_id.output"
+set job_list       ""
 set number_commas  "\[0-9_,\]+"
 
+proc cleanup {} {
+	global job_list file_out file_in1 file_in2 bin_rm
+
+	# cancel jobs
+	cancel_job $job_list
+
+	# remove vestigial files
+	run_command -none "$bin_rm ${file_out}.*"
+	run_command -none "$bin_rm -f $file_in1 $file_in2"
+}
+cleanup
+
 if {![check_config_select "cons_tres"]} {
 	skip "This test is only compatible with select/cons_tres"
 }
@@ -39,7 +52,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes > 1} {
 	set nb_nodes 2
 }
@@ -86,91 +99,36 @@ make_bash_script $file_in2 "echo HOST:\$SLURMD_NODENAME CUDA_VISIBLE_DEVICES:\$C
 for {set inx 1} {$inx <= $tot_gpus} {incr inx} {
 	set job_id 0
 	set ofile ${file_out}.${inx}
-	exec $bin_rm -f $ofile
 	if {$tot_gpus > $tot_cpus} {
-#		Assumes no configured DefCPUsPerGPU
-		spawn $sbatch --gpus=$inx -t1 -w $node_name \
-		              -J "test$test_id" --output=$ofile ./$file_in1
+		# Assumes no configured DefCPUsPerGPU
+		set job_id [submit_job "--gpus=$inx -t1 -w $node_name -J \"test$test_id\" --output=$ofile ./$file_in1"]
 	} else {
-		spawn $sbatch --cpus-per-gpu=1 --gpus=$inx -t1 \
-		              -w $node_name -J "test$test_id" \
-		              --output=$ofile ./$file_in1
-	}
-	expect {
-		-re "Submitted batch job ($number)" {
-			set job_id $expect_out(1,string)
-			exp_continue
-		}
-		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
+		set job_id [submit_job "--cpus-per-gpu=1 --gpus=$inx -t1 -w $node_name -J \"test$test_id\" --output=$ofile ./$file_in1"]
 	}
 	if {$job_id == 0} {
-		log_error "sbatch job submit failure"
-		set exit_code 1
-		set tot_gpus [expr $inx - 1]
-		break
+		fail "sbatch job submit failure"
+	} else {
+		lappend job_list $job_id
 	}
 }
 
-#
-# Check the output file contents to identify allocated GPUs
-#
-# Try to avoid possibly huge delays here when tot_gpus is large
-# Perform large delay at the start and small delays for each job's output
-#
-if {$tot_gpus > 4} {
-	sleep 70
+foreach job_id $job_list {
+	if {[wait_for_job $job_id "DONE"]} {
+		fail "Job $job_id not end"
+	}
 }
+
 for {set inx 1} {$inx <= $tot_gpus} {incr inx} {
 	set ofile ${file_out}.${inx}
 	if {[wait_for_file -timeout 20 $ofile] != 0} {
-		log_error "Output file $ofile not found"
-		set exit_code 1
-	} else {
-		set match 0
-		spawn $bin_cat $ofile
-		expect {
-			-re "CUDA_VISIBLE_DEVICES:($number_commas)" {
-				incr match [cuda_count $expect_out(1,string)]
-				exp_continue
-			}
-			eof {
-				wait
-			}
-		}
-		if {$match != $inx} {
-			log_error "Bad GPU count in file $ofile ($match != $inx)"
-			set exit_code 1
-		} else {
-			exec $bin_rm -f $ofile
-		}
+		fail "Output file $ofile not found"
 	}
-}
-
-#
-# Log any vestigial jobs and cancel them
-#
-if {$exit_code != 0} {
-	spawn $squeue -tall -n "test$test_id"
-	expect {
-		timeout {
-			log_error "squeue not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
+	set output [run_command_output "$bin_cat $ofile"]
+	set matches_list [regexp -inline -all "CUDA_VISIBLE_DEVICES:($number_commas)" $output]
+	set match 0
+	foreach {re devices} $matches_list {
+		incr match [cuda_count $devices]
 	}
-}
-exec $scancel -n "test$test_id"
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+	subtest {$match == $inx} "GPU count should be $inx in file $ofile" "$match != $inx, file: $output"
 }
diff --git a/testsuite/expect/test39.14 b/testsuite/expect/test39.14
index 0297c7e319..75ba52cdbf 100755
--- a/testsuite/expect/test39.14
+++ b/testsuite/expect/test39.14
@@ -34,6 +34,18 @@ set file_in2         "test$test_id.input2"
 set file_in3         "test$test_id.input3"
 set file_out1        "test$test_id.output1"
 set file_out2        "test$test_id.output2"
+set job_id1          0
+set job_id2          0
+
+proc cleanup {} {
+	global bin_rm file_in1 file_in2 file_in3 file_out1 file_out2 job_id2
+
+	exec $bin_rm -f $file_in1 $file_in2 $file_in3 $file_out1 $file_out2
+	if {$job_id2 > 0} {
+		exec $bin_rm -f slurm_job_${job_id2}_resize.csh
+		exec $bin_rm -f slurm_job_${job_id2}_resize.sh
+	}
+}
 
 # Bug 9701: disabling test until bug 6252 is fixed
 skip "Test disabled until bug 6252 is fixed"
@@ -49,7 +61,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
     skip "This test is incompatible with front-end systems"
 }
 
-set nb_nodes [available_nodes]
+set nb_nodes [llength [get_nodes_by_state idle,alloc,comp]]
 if {$nb_nodes < 2} {
     skip "Not enough nodes currently available ($nb_nodes avail, 2 needed)"
 }
@@ -100,7 +112,6 @@ echo 'HOST:'\$SLURMD_NODENAME 'CUDA_VISIBLE_DEVICES:'\$CUDA_VISIBLE_DEVICES"
 #
 # Submit job to expand: uses one GPU one node
 #
-set job_id1 0
 spawn $sbatch -N1 --exclusive -J "test$test_id" -t2 --gpus=1 --output=$file_out1 $file_in1
 expect {
 	-re "Submitted batch job ($number)" {
@@ -108,8 +119,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -126,7 +136,6 @@ if {[wait_for_job $job_id1 "RUNNING"] != 0} {
 #
 # Submit job to shrink: uses one GPU one node
 #
-set job_id2 0
 spawn $sbatch -N1 --exclusive -J "test_child_$test_id" --dependency=expand:$job_id1 -t1 --gpus=1 --output=$file_out2 $file_in2
 expect {
 	-re "Submitted batch job ($number)" {
@@ -134,8 +143,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -194,10 +202,6 @@ expect {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2 $file_in3 $file_out1 $file_out2
-	exec $bin_rm -f slurm_job_${job_id2}_resize.csh
-	exec $bin_rm -f slurm_job_${job_id2}_resize.sh
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test39.15 b/testsuite/expect/test39.15
index 4ab0b18bba..33dd56bf2c 100755
--- a/testsuite/expect/test39.15
+++ b/testsuite/expect/test39.15
@@ -26,10 +26,15 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.input"
 set number_commas  "\[0-9_,\]+"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {![check_config_select "cons_tres"]} {
 	skip "This test is only compatible with select/cons_tres"
 }
@@ -37,7 +42,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 2} {
 	skip "This test is 2 or more nodes in the default partition"
 }
@@ -88,9 +93,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -100,9 +104,3 @@ expect {
 if {$match != $nb_tasks} {
 	fail "srun --gpus-per-task with --overcommit failure ($match != $nb_tasks)"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test39.16 b/testsuite/expect/test39.16
index 4adee54f46..07aad2bc75 100755
--- a/testsuite/expect/test39.16
+++ b/testsuite/expect/test39.16
@@ -26,7 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.input"
 set number_commas  "\[0-9_,\]+"
 
@@ -34,7 +33,7 @@ if {![check_config_select "cons_tres"]} {
     skip "This test is only compatible with select/cons_tres"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 1} {
     skip "This test is 1 or more nodes in the default partition"
 }
@@ -95,9 +94,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -117,9 +115,6 @@ if {$gpu_cnt > $cpus_per_node} {
 	}
 }
 
-if {$exit_code} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
 if {$gpu_cnt > $cpus_per_node} {
 	skip "System has more GPUs than CPUs, test is only checking an expected error"
 }
diff --git a/testsuite/expect/test39.17 b/testsuite/expect/test39.17
index 3659e146cd..f88d7ed733 100755
--- a/testsuite/expect/test39.17
+++ b/testsuite/expect/test39.17
@@ -32,6 +32,12 @@ set file_in2       "test$test_id.input2"
 set file_out       "test$test_id.output"
 set number_commas  "\[0-9_,\]+"
 
+proc cleanup {} {
+	global bin_rm file_in1 file_in2 file_out
+
+	exec $bin_rm -f $file_in1 $file_in2 $file_out
+}
+
 if {![check_config_select "cons_tres"]} {
 	skip "This test is only compatible with select/cons_tres"
 }
@@ -39,7 +45,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 log_debug "Default partition node count is $nb_nodes"
 if {$nb_nodes > 1} {
 	set nb_nodes 2
@@ -104,8 +110,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -188,8 +193,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -276,8 +280,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -365,8 +368,7 @@ if {$gpu_cnt > 2} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -474,8 +476,7 @@ if {$gpu_cnt > 2} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -587,8 +588,7 @@ if {$gpu_cnt >= 2 && $nb_nodes >= 2 && $cpus_per_node >= 3} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -706,8 +706,7 @@ if {$gpu_cnt >= 4 && $nb_nodes >= 2 && $cpus_per_node >= 3} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -796,8 +795,7 @@ if {$gpu_cnt > 3 && $nb_nodes >= 2} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -919,8 +917,7 @@ if {$gpu_cnt > 3 && $nb_nodes >= 2} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -1019,8 +1016,7 @@ if {$gpu_cnt > 3 && $nb_nodes >= 2} {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch not responding"
-			set exit_code 1
+			fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -1084,8 +1080,6 @@ if {$gpu_cnt > 3 && $nb_nodes >= 2} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2 $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test39.18 b/testsuite/expect/test39.18
index c9d0fbddc4..1502324142 100755
--- a/testsuite/expect/test39.18
+++ b/testsuite/expect/test39.18
@@ -129,11 +129,13 @@ touch_file $dev8
 
 # Build test program
 if {$use_valgrind} {
-	compile_against_libslurm ${test_prog} 1 "-DUSING_VALGRIND"
+	set rc [compile_against_libslurm -full $test_prog "-DUSING_VALGRIND"]
 } else {
-	compile_against_libslurm ${test_prog} 1
+	set rc [compile_against_libslurm -full $test_prog]
+}
+if {$rc} {
+	fail "Cannot compile test program"
 }
-fail_on_error "Cannot compile test program"
 
 # Build program to determine size of unsigned long in C
 set build_cmd "$bin_cc ${test_ulong_prog}.c -o ${test_ulong_prog}"
@@ -311,7 +313,7 @@ rm -rf ./$file_out"
 	}
 
 	#  Check for expected errors, if applicable
-	if {$err_msgs != "bogus"} {
+	if {$err_msgs != ""} {
 		set response "Errors: Expected $errs_expected, found $errs_actual for error regex '$err_msgs' in sub-test $test_minor"
 		if {$errs_actual == $errs_expected} {
 			set response "(This is OK) ${response}"
diff --git a/testsuite/expect/test39.19 b/testsuite/expect/test39.19
index a27ce39b30..54e03ea030 100755
--- a/testsuite/expect/test39.19
+++ b/testsuite/expect/test39.19
@@ -26,11 +26,16 @@
 ############################################################################
 source ./globals
 
-set exit_code      0
 set file_in1       "test$test_id.input1"
 set file_in2       "test$test_id.input2"
 set file_out       "test$test_id.output"
 
+proc cleanup {} {
+	global bin_rm file_in1 file_in2 file_out
+
+	exec $bin_rm -f $file_in1 $file_in2 $file_out
+}
+
 #
 # Validate the job, batch step and step 0 of a job have the proper GPU counts
 # No step to test if step_gpus == -1
@@ -40,7 +45,7 @@ set file_out       "test$test_id.output"
 #
 proc test_acct { job_id job_gpus step_gpus req_gpus have_gpu_types } {
 	global re_word_str number
-	global bin_cat bin_rm bin_grep exit_code file_out sacct
+	global bin_cat bin_rm bin_grep file_out sacct
 
 	if {$job_id == 0} {
 		return
@@ -65,35 +70,23 @@ proc test_acct { job_id job_gpus step_gpus req_gpus have_gpu_types } {
 		expect {
 			-re "\[^:\]gpu:($number)" {
 				incr match
-				if {$expect_out(1,string) != $job_gpus} {
-					log_error "Bad step GPU count reported by sacct ($expect_out(1,string) != $step_gpus)"
-					set exit_code 1
-				}
+				subtest {$expect_out(1,string) == $job_gpus} "Step GPUs reported by sacct should be $job_gpus" "$expect_out(1,string) != $job_gpus"
 				exp_continue
 			}
 			-re ":gpu:($number)" {
 				incr match
-				if {$expect_out(1,string) != $req_gpus} {
-					log_error "Bad step GPU count reported by sacct ($expect_out(1,string) != $req_gpus)"
-					set exit_code 1
-				}
+				subtest {$expect_out(1,string) == $req_gpus} "Step GPUs reported by sacct should be $req_gpus" "$expect_out(1,string) != $req_gpus"
 				exp_continue
 			}
 			-re "gres/gpu=($number)" {
 				incr match
-				if {$expect_out(1,string) != $step_gpus} {
-					log_error "Bad step GPU count reported by sacct ($expect_out(1,string) != $step_gpus)"
-					set exit_code 1
-				}
+				subtest {$expect_out(1,string) == $step_gpus} "Step GPUs reported by sacct should be $step_gpus" "$expect_out(1,string) != $step_gpus"
 				exp_continue
 			}
 			-re "gres/gpu:($re_word_str)=($number)" {
 				if {$have_gpu_types != 0} {
 					incr match
-					if {$expect_out(2,string) != $step_gpus} {
-						log_error "Bad step GPU count reported by sacct ($expect_out(2,string) != $step_gpus)"
-						set exit_code 1
-					}
+					subtest {$expect_out(2,string) == $step_gpus} "Step GPUs reported by sacct should be $step_gpus" "$expect_out(2,string) != $step_gpus"
 				}
 				exp_continue
 			}
@@ -101,9 +94,7 @@ proc test_acct { job_id job_gpus step_gpus req_gpus have_gpu_types } {
 				wait
 			}
 		}
-		if {$match != 3} {
-			log_error "Missing step GPU count report from sacct ($match != 3)"
-		}
+		subtest {$match == 3} "sacct should report GPUs 3 times" "found $match times"
 	}
 
 	set match 0
@@ -111,62 +102,42 @@ proc test_acct { job_id job_gpus step_gpus req_gpus have_gpu_types } {
 	expect {
 		-re "\[^:\]gpu:($number)" {
 			incr match
-			if {$expect_out(1,string) != $job_gpus} {
-				log_error "Bad batch GPU count reported by sacct ($expect_out(1,string) != $job_gpus)"
-				set exit_code 1
-			}
+			subtest {$expect_out(1,string) == $job_gpus} "Step GPUs reported by sacct should be $job_gpus" "$expect_out(1,string) != $job_gpus"
 			exp_continue
 		}
 		-re ":gpu:($number)" {
 			incr match
-			if {$expect_out(1,string) != $req_gpus} {
-				log_error "Bad batch GPU count reported by sacct ($expect_out(1,string) != $req_gpus)"
-				set exit_code 1
-			}
+			subtest {$expect_out(1,string) == $req_gpus} "Step GPUs reported by sacct should be $req_gpus" "$expect_out(1,string) != $req_gpus"
 			exp_continue
 		}
 		eof {
 			wait
 		}
 	}
-	if {$match != 2} {
-		log_error "Missing batch GPU count report from sacct ($match != 2)"
-	}
+	subtest {$match == 2} "sacct should report GPUs 2 times" "found $match times"
 
 	set match 0
 	spawn $bin_grep $job_id| $file_out
 	expect {
 		-re "\[^:\]gpu:($number)" {
 			incr match
-			if {$expect_out(1,string) != $job_gpus} {
-				log_error "Bad job GPU count reported by sacct ($expect_out(1,string) != $job_gpus)"
-				set exit_code 1
-			}
+			subtest {$expect_out(1,string) == $job_gpus} "Step GPUs reported by sacct should be $job_gpus" "$expect_out(1,string) != $job_gpus"
 			exp_continue
 		}
 		-re ":gpu:($number)" {
 			incr match
-			if {$expect_out(1,string) != $req_gpus} {
-				log_error "Bad job GPU count reported by sacct ($expect_out(1,string) != $req_gpus)"
-				set exit_code 1
-			}
+			subtest {$expect_out(1,string) == $req_gpus} "Step GPUs reported by sacct should be $req_gpus" "$expect_out(1,string) != $req_gpus"
 			exp_continue
 		}
 		-re "gres/gpu=($number)" {
 			incr match
-			if {$expect_out(1,string) != $job_gpus} {
-				log_error "Bad job GPU count reported by sacct ($expect_out(1,string) != $job_gpus)"
-				set exit_code 1
-			}
+			subtest {$expect_out(1,string) == $job_gpus} "Step GPUs reported by sacct should be $job_gpus" "$expect_out(1,string) != $job_gpus"
 			exp_continue
 		}
 		-re "gres/gpu:($re_word_str)=($number)" {
 			if {$have_gpu_types != 0} {
 				incr match
-				if {$expect_out(2,string) != $job_gpus} {
-					log_error "Bad job GPU count reported by sacct ($expect_out(2,string) != $job_gpus)"
-					set exit_code 1
-				}
+				subtest {$expect_out(2,string) == $job_gpus} "Step GPUs reported by sacct should be $job_gpus" "$expect_out(1,string) != $job_gpus"
 			}
 			exp_continue
 		}
@@ -174,9 +145,7 @@ proc test_acct { job_id job_gpus step_gpus req_gpus have_gpu_types } {
 			wait
 		}
 	}
-	if {$match != 3} {
-		log_error "Missing job GPU count report from sacct ($match != 3)"
-	}
+	subtest {$match == 3} "sacct should report GPUs 2 times" "found $match times"
 	exec $bin_rm -f $file_out
 	log_user 1
 }
@@ -189,7 +158,7 @@ proc test_acct { job_id job_gpus step_gpus req_gpus have_gpu_types } {
 #	are reported based upon the job specification
 #
 proc test_out_file { file_out target } {
-	global re_word_str number bin_cat exit_code
+	global re_word_str number bin_cat
 
 	if {[wait_for_file $file_out] != 0} {
 		fail "No output file"
@@ -210,10 +179,7 @@ proc test_out_file { file_out target } {
 			wait
 		}
 	}
-	if {$match != $target} {
-		log_error "Failed to account for proper GPU count ($match != $target)"
-		set exit_code 1
-	}
+	subtest {$match == $target} "GPUs accounted should be $target" "$match != $target"
 }
 
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
@@ -232,7 +198,7 @@ if {![check_config_select "cons_tres"]} {
 	skip "This test is only compatible with select/cons_tres"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 log_debug "Default partition node count is $nb_nodes"
 if {$nb_nodes > 2} {
 	set nb_nodes 2
@@ -282,8 +248,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -320,10 +285,7 @@ expect {
 		wait
 	}
 }
-if {$match != $target} {
-	log_error "Failed to account for proper GPU count ($match != $target)"
-	set exit_code 1
-}
+subtest {$match == $target} "GPUs accounted should be $target" "$match != $target"
 test_acct $job_id $target -1 $req_gpus $have_gpu_types
 
 #
@@ -332,7 +294,7 @@ test_acct $job_id $target -1 $req_gpus $have_gpu_types
 log_info "TEST 2: --gpus option by job"
 
 exec $bin_rm -f $file_out
-if {$nb_nodes >= 2 || $gpu_cnt >= 2} {
+if {$nb_nodes >= 2 || $gpu_cnt >= 3} {
 	set target 3
 } else {
 	set target 2
@@ -345,8 +307,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -386,8 +347,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -428,8 +388,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -475,8 +434,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -500,7 +458,7 @@ test_acct $job_id $target $target $req_gpus $have_gpu_types
 log_info "TEST 6: --gpus option by step"
 
 exec $bin_rm -f $file_out
-if {$nb_nodes >= 2 || $gpu_cnt >= 2} {
+if {$nb_nodes >= 2 || $gpu_cnt >= 3} {
 	set target 3
 } else {
 	set target 2
@@ -513,8 +471,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -554,8 +511,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -596,8 +552,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -650,8 +605,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -668,9 +622,3 @@ if {[wait_for_job $job_id "DONE"] != 0} {
 
 test_out_file $file_out $step_tasks
 test_acct $job_id $job_tasks $step_tasks $req_gpus $have_gpu_types
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2 $file_out
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test39.2 b/testsuite/expect/test39.2
index 2cc5a1f913..93d1d9a409 100755
--- a/testsuite/expect/test39.2
+++ b/testsuite/expect/test39.2
@@ -29,11 +29,17 @@ source ./globals
 set exit_code   0
 set file_in     "test$test_id.input"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {![check_config_select "cons_tres"]} {
     skip "This test is only compatible with select/cons_tres"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes > 1} {
 	set nb_nodes 2
 }
@@ -118,8 +124,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -144,8 +149,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -155,8 +159,6 @@ if {$match != 1} {
 	fail "salloc gpu options not fully processed ($match != 1)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test39.20 b/testsuite/expect/test39.20
index 5827a9fa44..c88522351b 100755
--- a/testsuite/expect/test39.20
+++ b/testsuite/expect/test39.20
@@ -66,12 +66,6 @@ proc setup { gpu_limit } {
 	return 0
 }
 
-proc cleanup { } {
-	global acct
-
-	remove_acct "" $acct
-}
-
 set store_tres [string tolower [get_config_param "AccountingStorageTRES"]]
 set store_mps [string first "gres/gpu:" $store_tres]
 if {$store_mps != -1} {
@@ -97,7 +91,7 @@ if {[param_contains [get_config_param "SelectTypeParameters"] "CR_ONE_TASK_PER_C
 	set one_task_pc 1
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 log_debug "Default partition node count is $nb_nodes"
 if {$nb_nodes > 1} {
 	set nb_nodes 2
@@ -125,6 +119,13 @@ if {$cpus_per_node < 3} {
 	skip "This test requires 3 or more CPUs per node in the default partition"
 }
 
+proc cleanup {} {
+	global acct bin_rm file_in file_out1 file_out2
+
+	remove_acct "" $acct
+	exec $bin_rm -f $file_in $file_out1 $file_out2
+}
+
 # Remove any vestigial test account
 cleanup
 
@@ -160,8 +161,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -180,8 +180,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -210,8 +209,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -222,7 +220,9 @@ if {$match != 2} {
 	set exit_code 1
 }
 cancel_job $job_id1
-fail_on_error "Test failed due to previous errors (\$exit_code = $exit_code)"
+if {$exit_code != 0} {
+	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+}
 
 #
 # Test --gpus-per-node option by job (first job over limit, second job under limit)
@@ -245,8 +245,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -265,8 +264,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -295,8 +293,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -307,7 +304,9 @@ if {$match != 2} {
 	set exit_code 1
 }
 cancel_job $job_id1
-fail_on_error "Test failed due to previous errors (\$exit_code = $exit_code)"
+if {$exit_code != 0} {
+	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
+}
 
 #
 # Test --gpus-per-task option by job (first job over limit, second job under limit)
@@ -334,8 +333,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -354,8 +352,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -384,8 +381,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -396,8 +392,6 @@ if {$match != 2} {
 	set exit_code 1
 }
 cancel_job $job_id1
-fail_on_error "Test failed due to previous errors (\$exit_code = $exit_code)"
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out1 $file_out2
+if {$exit_code != 0} {
+	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test39.21 b/testsuite/expect/test39.21
index 3040a6630c..5a2a686ce2 100755
--- a/testsuite/expect/test39.21
+++ b/testsuite/expect/test39.21
@@ -26,12 +26,17 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set file_prog   "test$test_id.prog"
 set job_id      0
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_prog
+
+	exec $bin_rm -f $file_in $file_out $file_prog
+}
+
 set gpu_cnt [get_highest_gres_count 1 "gpu"]
 if {$gpu_cnt < 1} {
 	skip "This test requires 1 or more GPUs on 1 node of the default partition"
@@ -57,8 +62,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -104,9 +108,3 @@ if {[wait_for_file $file_out] == 0} {
 } else {
 	fail "Failed waiting for file ($file_out)"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_prog
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test39.22 b/testsuite/expect/test39.22
index 024c05c1dc..0233b6a6ba 100755
--- a/testsuite/expect/test39.22
+++ b/testsuite/expect/test39.22
@@ -26,11 +26,16 @@
 ############################################################################
 source ./globals
 
-set exit_code      0
 set file_in1       "test$test_id.input1"
 set file_in2       "test$test_id.input2"
 set number_commas  "\[0-9_,\]+"
 
+proc cleanup {} {
+	global bin_rm file_in1 file_in2
+
+	exec $bin_rm -f $file_in1 $file_in2
+}
+
 if {![check_config_select "cons_tres"]} {
 	skip "This test is only compatible with select/cons_tres"
 }
@@ -41,7 +46,7 @@ if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
 	skip "This test requires SchedulerType = sched/backfill"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 2} {
 	skip "This test requires 2 or more nodes in the default partition"
 }
@@ -75,9 +80,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
 		slow_kill $salloc_pid
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -86,9 +90,3 @@ expect {
 if {$match != 2} {
 	fail "Invalid heterogeneous job output ($match != 2)"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test39.23 b/testsuite/expect/test39.23
index cfa01e14dc..b3c138a4d7 100755
--- a/testsuite/expect/test39.23
+++ b/testsuite/expect/test39.23
@@ -31,6 +31,12 @@ set file_in1       "test$test_id.input1"
 set file_in2       "test$test_id.input2"
 set number_commas  "\[0-9_,\]+"
 
+proc cleanup {} {
+	global bin_rm file_in1 file_in2
+
+	exec $bin_rm -f $file_in1 $file_in2
+}
+
 if {![check_config_select "cons_tres"]} {
 	skip "This test is only compatible with select/cons_tres"
 }
@@ -38,7 +44,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 log_debug "Default partition node count $nb_nodes"
 if {$nb_nodes > 3} {
 	set nb_nodes 3
@@ -84,9 +90,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -117,9 +122,8 @@ if {$gpu_cnt > 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -148,9 +152,8 @@ if {$gpu_cnt > 1 && $nb_nodes > 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -178,9 +181,8 @@ if {$gpu_cnt > 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -222,9 +224,8 @@ if {$gpu_cnt > 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -262,9 +263,8 @@ if {$gpu_cnt > 1 && $num_cpus > 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -278,8 +278,6 @@ if {$gpu_cnt > 1 && $num_cpus > 0} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test39.3 b/testsuite/expect/test39.3
index ae7084750d..53a2db30ef 100755
--- a/testsuite/expect/test39.3
+++ b/testsuite/expect/test39.3
@@ -29,11 +29,17 @@ source ./globals
 set exit_code   0
 set file_in     "test$test_id.input"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 if {![check_config_select "cons_tres"]} {
     skip "This test is only compatible with select/cons_tres"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes > 1} {
 	set nb_nodes 2
 }
@@ -120,8 +126,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -148,8 +153,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -159,8 +163,6 @@ if {$match != 1} {
 	fail "srun gpu options not fully processed ($match != 1)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test39.4 b/testsuite/expect/test39.4
index 41bbc89e0e..115a4fb33f 100755
--- a/testsuite/expect/test39.4
+++ b/testsuite/expect/test39.4
@@ -29,7 +29,7 @@ source ./globals
 set exit_code   0
 set job_id      0
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 
 set gpu_cnt [get_highest_gres_count 1 "gpu"]
 if {$gpu_cnt < 1} {
@@ -54,8 +54,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -79,8 +78,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -104,8 +102,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -129,8 +126,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -154,8 +150,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -179,8 +174,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test39.5 b/testsuite/expect/test39.5
index c905abdb07..14d39f843e 100755
--- a/testsuite/expect/test39.5
+++ b/testsuite/expect/test39.5
@@ -26,7 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code      0
 set skipped        ""
 set file_in1       "test$test_id.input1"
 set file_in2       "test$test_id.input2"
@@ -74,7 +73,7 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes > 1} {
 	set nb_nodes 2
 }
@@ -239,7 +238,8 @@ test_gpus_cnt "--gpus-per-task=1 --tasks-per-node=$use_tasks_per_node -N $nb_nod
 log_info "TEST: -c1 and --cpus-per-gpu=\$cpus_per_socket implicit task count with one GPU"
 test_gpus_cnt "--gres=gpu:1 -c 1 --cpus-per-gpu=$cpus_per_socket" $cpus_per_socket 1
 test_gpus_cnt "--gpus=1 --sockets-per-node=1 -c 1 --cpus-per-gpu=$cpus_per_socket" $cpus_per_socket 1
-test_gpus_cnt "--gpus-per-socket=1 --sockets-per-node=1 -c 1 --cpus-per-gpu=$cpus_per_socket" $cpus_per_socket 1
+test_gpus_cnt "--gpus-per-socket=1 --sockets-per-node=1 -c 1 --cpus-per-gpu=$cpus_per_socket -mblock:cyclic" [expr $cpus_per_socket * $sockets_per_node] $sockets_per_node
+test_gpus_cnt "--gpus-per-socket=1 --sockets-per-node=1 -c 1 --cpus-per-gpu=$cpus_per_socket -mblock:block" $cpus_per_socket 1
 
 log_info "TEST -c1 --cpus-per-gpu=\$cpus_per_socket with 1 GPU per socket"
 if { $sockets_per_node <= $gpu_cnt } {
@@ -278,20 +278,19 @@ test_gpus_cnt "--gres=gpu:1 --ntasks-per-core=1 -c $cpus_per_node" 1 1
 test_gpus_cnt "--gpus=1 --ntasks-per-core=1 -c $cpus_per_node" 1 1
 test_gpus_cnt "-n1 --gpus-per-task=1 --ntasks-per-core=1 -c $cpus_per_node" 1 1
 test_gpus_cnt "--sockets-per-node=1 --gpus-per-socket=1 --ntasks-per-core=1 -c $cpus_per_node" $target_gpus $target_gpus
-test_gpus_cnt "--gpus-per-socket=1 --sockets-per-node=1 --threads-per-core=1 -c [expr $cpus_per_node / $threads_per_core]" $target_gpus $target_gpus
+# Because we're doing one sockets worth of cpus and if there are two sockets
+# we'll get two tasks.
+test_gpus_cnt "--gpus-per-socket=1 --sockets-per-node=1 --threads-per-core=1 -c [expr $cpus_per_node / $threads_per_core]" [expr 2 * $sockets_per_node] $target_gpus
 
 log_info "TEST: --cpus-per-gpu option requiring more CPUs than --cpus-per-task"
 test_gpus_cnt "--gres=gpu:1 -c 1 -n1 --cpus-per-gpu=$cpus_per_socket" 1 1
 test_gpus_cnt "--gres=gpu:1 -c 1 -n$sockets_per_node --cpus-per-gpu=$cpus_per_socket" $sockets_per_node 1
 test_gpus_cnt "--gpus=1 -c 1 -n1 --cpus-per-gpu=$cpus_per_socket" 1 1
 test_gpus_cnt "--gpus=1 -c 1 -n$sockets_per_node --cpus-per-gpu=$cpus_per_socket" $sockets_per_node 1
-test_gpus_cnt "--gpus-per-socket=1 --sockets-per-node=1 -c 1 -n1 --cpus-per-gpu=$cpus_per_socket" 1 1
+# Because we're doing one sockets worth of cpus and if there are two sockets
+# we'll get two tasks.
+test_gpus_cnt "--gpus-per-socket=1 --sockets-per-node=1 -c 1 -n1 --cpus-per-gpu=$cpus_per_socket" $sockets_per_node $target_gpus
 
-if {$cpus_per_socket > $sockets_per_node} {
-	set target_gpus 1
-} else {
-	set target_gpus [expr min($gpu_cnt,$sockets_per_node)]
-}
 test_gpus_cnt "--gpus-per-socket=1 --sockets-per-node=1 -c 1 -n$sockets_per_node --cpus-per-gpu=$cpus_per_socket" [expr $target_gpus * $sockets_per_node] $target_gpus
 
 #Negative tests - number of CPUs reqired by (-n -c) doesn't match --gpus-per-task and --cpus-per-gpu results
@@ -311,7 +310,9 @@ log_info "Negative tests - srun is expected to fail here"
 test_gpus_cnt "--sockets-per-node=1 --gpus-per-socket=1 --ntasks-per-core=1 -c [expr $cpus_per_node * 2]" 0 0
 test_gpus_cnt "--gres=gpu:1 -c [expr $cpus_per_node * 2]" 0 0
 test_gpus_cnt "--gpus=1 -c [expr $cpus_per_node * 2]" 0 0
-test_gpus_cnt "--sockets-per-node=1 --gpus-per-socket=1 -c $cpus_per_node --cpus-per-gpu=$cpus_per_node" 0 0
+if {$sockets_per_node > 1} {
+	test_gpus_cnt "--sockets-per-node=1 --gpus-per-socket=1 -c $cpus_per_node --cpus-per-gpu=$cpus_per_node" 0 0
+}
 if {$threads_per_core > 1} {
 	test_gpus_cnt "--gpus=1 --threads-per-core=1 -c $cpus_per_node" 0 0
 } else {
@@ -331,12 +332,12 @@ test_gpus_cnt "--gpus=1 --ntasks-per-socket=1 -c $cpus_per_node" 1 1
 test_gpus_cnt "-n1 --gpus-per-task=1 --ntasks-per-node=1 -c $cpus_per_node" 1 1
 test_gpus_cnt "-n1 --gpus-per-task=1 --ntasks-per-socket=1 -c $cpus_per_node" 1 1
 
-test_gpus_cnt "--sockets-per-node=$sockets_per_node --gpus-per-socket=1 --ntasks-per-core=1 -c 1" 1 1
+# Fatals slurmd w/out -n. Bug 10197
+test_gpus_cnt "--sockets-per-node=$sockets_per_node --gpus-per-socket=1 --ntasks-per-core=1 -c 1 -n$sockets_per_node" [expr $sockets_per_node * $sockets_per_node] $sockets_per_node
 test_gpus_cnt "--sockets-per-node=1 --gpus-per-socket=1 --ntasks-per-core=1 -c $cpus_per_socket" 1 1
 set target_gpus [expr min($sockets_per_node, $gpu_cnt)]
 test_gpus_cnt "--sockets-per-node=$sockets_per_node --gpus-per-socket=1 --ntasks-per-core=1 -c $cpus_per_node" $target_gpus $target_gpus
 
-fail_on_error "Test failed due to previous errors (\$exit_code = $exit_code)"
 if {[llength $skipped] != 0} {
 	skip "Some tests skipped:\n[join $skipped \n]"
 }
diff --git a/testsuite/expect/test39.6 b/testsuite/expect/test39.6
index 2dfeba11eb..434740c57e 100755
--- a/testsuite/expect/test39.6
+++ b/testsuite/expect/test39.6
@@ -27,10 +27,15 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.input"
 set number_commas  "\[0-9_,\]+"
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 proc multi_socket_gres { gres_string } {
 	set offset 0
 	set multi_found 0
@@ -168,9 +173,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -179,9 +183,3 @@ expect {
 if {$match != $gpu_cnt} {
 	fail "srun --gpus-per-node failure ($match != $gpu_cnt)"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test39.7 b/testsuite/expect/test39.7
index de209dec43..95c9cd493a 100755
--- a/testsuite/expect/test39.7
+++ b/testsuite/expect/test39.7
@@ -31,6 +31,12 @@ set file_in     "test$test_id.input"
 set number_commas  "\[0-9_,\]+"
 set timeout $max_job_delay
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 proc run_gpu_per_job { cpus_per_gpu } {
 	global exit_code file_in number srun test_id timeout
 
@@ -42,9 +48,8 @@ proc run_gpu_per_job { cpus_per_gpu } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -68,9 +73,8 @@ proc run_gpu_per_node { cpus_per_gpu } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -94,9 +98,8 @@ proc run_gpu_per_task { cpus_per_gpu } {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -125,7 +128,7 @@ if { [llength $node_name] != 1 } {
 set cpus_per_node    [get_node_param $node_name "CPUTot"]
 set sockets_per_node [get_node_param $node_name "Sockets"]
 set cpus_per_socket  [expr $cpus_per_node / $sockets_per_node]
-set nb_nodes         [get_node_cnt_in_part]
+set nb_nodes         [get_partition_param [default_partition] "TotalNodes"]
 
 log_debug "GPU count is $gpu_cnt"
 log_debug "Node count in default parition is $nb_nodes"
@@ -195,9 +198,8 @@ if {$gpu_cnt > 1 && $nb_nodes > 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -214,8 +216,6 @@ if {$gpu_cnt > 1 && $nb_nodes > 1} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test39.8 b/testsuite/expect/test39.8
index da7da36af2..6dc0c974ec 100755
--- a/testsuite/expect/test39.8
+++ b/testsuite/expect/test39.8
@@ -83,9 +83,8 @@ if {$sockets_per_node < 2} {
 	set srun_pid [spawn $srun --cpus-per-gpu=1 --gpus-per-socket=1 --sockets-per-node=2 -n2 --accel-bind=g -J "test$test_id" -t1 ./$file_in]
 	expect {
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -99,9 +98,8 @@ if {$sockets_per_node < 2} {
 	set srun_pid [spawn $srun --cpus-per-gpu=1 --gpus-per-socket=1 --sockets-per-node=2 -n2 --gpu-bind=closest -J "test$test_id" -t1 ./$file_in]
 	expect {
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -147,9 +145,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -194,9 +191,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test39.9 b/testsuite/expect/test39.9
index 1a5f94e9e7..18bb957f28 100755
--- a/testsuite/expect/test39.9
+++ b/testsuite/expect/test39.9
@@ -89,9 +89,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -114,9 +113,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -139,9 +137,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -172,9 +169,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -191,9 +187,8 @@ if {$match == 2} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -210,9 +205,8 @@ if {$match == 2} {
 			exp_continue
 		}
 		timeout {
-			log_error "srun not responding"
 			slow_kill $srun_pid
-			set exit_code 1
+			fail "srun not responding"
 		}
 		eof {
 			wait
@@ -249,9 +243,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test4.1 b/testsuite/expect/test4.1
index 21b84ebbb1..ed390f85b5 100755
--- a/testsuite/expect/test4.1
+++ b/testsuite/expect/test4.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$matches != 1} {
 	fail "sinfo failed to report usage format"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test4.10 b/testsuite/expect/test4.10
index fb672a3baa..3290177ad9 100755
--- a/testsuite/expect/test4.10
+++ b/testsuite/expect/test4.10
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set version     0
 
 #
@@ -41,9 +40,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
-		exp_continue
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -53,6 +50,3 @@ expect {
 if {$version != 1} {
 	fail "Did not get proper sinfo version number"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test4.11 b/testsuite/expect/test4.11
index 218546a78a..fea24d51bf 100755
--- a/testsuite/expect/test4.11
+++ b/testsuite/expect/test4.11
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
 set matches      0
 
 #
@@ -46,8 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -56,7 +54,3 @@ expect {
 if {$matches == 0} {
 	fail "sinfo --list-reason output format failure"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test4.12 b/testsuite/expect/test4.12
index f78f50564c..d948fa2b55 100755
--- a/testsuite/expect/test4.12
+++ b/testsuite/expect/test4.12
@@ -249,12 +249,9 @@ proc allocate_and_quit { node proc_cnt total_procs } {
 			exp_continue
 		}
 		timeout {
-			log_error "salloc not responding"
-			if {$job_id != 0} {
-				cancel_job $job_id
-			}
+			cancel_job $job_id
 			slow_kill $mypid
-			return 1
+			fail "salloc not responding"
 		}
 		eof {
 			wait
@@ -311,8 +308,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -327,8 +323,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test4.13 b/testsuite/expect/test4.13
index c75976ba40..f4110d56f5 100755
--- a/testsuite/expect/test4.13
+++ b/testsuite/expect/test4.13
@@ -30,7 +30,7 @@ source ./globals_accounting
 
 set test_acct           "test$test_id\_acct"
 set test_part           "test$test_id\_part"
-set test_node           [get_idle_node_in_part]
+set test_node           [lindex [get_nodes_by_state] 0]
 set exit_code           0
 
 array set node_sinfo_vals { }
@@ -42,7 +42,7 @@ array set node_info {
 	CPULoad            cpusload
 	CoresPerSocket     cores
 	TmpDisk            disk
-	Features           features
+	AvailableFeatures  features
 	FreeMem            freemem
 	Gres               gres
 	NodeAddr           nodeaddr
@@ -67,172 +67,52 @@ array set part_info {
 	RootOnly           root
 }
 
+if {![is_super_user]} {
+    skip "This test can't be run without being a super user of the cluster"
+}
 
 proc cleanup { } {
+	global scontrol test_part
 
-	global scontrol test_part exit_code
-
-	spawn $scontrol delete partitionname=$test_part
-	expect {
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-
-}
-
-if {![is_super_user]} {
-    skip "This test can't be run without being a super user of the cluster"
+	run_command "$scontrol delete partitionname=$test_part"
 }
 
 log_info "=== Testing Node Information ==="
-set first_option 1
+set nodes_dict [get_nodes $test_node]
 foreach option [array names node_info] {
-
-	if {$first_option == 1} {
-		set first_option 0
-	} else {
-		log_user 0
-	}
-	spawn $scontrol show node $test_node
-	expect {
-		-re "\\m$option=($re_word_str)\\M" {
-			set node_sinfo_vals($node_info($option)) $expect_out(1,string)
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
+	set node_sinfo_vals($node_info($option)) [dict get $nodes_dict $test_node $option]
 }
 
-set first_option 1
 foreach option [array names node_sinfo_vals] {
-
 	# Gres option (and potentially others) may include "(" and ")" as
 	# characters, they need to be escaped to be used as part of a regexp
-	set regexp [string map {\( \\( \) \\)} $node_sinfo_vals($option)]
+	set val_re [string map {\( \\( \) \\)} $node_sinfo_vals($option)]
 
-	set match 0
-	spawn $sinfo -n$test_node -O$option:256 -h
-	expect {
-		-nocase -re "$regexp" {
-			set match 1
-			exp_continue
-		}
-		timeout {
-			log_error "sinfo is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-
-	if {$match != 1} {
-		log_error "Node information $option output does not match sinfo output. Looking for value: $option = $node_sinfo_vals($option)"
-		set exit_code 1
+	set output [string trim [run_command_output -fail "$sinfo -n$test_node -O$option:256 -h"]]
+	if {$option eq "cpusload" || $option eq "freemem"} {
+		# CPULoad and FreeMem can change from one system call to another
+		subtest [regexp {\d+(?:\.\d+)?} $output] "Verify node $option field" "Expected a number but observed $output"
+	} else {
+		subtest [regexp -nocase $val_re $output] "Verify node $option field" "Expected $val_re but observed $output"
 	}
 }
 
 #
 # Add test partition
 #
-spawn $scontrol create partitionname=$test_part nodes=$test_node
-expect {
-	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-
-set match 0
-spawn $scontrol show partitionname=$test_part
-expect {
-	-re "PartitionName=$test_part" {
-		set match 1
-		exp_continue
-	}
-	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-if {$match != 1} {
+run_command -fail "$scontrol create partitionname=$test_part nodes=$test_node"
+set output [run_command_output -fail "$scontrol show partitionname=$test_part"]
+if {![regexp "PartitionName=$test_part" $output]} {
 	fail "Test partition was not created"
 }
 
 log_info "=== Testing Partition Information ==="
-set first_option 1
+set parts_dict [get_partitions $test_part]
 foreach option [array names part_info] {
-
-	set part_sinfo_vals($part_info($option)) "UNKNOWN"
-	set match 0
-	if {$first_option == 1} {
-		set first_option 0
-	} else {
-		log_user 0
-	}
-	spawn $scontrol show partition $test_part
-	expect {
-		-re "\\m$option=($re_word_str)\\M" {
-			set part_sinfo_vals($part_info($option)) \
-			    $expect_out(1,string)
-			exp_continue
-		}
-		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	log_user 1
+	set part_sinfo_vals($part_info($option)) [dict get $parts_dict $test_part $option]
 }
 
-set first_option 1
 foreach option [array names part_sinfo_vals] {
-
-	set match 0
-	spawn $sinfo -p$test_part -O$option -h
-	expect {
-		-nocase -re "$part_sinfo_vals($option)" {
-			set match 1
-			exp_continue
-		}
-		timeout {
-			log_error "sinfo is not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-
-	if {$match != 1} {
-		log_error "Partition information $option output does not match sinfo output. Looking for value: $option = $part_sinfo_vals($option)"
-		set exit_code 1
-	}
-}
-
-cleanup
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors"
+	set output [string trim [run_command_output -fail "$sinfo -p$test_part -O$option -h"]]
+	subtest [regexp -nocase $part_sinfo_vals($option) $output] "Verify partition $option field" "Expected $part_sinfo_vals($option) but observed $output"
 }
diff --git a/testsuite/expect/test4.14 b/testsuite/expect/test4.14
index a6279a3bd8..0c4afced08 100755
--- a/testsuite/expect/test4.14
+++ b/testsuite/expect/test4.14
@@ -37,14 +37,12 @@ if {![is_super_user]} {
 }
 
 proc delete_part { } {
-
-	global scontrol exit_code test_part_1 test_part_2
+	global scontrol test_part_1 test_part_2
 
 	spawn $scontrol delete partition=$test_part_1
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -54,8 +52,7 @@ proc delete_part { } {
 	spawn $scontrol delete partition=$test_part_2
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -63,6 +60,10 @@ proc delete_part { } {
 	}
 }
 
+proc cleanup {} {
+	delete_part
+}
+
 # Remove any vestigial Partitions
 delete_part
 
@@ -74,8 +75,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -86,8 +86,7 @@ expect {
 spawn $scontrol create partition=$test_part_1 nodes=$test_node
 expect {
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -97,8 +96,7 @@ expect {
 spawn $scontrol create partition=$test_part_2 nodes=$test_node
 expect {
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -118,8 +116,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -145,8 +142,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -174,8 +170,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -201,8 +196,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -226,8 +220,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -249,8 +242,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -271,8 +263,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -283,9 +274,6 @@ if {$match != 1} {
 	fail "sinfo should have produced an error ($match != 1)"
 }
 
-# Delete test partitions
-delete_part
-
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test4.2 b/testsuite/expect/test4.2
index d5ef6f642c..b9ea1a7fc6 100755
--- a/testsuite/expect/test4.2
+++ b/testsuite/expect/test4.2
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -46,8 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -57,6 +55,3 @@ expect {
 if {$matches != 2} {
 	fail "sinfo failed to report help message"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test4.3 b/testsuite/expect/test4.3
index afc5472c34..860e61a93a 100755
--- a/testsuite/expect/test4.3
+++ b/testsuite/expect/test4.3
@@ -80,8 +80,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -113,8 +112,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -174,8 +172,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -242,8 +239,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test4.4 b/testsuite/expect/test4.4
index 436240c613..6a4bf99171 100755
--- a/testsuite/expect/test4.4
+++ b/testsuite/expect/test4.4
@@ -63,8 +63,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -120,8 +119,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test4.5 b/testsuite/expect/test4.5
index 6eae6b8ae4..87419b9ba3 100755
--- a/testsuite/expect/test4.5
+++ b/testsuite/expect/test4.5
@@ -39,16 +39,23 @@ set mismatches   0
 # We start the node position of the array to 3 because the first 2 nodes will be
 # used for allocated state since scontrol cannot change node state to allocated
 set node_pos     2
+set tmp_id       0
+set tmp_sc       "test$test_id\_tmp_sc"
 array set node_list {}
 
+proc cleanup {} {
+	global tmp_sc
+
+	file delete $tmp_sc
+}
+
 proc change_state { state nodes } {
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol update nodename=$nodes state=$state reason=test
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -57,15 +64,13 @@ proc change_state { state nodes } {
 }
 
 proc reset_state { } {
-
-	global scontrol node_list node_pos exit_code
+	global scontrol node_list node_pos
 
 	foreach num [array names node_list] {
 		spawn $scontrol update nodename=$node_list($num) state=idle
 		expect {
 			timeout {
-				log_error "scontrol is not responding"
-				set exit_code 1
+				fail "scontrol is not responding"
 			}
 			eof {
 				wait
@@ -87,8 +92,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof  {
 		wait
@@ -117,8 +121,7 @@ expect {
 		}
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -133,8 +136,6 @@ if {$i != 8} {
 # Submit a job to filter for allocated job state
 #
 log_info "Testing ALLOCATED state"
-set tmp_id 0
-set tmp_sc "test$test_id\_tmp_sc"
 make_bash_script $tmp_sc "sleep 20"
 spawn $sbatch -p$partition -w$node_list(0),$node_list(1) -o/dev/null -n[expr 2 * $num_cpus] --exclusive $tmp_sc
 expect {
@@ -143,8 +144,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -178,8 +178,7 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -214,8 +213,7 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -242,8 +240,7 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -270,8 +267,7 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -286,8 +282,6 @@ reset_state
 if {$mismatches != 0} {
 	fail "sinfo node filtering error"
 }
-if {$exit_code == 0} {
-	file delete $tmp_sc
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test4.6 b/testsuite/expect/test4.6
index 6403e003be..2ab8724799 100755
--- a/testsuite/expect/test4.6
+++ b/testsuite/expect/test4.6
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
 set iteration    0
 
 #
@@ -46,8 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -57,6 +55,3 @@ expect {
 if {$iteration < 3} {
 	fail "sinfo iteration error"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test4.7 b/testsuite/expect/test4.7
index e5677096ae..c472726be4 100755
--- a/testsuite/expect/test4.7
+++ b/testsuite/expect/test4.7
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -49,8 +48,7 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -60,6 +58,3 @@ expect {
 if {$matches != 2} {
 	fail "sinfo failed to process verbose option"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test4.8 b/testsuite/expect/test4.8
index 815342a138..d18a637f07 100755
--- a/testsuite/expect/test4.8
+++ b/testsuite/expect/test4.8
@@ -45,8 +45,7 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -72,8 +71,7 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -99,8 +97,7 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test4.9 b/testsuite/expect/test4.9
index c364277906..b4124d10f6 100755
--- a/testsuite/expect/test4.9
+++ b/testsuite/expect/test4.9
@@ -46,8 +46,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
@@ -72,8 +71,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo not responding"
-		set exit_code 1
+		fail "sinfo not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test40.1 b/testsuite/expect/test40.1
index 094c64550d..78e4611409 100755
--- a/testsuite/expect/test40.1
+++ b/testsuite/expect/test40.1
@@ -29,7 +29,7 @@ source ./globals
 set exit_code   0
 set job_id      0
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 
 if {[llength [get_nodes_by_request "--gres=mps:100 -t1"]] == 0} {
 	skip "This test requires being able to submit job with --gres=mps:100"
@@ -52,8 +52,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -77,8 +76,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test40.2 b/testsuite/expect/test40.2
index b6ca63d4c5..038bb40127 100755
--- a/testsuite/expect/test40.2
+++ b/testsuite/expect/test40.2
@@ -26,7 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set skips       0
 set file_in1   "test$test_id.input1"
 set file_in2   "test$test_id.input2"
diff --git a/testsuite/expect/test40.3 b/testsuite/expect/test40.3
index f28bf1ad69..420c103d61 100755
--- a/testsuite/expect/test40.3
+++ b/testsuite/expect/test40.3
@@ -31,6 +31,12 @@ set file_in1       "test$test_id.input1"
 set file_in2       "test$test_id.input2"
 set file_out       "test$test_id.output"
 
+proc cleanup {} {
+	global bin_rm file_in1 file_in2 file_out
+
+	exec $bin_rm -f $file_in1 $file_in2 $file_out
+}
+
 #
 # Validate the job, batch step and step 0 of a job have the proper MPS counts
 # No step to test if step_mps == -1
@@ -259,8 +265,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -330,8 +335,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -349,8 +353,6 @@ if {[wait_for_job $job_id "DONE"] != 0} {
 test_out_file $file_out $target
 test_acct $job_id $target $target $req_mps $have_mps_types
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2 $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test40.4 b/testsuite/expect/test40.4
index 30a67922a1..c72280f743 100755
--- a/testsuite/expect/test40.4
+++ b/testsuite/expect/test40.4
@@ -39,6 +39,7 @@ set file_in        "test$test_id.input"
 set file_out1      "test$test_id.output1"
 set file_out2      "test$test_id.output2"
 set user           [get_my_user_name]
+set job_id1        0
 
 proc setup { mps_limit } {
 	global acct cluster exit_code user
@@ -65,12 +66,6 @@ proc setup { mps_limit } {
 	return 0
 }
 
-proc cleanup { } {
-	global acct
-
-	remove_acct "" $acct
-}
-
 set store_tres [string tolower [get_config_param "AccountingStorageTRES"]]
 set store_mps [string first "gres/mps:" $store_tres]
 if {$store_mps != -1} {
@@ -93,7 +88,7 @@ if {![check_config_select "cons_tres"]} {
 	skip "This test is only compatible with select/cons_tres"
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 log_debug "Default partition node count is $nb_nodes"
 if {$nb_nodes > 1} {
 	set nb_nodes 2
@@ -104,6 +99,14 @@ if {$mps_cnt < 100} {
 }
 log_debug "MPS count is $mps_cnt"
 
+proc cleanup {} {
+	global acct job_id1 bin_rm file_in file_out1 file_out2
+
+	remove_acct "" $acct
+	cancel_job $job_id1
+	exec $bin_rm -f $file_in $file_out1 $file_out2
+}
+
 # Remove any vestigial test account
 cleanup
 
@@ -135,7 +138,6 @@ if {$nb_nodes == 1} {
 } else {
 	set mps_fail_cnt [expr $mps_good_cnt + 1]
 }
-set job_id1 0
 spawn $sbatch --account=$acct --gres=craynetwork:0 --gres=mps:$mps_fail_cnt -N$nb_nodes -t1 -o $file_out1 -J "test$test_id" ./$file_in
 expect {
 	-re "Submitted batch job ($number)" {
@@ -143,8 +145,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -163,8 +164,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -193,8 +193,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -204,13 +203,7 @@ if {$match != 2} {
 	log_error "Job $job_id1 state is bad"
 	set exit_code 1
 }
-cancel_job $job_id1
-if {$exit_code != 0} {
-	fail "Unable to cancel job ($job_id1)"
-}
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out1 $file_out2
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test40.5 b/testsuite/expect/test40.5
index e257ccb049..4053d2c996 100755
--- a/testsuite/expect/test40.5
+++ b/testsuite/expect/test40.5
@@ -32,6 +32,18 @@ set file_in2         "test$test_id.input2"
 set file_in3         "test$test_id.input3"
 set file_out1        "test$test_id.output1"
 set file_out2        "test$test_id.output2"
+set job_id1          0
+set job_id2          0
+
+proc cleanup {} {
+	global bin_rm job_id2 file_in1 file_in2 file_in3 file_out1 file_out2
+
+	if {$job_id2 > 0} {
+		exec $bin_rm -f slurm_job_${job_id2}_resize.csh
+		exec $bin_rm -f slurm_job_${job_id2}_resize.sh
+	}
+	exec $bin_rm -f $file_in1 $file_in2 $file_in3 $file_out1 $file_out2
+}
 
 if {![param_contains [get_config_param "SchedulerParameters"] "permit_job_expansion"]} {
     skip "This test is only compatible with SchedulerParameters=permit_job_expansion"
@@ -99,7 +111,6 @@ echo 'HOST:'\$SLURMD_NODENAME 'CUDA_VISIBLE_DEVICES:'\$CUDA_VISIBLE_DEVICES 'CUD
 #
 # Submit job to expand: uses 10 gres/mps on one node
 #
-set job_id1 0
 spawn $sbatch -N1 --exclusive -J "test$test_id" -t2 --gres=mps:10 --output=$file_out1 $file_in1
 expect {
 	-re "Submitted batch job ($number)" {
@@ -107,8 +118,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -125,7 +135,6 @@ if {[wait_for_job $job_id1 "RUNNING"] != 0} {
 #
 # Submit job to give up resources: uses 10 gres/mps on one node
 #
-set job_id2 0
 spawn $sbatch -N1 --exclusive -J "test_child_$test_id" --dependency=expand:$job_id1 -t1 --gres=mps:10 --output=$file_out2 $file_in2
 expect {
 	-re "Submitted batch job ($number)" {
@@ -133,8 +142,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -229,10 +237,6 @@ expect {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2 $file_in3 $file_out1 $file_out2
-	exec $bin_rm -f slurm_job_${job_id2}_resize.csh
-	exec $bin_rm -f slurm_job_${job_id2}_resize.sh
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test40.6 b/testsuite/expect/test40.6
index c2b59eaebf..5c58b32596 100755
--- a/testsuite/expect/test40.6
+++ b/testsuite/expect/test40.6
@@ -31,6 +31,12 @@ set file_in1         "test$test_id.input1"
 set file_in2         "test$test_id.input2"
 set file_out         "test$test_id.output"
 
+proc cleanup {} {
+	global bin_rm file_in1 file_in2 file_out
+
+	exec $bin_rm -f $file_in1 $file_in2 $file_out
+}
+
 if {![check_config_select "cons_tres"]} {
     skip "This test is only compatible with select/cons_tres"
 }
@@ -82,8 +88,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -155,8 +160,6 @@ if {$exit_code == 0 && $constrain_devices == 0} {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in1 $file_in2 $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test40.8 b/testsuite/expect/test40.8
index abf655c15f..b752ac2b7c 100755
--- a/testsuite/expect/test40.8
+++ b/testsuite/expect/test40.8
@@ -32,6 +32,12 @@ set file_out    "test$test_id.output"
 set file_prog   "test$test_id.prog"
 set job_id      0
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_prog
+
+	exec $bin_rm -f $file_in $file_out $file_prog
+}
+
 if {![check_config_select "cons_tres"]} {
     skip "This test is only compatible with select/cons_tres"
 }
@@ -64,8 +70,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -163,8 +168,6 @@ if {[wait_for_file $file_out] == 0} {
 	fail "Output file failed to appear ($file_out)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_prog
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test41.1 b/testsuite/expect/test41.1
new file mode 100755
index 0000000000..5859f1fdb2
--- /dev/null
+++ b/testsuite/expect/test41.1
@@ -0,0 +1,37 @@
+#!/usr/bin/env expect
+############################################################################
+# Purpose: Test of Slurm functionality
+#          Test of slurmrestd basic functionality.
+############################################################################
+# Copyright (C) 2020 SchedMD LLC
+# Written by Nathan Rini <nate@schedmd.gov>
+#
+# This file is part of Slurm, a resource management program.
+# For details, see <https://slurm.schedmd.com/>.
+# Please also read the included file: DISCLAIMER.
+#
+# Slurm is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# Slurm is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+# details.
+#
+# You should have received a copy of the GNU General Public License along
+# with Slurm; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+############################################################################
+source ./globals
+
+if {![file exists $slurmrestd]} {
+	skip "slurmrestd not installed"
+}
+
+run_command -subtest        "$slurmrestd -h"
+run_command -subtest        "$slurmrestd -h"
+run_command -subtest -xfail "$slurmrestd --invalid"
+run_command -subtest -xfail "$slurmrestd -a invalid_plugin"
+run_command -subtest -xfail "$slurmrestd -s invalid_plugin"
diff --git a/testsuite/expect/test5.1 b/testsuite/expect/test5.1
index c86e69b0dd..64964e636f 100755
--- a/testsuite/expect/test5.1
+++ b/testsuite/expect/test5.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$matches != 1} {
 	fail "squeue failed to report usage format"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test5.10 b/testsuite/expect/test5.10
index 0e30c6b809..eaa119f5a8 100755
--- a/testsuite/expect/test5.10
+++ b/testsuite/expect/test5.10
@@ -34,18 +34,29 @@ set test_part_1   "test$test_id\_part1"
 set test_part_2   "test$test_id\_part2"
 set exit_code     0
 
+proc cleanup {} {
+	global test_part_1 test_part_2 job_id bin_rm file_in
+
+	# Delete test partitions
+	delete_part $test_part_1
+	delete_part $test_part_2
+
+	cancel_job $job_id
+
+	exec $bin_rm $file_in
+}
+
 if {![is_super_user]} {
 	skip "Can not test more unless SlurmUser"
 }
 
 proc create_part { name prio } {
-	global scontrol nodes exit_code
+	global scontrol nodes
 
 	spawn $scontrol create partitionname=$name priority=$prio nodes=$nodes
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -60,8 +71,7 @@ proc create_part { name prio } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -74,13 +84,12 @@ proc create_part { name prio } {
 }
 
 proc change_prio { name prio } {
-	global scontrol nodes exit_code
+	global scontrol nodes
 
 	spawn $scontrol update partitionname=$name priority=$prio
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -95,8 +104,7 @@ proc delete_part { name } {
 	spawn $scontrol delete partition=$name
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -112,8 +120,7 @@ proc delete_part { name } {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -128,8 +135,7 @@ proc delete_part { name } {
 }
 
 proc sub_job { } {
-
-	global sbatch test_part_1 test_part_2 file_in job_id exit_code
+	global sbatch test_part_1 test_part_2 file_in job_id
 	global number
 
 	set job_id 0
@@ -141,8 +147,7 @@ proc sub_job { } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -167,15 +172,14 @@ if {[string length [default_partition]] == 0} {
 
 # Get a list of nodes
 set timeout $max_job_delay
-spawn $bin_bash -c "exec $srun -t1 -N[available_nodes idle] $bin_printenv | $bin_grep NODE"
+spawn $bin_bash -c "exec $srun -t1 -N[llength [get_nodes_by_state]] $bin_printenv | $bin_grep NODE"
 expect {
 	-re "SLURM_NODELIST=($re_word_str)" {
 		set nodes $expect_out(1,string)
 		exp_continue
 	}
 	timeout {
-		log_error "srun is not responding"
-		set exit_code 1
+		fail "srun is not responding"
 	}
 	eof {
 		wait
@@ -208,8 +212,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -243,8 +246,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -268,8 +270,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -293,8 +294,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -307,14 +307,6 @@ if {$part_chk != 1} {
 	log_debug "Job $job_id is RUNNING in partition $test_part_1 as expected"
 }
 
-cancel_job $job_id
-
-# Delete test partitions
-delete_part $test_part_1
-delete_part $test_part_2
-
-if {$exit_code == 0} {
-	exec $bin_rm $file_in
-} else {
-	fail "Test failed due to previous errors"
+if {$exit_code != 0} {
+	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test5.11 b/testsuite/expect/test5.11
index 6b1a7c3766..993a97870d 100755
--- a/testsuite/expect/test5.11
+++ b/testsuite/expect/test5.11
@@ -41,6 +41,14 @@ set node_h           ""
 set cpu_h_cnt        0
 set test_part        "test$test_id\_part"
 
+proc cleanup {} {
+	global job_id scontrol test_part bin_rm script
+
+	cancel_job $job_id
+	exec $scontrol delete partition=$test_part
+	exec $bin_rm -fr $script
+}
+
 make_bash_script $script "
 sleep 10
 "
@@ -52,8 +60,7 @@ if {![is_super_user]} {
 }
 
 proc sub_job { cpu_cnt part } {
-
-	global sbatch script job_id number exit_code
+	global sbatch script job_id number
 
 	set job_id 0
 	spawn $sbatch -t1 -H -p$part -n$cpu_cnt -o/dev/null $script
@@ -63,8 +70,7 @@ proc sub_job { cpu_cnt part } {
 			exp_continue
 		}
 		timeout {
-			log_error "sbatch is not responding"
-			set exit_code 1
+			fail "sbatch is not responding"
 		}
 		eof {
 			wait
@@ -77,7 +83,6 @@ proc sub_job { cpu_cnt part } {
 }
 
 proc check_node_cnt { exp_nodes } {
-
 	global squeue exit_code
 
 	set match 0
@@ -88,8 +93,7 @@ proc check_node_cnt { exp_nodes } {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -103,14 +107,12 @@ proc check_node_cnt { exp_nodes } {
 }
 
 proc update_job { job_id part } {
-
-	global scontrol exit_code
+	global scontrol
 
 	spawn $scontrol update jobid=$job_id partition=$part
 	expect {
 		timeout {
-			log_error "scontrol is not responding"
-			set exit_code 1
+			fail "scontrol is not responding"
 		}
 		eof {
 			wait
@@ -134,8 +136,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -153,8 +154,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -232,8 +232,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -252,8 +251,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sinfo is not responding"
-		set exit_code 1
+		fail "sinfo is not responding"
 	}
 	eof {
 		wait
@@ -267,9 +265,6 @@ if {$cpu_l_cnt == $cpu_h_cnt} {
 		each with different cpu counts -- finishing test now."
 
 	exec $bin_rm -fr $script
-	if {$exit_code != 0} {
-		fail "Test failed due to prior errors"
-	}
 	pass
 }
 
@@ -351,21 +346,6 @@ sub_job $cpu_test_cnt $default_part
 sleep 4
 test_and_check $job_id $test_part $exp_nodes
 
-sleep 4
-cancel_job $job_id
-
-spawn $scontrol delete partition=$test_part
-expect {
-	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
-	}
-	eof {
-		wait
-	}
-}
-
-exec $bin_rm -fr $script
 if {$exit_code != 0} {
-	fail "Test failed due to previous errors"
+	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test5.2 b/testsuite/expect/test5.2
index 8bd7d74400..8ea1bb2060 100755
--- a/testsuite/expect/test5.2
+++ b/testsuite/expect/test5.2
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -46,8 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -57,6 +55,3 @@ expect {
 if {$matches != 2} {
 	fail "squeue failed to report help message"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test5.3 b/testsuite/expect/test5.3
index b3a9978e92..bef2b8c834 100755
--- a/testsuite/expect/test5.3
+++ b/testsuite/expect/test5.3
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set iteration    0
 
 #
@@ -54,8 +53,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -65,6 +63,3 @@ expect {
 if {$iteration < 3} {
 	fail "squeue iteration error"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test5.4 b/testsuite/expect/test5.4
index ac2e4c32c8..1a23312cc5 100755
--- a/testsuite/expect/test5.4
+++ b/testsuite/expect/test5.4
@@ -35,6 +35,13 @@ set job_id1      0
 set job_id2      0
 set step_id      0
 
+proc cleanup {} {
+	global job_id1 job_id2
+
+	cancel_job $job_id1
+	cancel_job $job_id2
+}
+
 #
 # Delete left-over input script
 # Build input script file
@@ -99,9 +106,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
 		cancel_job $job_id2
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -133,8 +139,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -169,8 +174,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -210,8 +214,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -222,12 +225,6 @@ if {$step_found == 0} {
 	fail "squeue step format error"
 }
 
-if {[cancel_job $job_id1] != 0} {
-	fail "Unable to cancel job ($job_id1)"
-}
-if {[cancel_job $job_id2] != 0} {
-	fail "Unable to cancel job ($job_id2)"
-}
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test5.5 b/testsuite/expect/test5.5
index 6a7a436290..693596aaf4 100755
--- a/testsuite/expect/test5.5
+++ b/testsuite/expect/test5.5
@@ -35,6 +35,14 @@ set job_id2      0
 set job_name1    "job_b"
 set job_name2    "job_a"
 
+proc cleanup {} {
+	global job_id1 job_id2 bin_rm file_in
+
+	cancel_job $job_id1
+	cancel_job $job_id2
+	exec $bin_rm -f $file_in
+}
+
 #
 # Build input script file
 #
@@ -79,8 +87,6 @@ if {$job_id2 == 0} {
 	fail "srun job submit failure"
 }
 
-exec $bin_rm -f $file_in
-
 #
 # Check the squeue sort output
 #
@@ -100,20 +106,13 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {[cancel_job $job_id1] != 0} {
-	fail "Unable to cancel job ($job_id1)"
-}
-if {[cancel_job $job_id2] != 0} {
-	fail "Unable to cancel job ($job_id2)"
-}
 if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test5.6 b/testsuite/expect/test5.6
index 779b3dc7cb..c5d6b86a4c 100755
--- a/testsuite/expect/test5.6
+++ b/testsuite/expect/test5.6
@@ -38,7 +38,18 @@ set job_name1    "test$test_id.job1"
 set job_name2    "test$test_id.job2"
 set node_cnt 1-1
 
-if {[job_submit_all_partitions] != 0} {
+proc cleanup {} {
+	global job_id1 job_id2 bin_rm file_in
+
+	#
+	# Cancel jobs and remove files
+	#
+	cancel_job $job_id1
+	cancel_job $job_id2
+	exec $bin_rm -f $file_in
+}
+
+if {[param_contains [get_config_param "JobSubmitPlugins"] "all_partitions"]} {
 	skip "This test is incompatible with JobSubmitPlugins=all_partitions"
 }
 
@@ -105,8 +116,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -130,8 +140,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -154,8 +163,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -177,8 +185,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -198,8 +205,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -220,8 +226,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -235,8 +240,7 @@ if {$node_name_set == 1} {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue not responding"
-			set exit_code 1
+			fail "squeue not responding"
 		}
 		eof {
 			wait
@@ -267,8 +271,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -287,8 +290,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -319,8 +321,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -348,8 +349,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -374,8 +374,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -386,18 +385,6 @@ if {$job_found == 0} {
 	set exit_code 1
 }
 
-#
-# Cancel jobs and remove files
-#
-if {[cancel_job $job_id1] != 0} {
-	fail "Unable to cancel job ($job_id1)"
-}
-if {[cancel_job $job_id2] != 0} {
-	fail "Unable to cancel job ($job_id2)"
-}
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
-
diff --git a/testsuite/expect/test5.7 b/testsuite/expect/test5.7
index d17ffec451..4d8663a202 100755
--- a/testsuite/expect/test5.7
+++ b/testsuite/expect/test5.7
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -49,8 +48,7 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -60,6 +58,3 @@ expect {
 if {$matches != 2} {
 	fail "squeue failed to process verbose option"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test5.8 b/testsuite/expect/test5.8
index e05cbc2fb7..084174b237 100755
--- a/testsuite/expect/test5.8
+++ b/testsuite/expect/test5.8
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set version     0
 
 #
@@ -41,9 +40,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue not responding"
-		set exit_code 1
-		exp_continue
+		fail "squeue not responding"
 	}
 	eof {
 		wait
@@ -53,6 +50,3 @@ expect {
 if {$version != 1} {
 	fail "Did not get proper squeue version number"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test5.9 b/testsuite/expect/test5.9
index f6dd797db3..3034a74089 100755
--- a/testsuite/expect/test5.9
+++ b/testsuite/expect/test5.9
@@ -92,11 +92,21 @@ if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"}
 if {[string compare [get_admin_level] "Administrator"]} {
 	skip "This test can't be run without being an Accounting administrator"
 }
-set available [available_nodes idle]
+set available [llength [get_nodes_by_state]]
 if {$available < 2} {
     skip "Not enough nodes currently available ($available avail, 2 needed)"
 }
 
+proc cleanup {} {
+	global job_id test_acct bin_rm file_err file_out file_in
+
+	cancel_job $job_id
+
+	remove_acct "" $test_acct
+
+	exec $bin_rm -f $file_err $file_out $file_in
+}
+
 remove_acct [get_config_param "ClusterName"] $test_acct
 
 # Run a job to get a usable node to test
@@ -112,8 +122,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -139,8 +148,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -196,8 +204,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -216,8 +223,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sacctmgr is not responding"
-		set exit_code 1
+		fail "sacctmgr is not responding"
 	}
 	eof {
 		wait
@@ -249,8 +255,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch is not responding"
-		set exit_code 1
+		fail "sbatch is not responding"
 	}
 	eof {
 		wait
@@ -280,8 +285,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -306,8 +310,7 @@ foreach option [array names sq_format] {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -336,8 +339,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "squeue is not responding"
-		set exit_code 1
+		fail "squeue is not responding"
 	}
 	eof {
 		wait
@@ -393,8 +395,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol is not responding"
-		set exit_code 1
+		fail "scontrol is not responding"
 	}
 	eof {
 		wait
@@ -419,8 +420,7 @@ foreach option [array names sq_step_format] {
 			exp_continue
 		}
 		timeout {
-			log_error "squeue is not responding"
-			set exit_code 1
+			fail "squeue is not responding"
 		}
 		eof {
 			wait
@@ -437,16 +437,6 @@ if {$match != $cnt} {
 	set exit_code 1
 }
 
-cancel_job $job_id
-if {[wait_for_job $job_id "DONE"] != 0} {
-	log_error "Error waiting for job $job_id to complete"
-	set exit_code 1
-}
-
-remove_acct "" $test_acct
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_err $file_out $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test6.1 b/testsuite/expect/test6.1
index 6906e0cc21..a7b679dccc 100755
--- a/testsuite/expect/test6.1
+++ b/testsuite/expect/test6.1
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$matches != 1} {
 	fail "scancel failed to report usage format"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test6.10 b/testsuite/expect/test6.10
index c8a9930989..34e234d81a 100755
--- a/testsuite/expect/test6.10
+++ b/testsuite/expect/test6.10
@@ -37,7 +37,13 @@ set exit_code     0
 set file_in       "test$test_id.input"
 set job_id        0
 
-if {[job_submit_all_partitions] != 0} {
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
+if {[param_contains [get_config_param "JobSubmitPlugins"] "all_partitions"]} {
 	skip "This test is incompatible with JobSubmitPlugins=all_partitions"
 }
 
@@ -62,9 +68,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -86,8 +91,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -110,8 +114,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -131,8 +134,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -142,8 +144,7 @@ expect {
 spawn $scancel --verbose --user=$my_login
 expect {
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -158,8 +159,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -169,8 +169,6 @@ if {$matches != 0} {
 	fail "scancel user filter failed"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test6.11 b/testsuite/expect/test6.11
index b58e85b996..07c12d3474 100755
--- a/testsuite/expect/test6.11
+++ b/testsuite/expect/test6.11
@@ -32,6 +32,12 @@ set exit_code    0
 set file_in      "test$test_id.input"
 set job_id       0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 make_bash_script $file_in { $bin_id }
 
 #
@@ -44,9 +50,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -66,8 +71,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -86,8 +90,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -107,16 +110,13 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test6.12 b/testsuite/expect/test6.12
index 704c221a05..4b68f33f7d 100755
--- a/testsuite/expect/test6.12
+++ b/testsuite/expect/test6.12
@@ -34,11 +34,16 @@ source ./globals
 set file_in     "test$test_id.input"
 set file_out    "test$test_id.output"
 set file_err    "test$test_id.error"
-
 set exit_code   0
 set job_id      0
 set step_id	0
 
+proc cleanup {} {
+	global bin_rm file_in file_out file_err
+
+	exec $bin_rm -f $file_in $file_out $file_err
+}
+
 #
 # Delete left-over input script plus stdout/err files
 #
@@ -291,8 +296,6 @@ if {[cancel_job $job_id] != 0} {
 	fail "Unable to cancel job ($job_id)"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out $file_err
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test6.13 b/testsuite/expect/test6.13
index 35e59b1daa..9af9b5fe39 100755
--- a/testsuite/expect/test6.13
+++ b/testsuite/expect/test6.13
@@ -34,6 +34,12 @@ set file_in      "test$test_id.input"
 set file_out     "test$test_id.output"
 set file_prog    "test$test_id.prog"
 
+proc cleanup {} {
+	global file_in file_out file_prog
+
+	exec rm -f $file_in $file_out $file_prog
+}
+
 #
 # Cannot run the test if OverTimeLimit is set, since we test time limits.
 #
@@ -64,10 +70,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
-		exp_continue
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -104,8 +108,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -174,10 +177,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
-		exp_continue
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -210,8 +211,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -254,8 +254,6 @@ if {[wait_for_file $file_out] == 0} {
 	fail "Output file ($file_out) did not appear"
 }
 
-if {$exit_code == 0} {
-	exec rm -f $file_in $file_out $file_prog
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test6.14 b/testsuite/expect/test6.14
index 8d722e0d5d..df2b961263 100755
--- a/testsuite/expect/test6.14
+++ b/testsuite/expect/test6.14
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code      0
 set file_in        "test$test_id.input"
 set num_procs      10
 set ii             0
@@ -169,6 +168,3 @@ for {set ii 0} {$ii < [llength $job_map]} {incr ii} {
 		fail "scancel did not remove jobs $job_list from node $node_name"
 	}
 }
-
-
-fail_on_error "Test failed due to previous errors (\$exit_code = $exit_code)"
diff --git a/testsuite/expect/test6.16 b/testsuite/expect/test6.16
index 6aec9e8343..333b00e0ba 100755
--- a/testsuite/expect/test6.16
+++ b/testsuite/expect/test6.16
@@ -33,6 +33,12 @@ set exit_code   0
 set file_in     "test$test_id.input"
 set job_id      0
 
+proc cleanup {} {
+	global file_in
+
+	exec rm -f $file_in
+}
+
 #
 # Build input script file
 #
@@ -92,8 +98,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -103,8 +108,6 @@ if {$matches != 3} {
 	fail "scancel with multiple step_id failed"
 }
 
-if {$exit_code == 0} {
-	exec rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test6.17 b/testsuite/expect/test6.17
index 5b29cb7635..cd62345510 100755
--- a/testsuite/expect/test6.17
+++ b/testsuite/expect/test6.17
@@ -39,8 +39,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -63,8 +62,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -87,8 +85,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -100,5 +97,5 @@ if {$matches != 1} {
 }
 
 if {$exit_code != 0} {
-	fail "Test failed due to previous errors"
+	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test6.2 b/testsuite/expect/test6.2
index ea12080b88..3c5423a554 100755
--- a/testsuite/expect/test6.2
+++ b/testsuite/expect/test6.2
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set matches     0
 
 #
@@ -46,8 +45,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -57,6 +55,3 @@ expect {
 if {$matches != 2} {
 	fail "scancel failed to report help message"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test6.3 b/testsuite/expect/test6.3
index 9de5e1afe5..41a6559499 100755
--- a/testsuite/expect/test6.3
+++ b/testsuite/expect/test6.3
@@ -33,6 +33,12 @@ set file_in      "test$test_id.input"
 set job_id1      0
 set matches      0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 #
 # Build input script file
 #
@@ -48,9 +54,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -78,8 +83,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -98,8 +102,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -114,8 +117,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -125,9 +127,7 @@ expect {
 if {$matches != 3} {
 	fail "scancel interactive option failed"
 }
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
 
diff --git a/testsuite/expect/test6.4 b/testsuite/expect/test6.4
index 2600ca0e90..a37fe5eb32 100755
--- a/testsuite/expect/test6.4
+++ b/testsuite/expect/test6.4
@@ -50,9 +50,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -69,9 +68,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -96,8 +94,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -117,8 +114,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test6.5 b/testsuite/expect/test6.5
index 3bf9c602f2..46fd553018 100755
--- a/testsuite/expect/test6.5
+++ b/testsuite/expect/test6.5
@@ -92,8 +92,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -112,8 +111,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test6.6 b/testsuite/expect/test6.6
index 55f7ebd2fb..3f2764e7e4 100755
--- a/testsuite/expect/test6.6
+++ b/testsuite/expect/test6.6
@@ -28,7 +28,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set version     0
 
 #
@@ -42,8 +41,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -53,6 +51,3 @@ expect {
 if {$version != 1} {
 	fail "Did not get proper scancel version number"
 }
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test6.7 b/testsuite/expect/test6.7
index eec4c93759..6e95f25d0c 100755
--- a/testsuite/expect/test6.7
+++ b/testsuite/expect/test6.7
@@ -34,6 +34,12 @@ set file_out     "test$test_id.output"
 set file_out2    "test$test_id.output2"
 set file_prog    "test$test_id.prog"
 
+proc cleanup {} {
+	global file_in file_out2 file_prog
+
+	exec rm -f $file_in $file_out2 $file_prog
+}
+
 #
 # Cannot run the test if OverTimeLimit is set, since we test time limits.
 #
@@ -64,9 +70,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -103,8 +108,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -174,10 +178,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill sbatch_pid
-		set exit_code 1
-		exp_continue
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -210,8 +212,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -246,9 +247,7 @@ if {[wait_for_file $file_out2] == 0} {
 	set exit_code 1
 }
 
-if {$exit_code == 0} {
-	exec rm -f $file_in $file_out2 $file_prog
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
 
diff --git a/testsuite/expect/test6.8 b/testsuite/expect/test6.8
index 2b7b90ebbe..58508f362b 100755
--- a/testsuite/expect/test6.8
+++ b/testsuite/expect/test6.8
@@ -51,9 +51,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -70,9 +69,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $sbatch_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -107,8 +105,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -135,8 +132,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
diff --git a/testsuite/expect/test6.9 b/testsuite/expect/test6.9
index adb389a712..5a5c4d0ecb 100755
--- a/testsuite/expect/test6.9
+++ b/testsuite/expect/test6.9
@@ -35,6 +35,12 @@ set exit_code   0
 set file_in     "test$test_id.input"
 set job_id      0
 
+proc cleanup {} {
+	global file_in
+
+	exec rm -f $file_in
+}
+
 #
 # Build input script file
 # The "sleep 1" ensures the background tasks is step 0 and foreground tasks is step 1
@@ -85,8 +91,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -106,8 +111,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scancel not responding"
-		set exit_code 1
+		fail "scancel not responding"
 	}
 	eof {
 		wait
@@ -117,8 +121,6 @@ if {$matches != 1} {
 	fail "scancel with step_id failed"
 }
 
-if {$exit_code == 0} {
-	exec rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test7.1 b/testsuite/expect/test7.1
index d563dab013..31b9cb0416 100755
--- a/testsuite/expect/test7.1
+++ b/testsuite/expect/test7.1
@@ -38,8 +38,14 @@ set prio2                -1
 set prio3                -1
 set multi                0
 
+proc cleanup {} {
+	global bin_rm file_in
+
+	exec $bin_rm -f $file_in
+}
+
 # expected outcome is different under multifactor rule
-if { ![string compare [priority_type] multifactor] } {
+if {[get_config_param "PriorityType"] eq "priority/multifactor"} {
 	set multi 1
 }
 
@@ -104,9 +110,8 @@ if {$job_id1 != 0} {
 			exp_continue
 		}
 		timeout {
-			log_error "scontrol not responding"
 			cancel_job $job_id1
-			set exit_code   1
+			fail "scontrol not responding"
 		}
 		eof {
 			wait
@@ -126,9 +131,8 @@ if {$job_id2 != 0} {
             exp_continue
         }
         timeout {
-            log_error "scontrol not responding"
             cancel_job $job_id2
-            set exit_code   1
+            fail "scontrol not responding"
         }
         eof {
 			wait
@@ -148,9 +152,8 @@ if {$job_id3 != 0} {
             exp_continue
         }
         timeout {
-            log_error "scontrol not responding"
             cancel_job $job_id3
-            set exit_code   1
+            fail "scontrol not responding"
         }
         eof {
 			wait
@@ -181,8 +184,6 @@ if {$prio3 != 0} {
 	fail "Held job has non-zero priority: $prio3"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test7.10 b/testsuite/expect/test7.10
index 5d4d4cc4f5..d90a98a2bb 100755
--- a/testsuite/expect/test7.10
+++ b/testsuite/expect/test7.10
@@ -32,6 +32,12 @@ source ./globals
 set exit_code            0
 set ld_preload           "ld_preload"
 
+proc cleanup {} {
+	global bin_rm ld_preload
+
+	exec $bin_rm -f ${ld_preload}.c ${ld_preload}.lo ${ld_preload}.so
+}
+
 if [is_super_user] {
 	skip "This test can't be run as SlurmUser"
 }
@@ -67,17 +73,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f ${ld_preload}.c ${ld_preload}.lo ${ld_preload}.so
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test7.11 b/testsuite/expect/test7.11
index 62c4aaf2ed..ea00719231 100755
--- a/testsuite/expect/test7.11
+++ b/testsuite/expect/test7.11
@@ -29,7 +29,6 @@
 source ./globals
 
 set cwd		    "[$bin_pwd]"
-set exit_code	    0
 set file_in         "${cwd}/test${test_id}.in"
 set file_out	    "${cwd}/test${test_id}.out"
 set file_prog	    "${cwd}/test${test_id}.prog"
@@ -44,9 +43,10 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
 	skip "This test is incompatible with front-end systems"
 }
 
-proc end_it { exit_code } {
+proc cleanup {} {
 	global test_id orig_spank_conf spank_conf_file new_spank_conf spank_out
 	global file_out spank_out bin_cp bin_rm file_in file_prog
+
 	#
 	# Restore the original plugstack
 	#
@@ -57,13 +57,7 @@ proc end_it { exit_code } {
 	}
 	reconfigure
 
-	if {$exit_code == 0} {
-		exec $bin_rm -f $orig_spank_conf $new_spank_conf $file_in $file_out $spank_out ${file_prog}.so
-	}
-	if {$exit_code != 0} {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
-	pass
+	exec $bin_rm -f $orig_spank_conf $new_spank_conf $file_in $file_out $spank_out ${file_prog}.so
 }
 
 #
@@ -143,7 +137,7 @@ expect {
 		wait
 	}
 }
-reconfigure
+reconfigure -fail
 
 #
 # Test of srun help message
@@ -167,17 +161,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 2} {
-	log_error "Spank help message not in srun help message"
-	end_it 1
+	fail "Spank help message not in srun help message"
 }
 
 #
@@ -198,17 +190,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "salloc not responding"
 		slow_kill $srun_pid
-		end_it 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "spank help message not in salloc help message ($matches != 1)"
-	end_it 1
+	fail "Spank help message not in salloc help message ($matches != 1)"
 }
 
 #
@@ -229,17 +219,15 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		end_it 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 1} {
-	log_error "spank help message not in sbatch help message ($matches != 1)"
-	end_it 1
+	fail "Spank help message not in sbatch help message ($matches != 1)"
 }
 
 #
@@ -257,8 +245,7 @@ log_debug "Checksum of local $spank_conf_file"
 spawn $bin_sum $spank_conf_file
 expect {
 	-re timeout {
-		log_error "sbatch not responding"
-		end_it 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -293,29 +280,25 @@ expect {
 		exp_continue
 	}
 	-re timeout {
-		log_error "sbatch not responding"
-		end_it 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$job_id == 0} {
-	log_error "Batch submit failure"
-	end_it 1
+	fail "Batch submit failure"
 }
 if {$matches != 2} {
-	log_error "spank options not processed by sbatch ($matches != 2)"
-	end_it 1
+	fail "Spank options not processed by sbatch ($matches != 2)"
 }
 
 #
 # Wait for job to complete and check for files
 #
 if {[wait_for_job $job_id "DONE"] != 0} {
-	log_error "Waiting for job to complete"
 	cancel_job $job_id
-	end_it 1
+	fail "Waiting for job to complete"
 }
 
 # NOTE: spank logs from sbatch and srun would be intermingled here
@@ -326,8 +309,7 @@ if {[wait_for_file $file_out] == 0} {
 	spawn $bin_cat $file_out
 	expect {
 		-re "error" {
-			log_error "Some error happened"
-			end_it 1
+			fail "Some error happened"
 		}
 		-re "_test_opt_process_(.*?=$number)" {
 			set substr $expect_out(1,string)
@@ -351,19 +333,16 @@ if {[wait_for_file $file_out] == 0} {
 		}
 	}
 	if {$matches_sbatch != 1} {
-		log_error "Local (srun) sbatch spank plugin failure ($matches_sbatch != 1)"
-		end_it 1
+		fail "Local (srun) sbatch spank plugin failure ($matches_sbatch != 1)"
 	} elseif {$matches_srun != 1} {
-		log_error "Local (srun) srun spank plugin failure ($matches_srun != 1)"
-		end_it 1
+		fail "Local (srun) srun spank plugin failure ($matches_srun != 1)"
 	} elseif {$matches != 2} {
-		log_error "Local (srun) spank plugin failure ($matches != 2)"
-		end_it 1
+		fail "Local (srun) spank plugin failure ($matches != 2)"
 	} else {
 		log_debug "Local (srun) spank plugin success"
 	}
 } else {
-	end_it 1
+	fail "Job output file ($file_out) did not appear"
 }
 
 #
@@ -391,8 +370,7 @@ if {[wait_for_file $spank_out] == 0} {
 			incr expected_spank_exit
 		}
 		timeout {
-			log_error "scontrol show config not responding"
-			end_it 1
+			fail "scontrol show config not responding"
 		}
 		eof {
 			wait
@@ -455,12 +433,19 @@ if {[wait_for_file $spank_out] == 0} {
 		set fail_cnt 1
 	}
 	if {$fail_cnt != 0} {
-		log_warn "Check for matching checksums on the plugstack.conf file. Different checksums could indicate file system delays"
-		end_it 1
+		fail "Check for matching checksums on the plugstack.conf file. Different checksums could indicate file system delays"
 	}
 	log_debug "Remote (slurmd) spank plugin success"
 } else {
-	end_it 1
+	fail "Spank output file ($spank_out) was not created"
 }
 
-end_it $exit_code
+#Test if internal spank option parsing works (Bug 10454)
+set output [run_command_output -timeout 2 -xfail -subtest "$sbatch --test_suite_sbatch=NaN --wrap='/bin/true'"]
+subtest {[regexp "sbatch: error: Non-zero argument required" $output]} "sbatch should print error message from spank"
+
+set output [run_command_output -timeout 2 -xfail -subtest "$salloc --test_suite_sbatch=NaN"]
+subtest {[regexp "salloc: error: Non-zero argument required" $output]} "salloc should print error message from spank"
+
+set output [run_command_output -timeout 2 -xfail -subtest "$srun --test_suite_sbatch=NaN"]
+subtest {[regexp "srun: error: Non-zero argument required" $output]} "srun should print error message from spank"
diff --git a/testsuite/expect/test7.11.prog.c b/testsuite/expect/test7.11.prog.c
index e98a69fe40..d7c518a82a 100644
--- a/testsuite/expect/test7.11.prog.c
+++ b/testsuite/expect/test7.11.prog.c
@@ -65,7 +65,7 @@ struct spank_option spank_options_reg[] =
 {
 	{ "test_suite_sbatch",
 	  "[opt_arg_sbatch]",
-	  "Registered component of slurm test suite.",
+	  "Registered component of slurm test suite. Has to be non-zero int",
 	  2,
 	  0,
 	  _test_opt_process_sbatch
@@ -85,6 +85,12 @@ static int _test_opt_process_srun(int val, const char *optarg, int remote)
 static int _test_opt_process_sbatch(int val, const char *optarg, int remote)
 {
 	opt_arg_sbatch = atoi(optarg);
+	/* Verify if option is a non-zero number */
+	if (!opt_arg_sbatch) {
+		slurm_error("Non-zero argument required");
+		return -1;
+	}
+
 	if (!remote)
 		slurm_info("%s: opt_arg_sbatch=%d", __func__, opt_arg_sbatch);
 
diff --git a/testsuite/expect/test7.12 b/testsuite/expect/test7.12
index a8f05fa5b1..47e0b98816 100755
--- a/testsuite/expect/test7.12
+++ b/testsuite/expect/test7.12
@@ -31,13 +31,19 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set file_in     "test$test_id.input"
 set job_id      0
 set step_id	0
 set pid_count	1
 set test_prog   "test$test_id.prog"
 
+proc cleanup {} {
+	global job_id file_in test_prog
+
+	cancel_job $job_id
+	file delete $file_in $test_prog
+}
+
 if {[get_config_param "FrontendName"] ne "MISSING"} {
     skip "This test is incompatible with front-end systems"
 }
@@ -49,8 +55,9 @@ file delete $file_in $test_prog
 make_bash_script $file_in "
   $srun $bin_sleep 120
 "
-compile_against_libslurm ${test_prog}
-fail_on_error "Cannot compile test program"
+if [compile_against_libslurm ${test_prog}] {
+	fail "Cannot compile test program"
+}
 
 #
 # Spawn program via sbatch
@@ -62,9 +69,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "sbatch not responding"
-		set exit_code 1
-		exp_continue
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
@@ -111,9 +116,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "Spawn IO not responding"
 		cancel_job $job_id
-		set exit_code 1
+		fail "Spawn IO not responding"
 	}
 	eof {
 		wait
@@ -129,10 +133,3 @@ if {$pid_matches != $pid_count} {
 if {$job_matches != 1} {
 	fail "Failed to load job info for this job ($job_matches != 1)"
 }
-
-cancel_job $job_id
-if {$exit_code == 0} {
-	file delete $file_in $test_prog
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test7.13 b/testsuite/expect/test7.13
index 8ddd237129..0585688024 100755
--- a/testsuite/expect/test7.13
+++ b/testsuite/expect/test7.13
@@ -27,11 +27,16 @@
 ############################################################################
 source ./globals
 
-set exit_code        0
 set file_in          "test$test_id.input"
 set file_prog1       "test$test_id.prog1"
 set file_prog2       "test$test_id.prog2"
 
+proc cleanup {} {
+	global bin_rm file_in file_prog1 file_prog2
+
+	exec $bin_rm -f $file_in $file_prog1 $file_prog2
+}
+
 set accounting_storage_enforce [get_config_param "AccountingStorageEnforce"]
 if {[param_contains $accounting_storage_enforce "nosteps"] || [param_contains $accounting_storage_enforce "nojobs"]} {
 	skip "This test can not be run with nosteps or nojobs (AccoutingStorageEnforce)"
@@ -252,9 +257,3 @@ if {[get_config_param "AccountingStorageType"] eq "accounting_storage/slurmdbd"}
 		fail "sacct of $job_id failed ($matches != 4)"
 	}
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_prog1 $file_prog2
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test7.14 b/testsuite/expect/test7.14
index 72ec4a9700..4cb19fd84b 100755
--- a/testsuite/expect/test7.14
+++ b/testsuite/expect/test7.14
@@ -28,11 +28,16 @@
 ############################################################################
 source ./globals
 
-set exit_code        0
 set file_in          "test$test_id.input"
 set file_prog1       "test$test_id.prog1"
 set file_prog2       "test$test_id.prog2"
 
+proc cleanup {} {
+	global bin_rm file_in file_prog1 file_prog2
+
+	exec $bin_rm -f $file_in $file_prog1 $file_prog2
+}
+
 if {[get_config_param "AccountingStorageType"] ne "accounting_storage/slurmdbd"} {
 	skip "This test can't be run without a usable AccountStorageType"
 }
@@ -157,9 +162,3 @@ expect {
 if {$matches != 1} {
 	fail "sacct of $job_id failed ($matches)"
 }
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_prog1 $file_prog2
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test7.15 b/testsuite/expect/test7.15
index 77a1a2c714..5d18c2730e 100755
--- a/testsuite/expect/test7.15
+++ b/testsuite/expect/test7.15
@@ -29,6 +29,12 @@ source ./globals
 set exit_code        0
 set file_prog       "test$test_id.prog"
 
+proc cleanup {} {
+	global bin_rm file_prog
+
+	exec $bin_rm -f $file_prog
+}
+
 #
 # Delete left-over programs and rebuild them.
 #
@@ -47,7 +53,7 @@ if {[get_config_param "LaunchType"] eq "launch/runjob"} {
 if {$have_runjob} {
 	set nnodes 1
 } else {
-	set nnodes [available_nodes idle]
+	set nnodes [llength [get_nodes_by_state]]
 }
 
 #
@@ -68,9 +74,8 @@ expect {
 		}
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		# The above signals will result in a bad exit code,
@@ -82,8 +87,6 @@ expect {
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_prog
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test7.16 b/testsuite/expect/test7.16
index 0ee7b27d1e..3ff544b815 100755
--- a/testsuite/expect/test7.16
+++ b/testsuite/expect/test7.16
@@ -26,8 +26,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-
 #
 # Try to get allocation with bad credential
 #
@@ -71,8 +69,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "scontrol not responding"
-		set exit_code 1
+		fail "scontrol not responding"
 	}
 	eof {
 		wait
@@ -92,8 +89,3 @@ if {$job_id != 0} {
 		fail "Allocation granted with bad Munge credential. This happens rarely, when the Slurm test modifies a byte that Munge does not use"
 	}
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
-
diff --git a/testsuite/expect/test7.17 b/testsuite/expect/test7.17
index 969eb83f36..ecf22c3556 100755
--- a/testsuite/expect/test7.17
+++ b/testsuite/expect/test7.17
@@ -39,8 +39,9 @@ if {[get_config_param "SwitchType"] eq "switch/cray"} {
 #
 file delete $test_prog
 
-compile_against_libslurm ${test_prog} 1
-fail_on_error "Cannot compile test program"
+if [compile_against_libslurm -full $test_prog] {
+	fail "Cannot compile test program"
+}
 
 log_info "====test7.17.1===="
 set cpu_match 0
diff --git a/testsuite/expect/test7.18 b/testsuite/expect/test7.18
index dde507817b..7f5e75c4db 100755
--- a/testsuite/expect/test7.18
+++ b/testsuite/expect/test7.18
@@ -31,12 +31,19 @@ source ./globals
 set exit_code   0
 set test_prog   "test$test_id.prog"
 
+proc cleanup {} {
+	global test_prog
+
+	file delete $test_prog
+}
+
 #
 # Delete left-over programs and rebuild them.
 #
 exec $bin_rm -f $test_prog
-compile_against_libslurm ${test_prog}
-fail_on_error "Cannot compile test program"
+if [compile_against_libslurm ${test_prog}] {
+	fail "Cannot compile test program"
+}
 
 spawn ./$test_prog
 expect {
@@ -45,16 +52,13 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "test$test_id.prog not responding."
-		set exit_code 1
+		fail "test$test_id.prog not responding."
 	}
 	eof {
 		wait
 	}
 }
 
-if { $exit_code == 0 } {
-	file delete $test_prog
-} else {
+if { $exit_code != 0 } {
 	fail "One or more hosts weren't found"
 }
diff --git a/testsuite/expect/test7.2 b/testsuite/expect/test7.2
index 79da4cd146..ad71bb2123 100755
--- a/testsuite/expect/test7.2
+++ b/testsuite/expect/test7.2
@@ -32,6 +32,12 @@ source ./globals
 set exit_code        0
 set file_prog_get    "test$test_id.prog"
 
+proc cleanup {} {
+	global bin_rm file_prog_get
+
+	exec $bin_rm -f $file_prog_get
+}
+
 # PMI library not in Cray RPM
 if {[get_config_param "SwitchType"] eq "switch/cray"} {
 	skip "This test is incompatible with Cray systems"
@@ -60,9 +66,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $prog_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -94,17 +99,14 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		wait
 	}
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_prog_get
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test7.20 b/testsuite/expect/test7.20
index 7d916aa297..d4fcc246a2 100755
--- a/testsuite/expect/test7.20
+++ b/testsuite/expect/test7.20
@@ -87,15 +87,6 @@ proc cleanup_accounts {} {
 	remove_acct "" $ta1
 }
 
-proc cleanup {} {
-	global config_dir
-
-	cleanup_accounts
-	restore_conf $config_dir/job_submit.lua
-	restore_conf $config_dir/slurm.conf
-	reconfigure
-}
-
 proc check_rc { exit_code } {
 	if {$exit_code != 0} {
 		fail "Exiting with exit code $exit_code"
@@ -246,6 +237,15 @@ if { [llength $nodes] != 3 } {
 	skip "System too small for test, it needs '--ntasks-per-node=5 -N3'"
 }
 
+proc cleanup {} {
+	global config_dir
+
+	cleanup_accounts
+	restore_conf $config_dir/job_submit.lua
+	restore_conf $config_dir/slurm.conf
+	reconfigure
+}
+
 cleanup_accounts
 create_accounts
 
@@ -256,7 +256,7 @@ save_conf $config_dir/slurm.conf
 # Activate lua plugin
 exec $bin_sed -i {s/^\(JobSubmitPlugins\)/#\1/gI} $config_dir/slurm.conf
 exec $bin_echo "\n### test7.20 additions####\nJobSubmitPlugins=lua" >> $config_dir/slurm.conf
-reconfigure
+reconfigure -fail
 
 run_command "$bin_rm $config_dir/job_submit.lua"
 run_command -fail "$bin_cp $test_lua_reject $config_dir/job_submit.lua"
diff --git a/testsuite/expect/test7.21 b/testsuite/expect/test7.21
index 2b8eeabbbb..9da9a8848c 100755
--- a/testsuite/expect/test7.21
+++ b/testsuite/expect/test7.21
@@ -30,7 +30,6 @@
 source ./globals
 
 set cwd				"[$bin_pwd]"
-set exit_code	    0
 set file_in         "${cwd}/test${test_id}.in"
 set file_out	    "${cwd}/test${test_id}.out"
 set file_prog	    "${cwd}/test${test_id}.prog"
@@ -47,9 +46,10 @@ if {[get_config_param "FrontendName"] ne "MISSING"} {
     skip "This test is incompatible with front-end systems"
 }
 
-proc end_it { exit_code } {
+proc cleanup {} {
 	global test_id orig_spank_conf spank_conf_file new_spank_conf spank_out
 	global file_out spank_out bin_cp bin_rm file_in file_prog
+
 	#
 	# Restore the original plugstack
 	#
@@ -60,12 +60,7 @@ proc end_it { exit_code } {
 	}
 	reconfigure
 
-	if {$exit_code == 0} {
-		exec $bin_rm -f $orig_spank_conf $new_spank_conf $file_in $file_out $spank_out ${file_prog}.so
-		pass
-	} else {
-		fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-	}
+	exec $bin_rm -f $orig_spank_conf $new_spank_conf $file_in $file_out $spank_out ${file_prog}.so
 }
 
 #
@@ -151,7 +146,7 @@ expect {
 		wait
 	}
 }
-reconfigure
+reconfigure -fail
 
 #
 # Test of srun help message
@@ -172,23 +167,20 @@ expect {
 		exp_continue
 	}
 	-re timeout {
-		log_error "sbatch not responding"
-		end_it 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$job_id == 1} {
-	log_error "sbatch did not return a job id"
-	end_it 1
+	fail "sbatch did not return a job id"
 }
 # Check echo worked
 spawn $bin_cat $file_out
 expect {
 	-re "error" {
-		log_error "some error happened"
-		end_it 1
+		fail "Some error happened"
 	}
 	-re "IT_RAN" {
 		incr matches
@@ -199,8 +191,7 @@ expect {
 	}
 }
 if {$matches != 1} {
-	log_error "local (srun) sbatch spank plugin failure ($matches != 1)"
-	end_it 1
+	fail "Local (srun) sbatch spank plugin failure ($matches != 1)"
 }
 
 #check the output of spank plugin
@@ -217,21 +208,18 @@ expect {
 			incr matches
 			exp_continue
 		} else {
-			log_error "unexpected job id: $njob_id != $job_id"
-			end_it 1
+			fail "Unexpected job id: $njob_id != $job_id"
 		}
 	}
 	-re "error" {
-		log_error "some error happened"
-		end_it 1
+		fail "Some error happened"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 4} {
-	log_error "local (srun) sbatch spank plugin failure ($matches != 2)"
-	end_it 1
+	fail "Local (srun) sbatch spank plugin failure ($matches != 2)"
 }
 
 spawn $bin_rm $spank_out
@@ -249,23 +237,20 @@ expect {
 		exp_continue
 	}
 	-re timeout {
-		log_error "sbatch not responding"
-		end_it 1
+		fail "sbatch not responding"
 	}
 	eof {
 		wait
 	}
 }
 if {$job_id == 1} {
-	log_error "sbatch did not return a job id"
-	end_it 1
+	fail "sbatch did not return a job id"
 }
 # Check echo worked
 spawn $bin_cat $file_out
 expect {
 	-re "error" {
-		log_error "some error happened"
-		end_it 1
+		fail "Some error happened"
 	}
 	-re "IT_RAN" {
 		incr matches
@@ -276,8 +261,7 @@ expect {
 	}
 }
 if {$matches != 2} {
-	log_error "local (srun) sbatch spank plugin failure ($matches != 2)"
-	end_it 1
+	fail "Local (srun) sbatch spank plugin failure ($matches != 2)"
 }
 
 #check the output of spank plugin
@@ -297,21 +281,16 @@ expect {
 			incr matches
 			exp_continue
 		} else {
-			log_error "unexpected array job id: $narray_job_id != $array_job_id"
-			end_it 1
+			fail "Unexpected array job id: $narray_job_id != $array_job_id"
 		}
 	}
 	-re "error" {
-		log_error "some error happened"
-		end_it 1
+		fail "Some error happened"
 	}
 	eof {
 		wait
 	}
 }
 if {$matches != 5} {
-	log_error "local (srun) sbatch spank plugin failure ($matches != 5)"
-	end_it 1
+	fail "Local (srun) sbatch spank plugin failure ($matches != 5)"
 }
-
-end_it $exit_code
diff --git a/testsuite/expect/test7.22 b/testsuite/expect/test7.22
new file mode 100755
index 0000000000..6868c5f200
--- /dev/null
+++ b/testsuite/expect/test7.22
@@ -0,0 +1,152 @@
+#!/usr/bin/env expect
+############################################################################
+# Purpose: Test basic functionality of backfill scheduler
+############################################################################
+# Copyright (C) 2020 SchedMD LLC
+# Written by Albert Gil <albert.gil@schedmd.com>
+#
+# This file is part of Slurm, a resource management program.
+# For details, see <https://slurm.schedmd.com/>.
+# Please also read the included file: DISCLAIMER.
+#
+# Slurm is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# Slurm is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+# details.
+#
+# You should have received a copy of the GNU General Public License along
+# with Slurm; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+############################################################################
+source ./globals
+
+set nodes_avail      [llength [get_nodes_by_state]]
+set nodes_except_one [expr ($nodes_avail - 1)]
+set nodes_min        2
+set bf_interval      [param_value [get_config_param  "SchedulerParameters"] "bf_interval" 30]
+set bf_interval3     [expr $bf_interval * 3]
+set bf_interval5     [expr $bf_interval * 5]
+set job_id           0
+set job_pd           0
+set job_bf           0
+
+if {[get_config_param "FrontendName"] ne "MISSING"} {
+	skip "This test is incompatible with front-end systems."
+}
+
+if {[get_config_param "SchedulerType"] ne "sched/backfill"} {
+	skip "This test requires SchedulerType = sched/backfill"
+}
+
+if {$nodes_avail < $nodes_min} {
+	skip "Not enough nodes currently available ($nodes_avail avail < $nodes_min needed)."
+}
+
+if {[get_partition_param [default_partition] "OverSubscribe"] != "NO"} {
+	skip "This tests not works if OverSubscribe is enabled"
+}
+
+# Clean jobs and print success/failure based on exit_code
+proc cleanup { } {
+	global job_id job_pd job_bf
+	cancel_job [list $job_id $job_pd $job_bf]
+}
+
+proc test_bf {job_pd_args job_bf_args bf_expected} {
+	global job_id job_pd job_bf
+	global nodes_except_one bf_interval bf_interval3 bf_interval5
+	global test_name number re_word_str bin_sleep squeue
+
+	# Submit a first job that will block the second one
+	set job_id [submit_job -fail "--exclusive --nice=0   -o /dev/null -J $test_name --time=$bf_interval3 --wrap '$bin_sleep $bf_interval3' -N$nodes_except_one"]
+
+	# Wait to avoid job2 to be scheduled
+	if {[wait_for_job $job_id "RUNNING"]} {
+		fail "First job $job_id not started"
+	}
+
+	# Submit the job_pd with higher prio, and later the job_bf with less prio
+	set job_pd [submit_job -fail "--exclusive --nice=0   -o /dev/null -J $test_name $job_pd_args"]
+	set job_bf [submit_job -fail "--exclusive --nice=100 -o /dev/null -J $test_name $job_bf_args"]
+
+	# Wait for job_bf being started before job_pd
+	set end false
+	wait_for -pollinterval 1 -timeout $bf_interval5 {$end} {
+		if {$bf_expected} {
+			log_info "Waiting for job $job_bf to be backfilled before job $job_pd..."
+		} else {
+			log_info "Waiting for job $job_bf to NOT be backfilled before job $job_pd..."
+		}
+
+		set re_squeue "($number) ($re_word_str) ($number|N/A)"
+
+		set bf_found false
+		set pd_found false
+		set out [run_command_output -fail "SLURM_TIME_FORMAT=%s $squeue -o '%i %Q %t %S' --sort=i -j $job_pd,$job_bf -h"]
+		if {[regexp "$job_pd $re_squeue" $out - job_pd_prio job_pd_state job_pd_time]} {
+			set pd_found true
+		}
+		if {[regexp "$job_bf $re_squeue" $out - job_bf_prio job_bf_state job_bf_time]} {
+			set bf_found true
+		}
+
+		# Sanity checks
+		if {!$pd_found || !$bf_found} {
+			fail "Could not find jobs."
+		}
+		if {$job_bf_prio > $job_pd_prio} {
+			fail "Job to be backfilled has higher priority ($job_bf_prio > $job_pd_prio)."
+		}
+
+		# Backfill subtest
+		if {"$job_bf_state" ne "PD"} {
+			if {"$job_pd_state" eq "PD"} {
+				if {$bf_expected} {
+					subpass "Job $job_bf should be backfilled before job $job_pd."
+				} else {
+					subfail "Job $job_bf should NOT be backfilled before job $job_pd ($job_bf is not PD and $job_pd is still PD)"
+				}
+				set end true
+			} else {
+				if {$bf_expected} {
+					subtest {$job_bf_time < $job_pd_time} "Job $job_bf should be backfilled before job $job_pd." "$job_bf_time > $job_pd_time"
+				} else {
+					subtest {$job_bf_time > $job_pd_time} "Job $job_bf should NOT be backfilled before job $job_pd." "$job_bf_time < $job_pd_time"
+				}
+				set end true
+			}
+		} else {
+			if {"$job_pd_state" ne "PD"} {
+				if {$bf_expected} {
+					subfail "Job $job_bf should be backfilled before job $job_pd ($job_pd is not PD and $job_bf is still PD)"
+				} else {
+					subpass "Job $job_bf should NOT be backfilled before job $job_pd."
+				}
+				set end true
+			}
+		}
+	}
+	if {!$end} {
+		if {$bf_expected} {
+			subfail "Job $job_bf should be backfilled before job $job_pd (condition not reached after $bf_interval3)"
+		} else {
+			subfail "Job $job_bf should NOT be backfilled before job $job_pd (condition not reached after $bf_interval5)"
+		}
+	}
+	cleanup
+}
+
+# Positive test: bf should scheduler because that would NOT delay a job with higher prio
+testproc test_bf "--time=$bf_interval --wrap '$bin_sleep $bf_interval' -N$nodes_avail" \
+		 "--time=$bf_interval --wrap '$bin_sleep $bf_interval' -N1" \
+		 true
+
+# Negative test: bf should NOT scheduler because that would delay a job with higher prio
+testproc test_bf "--time=$bf_interval  --wrap '$bin_sleep $bf_interval'  -N$nodes_avail" \
+		 "--time=$bf_interval5 --wrap '$bin_sleep $bf_interval5' -N1" \
+		 false
diff --git a/testsuite/expect/test7.23 b/testsuite/expect/test7.23
index dcf8ef773f..2162dc78bb 100755
--- a/testsuite/expect/test7.23
+++ b/testsuite/expect/test7.23
@@ -1,13 +1,9 @@
 #!/usr/bin/env expect
 ############################################################################
-# Purpose:  Test time_str2secs parsing of different formats
-#
-# Note:    This script generates and then deletes files in the working directory
-#          named test7.23.prog
+# Purpose:  Confirm min_mem_per_{cpu,node} in lua JobSubmitPlugin
 ############################################################################
-# Copyright (C) 2019 SchedMD LLC
-# Written by Nathan Rini <nate@schedmd.com>
-# CODE-OCEC-09-009. All rights reserved.
+# Copyright (C) 2021 SchedMD LLC
+# Written by Chad Vizino
 #
 # This file is part of Slurm, a resource management program.
 # For details, see <https://slurm.schedmd.com/>.
@@ -29,17 +25,49 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
-set test_prog   "test$test_id.prog"
+set test_lua_min_mem	"$test_name\_scripts/min_mem.lua"
+set job_name		"$test_name"
 
-#
-# Delete left-over programs and rebuild them
-#
-file delete $test_prog
+if {![have_lua]} {
+	skip "LUA must be installed and enabled to test lua job_submit plugin."
+}
+
+proc test_min_mem { cmd min_mem_per_cpu_exp min_mem_per_node_exp } {
+	set output [run_command_output -fail "$cmd"]
+	set per_cpu_found ""
+	set per_node_found ""
+	regexp -lineanchor "^(srun|salloc|sbatch): min_mem_per_cpu is (\\S+)$" $output - - per_cpu_found
+	regexp -lineanchor "^(srun|salloc|sbatch): min_mem_per_node is (\\S+)$" $output - - per_node_found
+	subtest {$per_cpu_found == $min_mem_per_cpu_exp} "min_mem_per_cpu should be $min_mem_per_cpu_exp" "$per_cpu_found != $min_mem_per_cpu_exp"
+	subtest {$per_node_found == $min_mem_per_node_exp} "min_mem_per_node should be $min_mem_per_node_exp" "$per_node_found != $min_mem_per_node_exp"
+}
+
+proc cleanup {} {
+	global config_dir
 
-compile_against_libslurm ${test_prog}
-if {$exit_code} {
-	fail "Error compiling test_prog"
+	restore_conf $config_dir/job_submit.lua
+	restore_conf $config_dir/slurm.conf
+	reconfigure
 }
 
-run_command -fail "./$test_prog"
+set config_dir [get_conf_path]
+save_conf $config_dir/job_submit.lua
+save_conf $config_dir/slurm.conf
+
+# Activate lua plugin
+exec $bin_sed -i {s/^\(JobSubmitPlugins\)/#\1/gI} $config_dir/slurm.conf
+exec $bin_echo "\n### $test_name additions####\nJobSubmitPlugins=lua" >> $config_dir/slurm.conf
+reconfigure -fail
+
+run_command "$bin_rm $config_dir/job_submit.lua"
+run_command -fail "$bin_cp $test_lua_min_mem $config_dir/job_submit.lua"
+
+testproc test_min_mem "$salloc -J $job_name $bin_true" nil nil
+testproc test_min_mem "$srun -J $job_name $bin_true" nil nil
+testproc test_min_mem "$sbatch -J $job_name -o /dev/null --wrap $bin_true" nil nil
+testproc test_min_mem "$salloc -J $job_name --mem-per-cpu=1024 $bin_true" 1024 nil
+testproc test_min_mem "$srun -J $job_name --mem-per-cpu=1024 $bin_true" 1024 nil
+testproc test_min_mem "$sbatch -J $job_name --mem-per-cpu=1024 -o /dev/null --wrap $bin_true" 1024 nil
+testproc test_min_mem "$salloc -J $job_name --mem=2048 $bin_true" nil 2048
+testproc test_min_mem "$srun -J $job_name --mem=2048 $bin_true" nil 2048
+testproc test_min_mem "$sbatch -J $job_name --mem=2048 -o /dev/null --wrap $bin_true" nil 2048
diff --git a/testsuite/expect/test7.23.prog.c b/testsuite/expect/test7.23.prog.c
deleted file mode 100644
index 48d2991572..0000000000
--- a/testsuite/expect/test7.23.prog.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/*****************************************************************************\
- *  test7.23.prog.c - Test time_str2secs parsing of different formats.
- *
- *  Usage: test7.23.prog
- *****************************************************************************
- *  Copyright (C) 2019 SchedMD LLC
- *  Written by Nathan Rini <nate@schedmd.com>
- *  CODE-OCEC-09-009. All rights reserved.
- *
- *  This file is part of Slurm, a resource management program.
- *  For details, see <https://slurm.schedmd.com/>.
- *  Please also read the included file: DISCLAIMER.
- *
- *  Slurm is free software; you can redistribute it and/or modify it under
- *  the terms of the GNU General Public License as published by the Free
- *  Software Foundation; either version 2 of the License, or (at your option)
- *  any later version.
- *
- *  Slurm is distributed in the hope that it will be useful, but WITHOUT ANY
- *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
- *  details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with Slurm; if not, write to the Free Software Foundation, Inc.,
- *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
-\*****************************************************************************/
-
-#include <sys/types.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <slurm/slurm.h>
-#include <slurm/slurm_errno.h>
-
-#include "src/common/slurm_xlator.h"
-
-#include "src/common/log.h"
-#include "src/common/parse_time.h"
-#include "src/common/xassert.h"
-#include "src/common/xstring.h"
-
-void _ct(const char *time_string, int value)
-{
-	int t = time_str2secs(time_string);
-
-	if (t != value)
-		fatal("check_time: %s -> %u != %u", time_string, t, value);
-}
-
-int main (int argc, char **argv)
-{
-	log_options_t logopt = LOG_OPTS_STDERR_ONLY;
-	logopt.prefix_level = 1;
-	log_init(xbasename(argv[0]), logopt, 0, NULL);
-	logopt.stderr_level += 5;
-	log_alter(logopt, 0, NULL);
-
-	_ct("INVALID TIME", NO_VAL);
-	_ct("-1", INFINITE);
-	_ct("INFINITE", INFINITE);
-	_ct("infinite", INFINITE);
-	_ct("UNLIMITED", INFINITE);
-	_ct("unlimited", INFINITE);
-	_ct("LONG --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- INVALID TIME", NO_VAL);
-	_ct("0", 0);
-	_ct("60", 60*60);
-	_ct("60:15", 60*60 + 15);
-	_ct("60:0", 60*60);
-	_ct("60:", NO_VAL);
-	_ct("60:-10", NO_VAL);
-	_ct("-60:10", NO_VAL);
-	_ct("1:60:15", 1*60*60 + 60*60 + 15);
-	_ct("2:60:15", 2*60*60 + 60*60 + 15);
-	_ct("0:0:15", 15);
-	_ct("0:60:0", 60*60);
-	_ct("0:0:0", 0);
-	_ct("-0:-0:-0", NO_VAL);
-	_ct(" 0:0:0 ", NO_VAL); //TODO: should we trim()?
-	_ct("0-1:60:15", 1*60*60 + 60*60 + 15);
-	_ct("1-1:60:15", 1*60*60*24 + 1*60*60 + 60*60 + 15);
-	_ct("365-1:60:15", 365*60*60*24 + 1*60*60 + 60*60 + 15);
-	_ct("365-0:0:0", 365*60*60*24);
-	/*
-	 * ct("9999999-0:0:0", 365*60*60*24)
-	 * doesn't work with 32-bit int (sets high bit)
-	 * TODO: Ignoring this edge for now until time_t
-	 */
-	//_ct("9999999-0:0:0", NO_VAL);
-
-	return 0;
-}
diff --git a/testsuite/expect/test7.23_scripts/min_mem.lua b/testsuite/expect/test7.23_scripts/min_mem.lua
new file mode 100644
index 0000000000..70cceedb8e
--- /dev/null
+++ b/testsuite/expect/test7.23_scripts/min_mem.lua
@@ -0,0 +1,30 @@
+--[[
+ Test lua script for test7.23
+--]]
+
+function slurm_job_submit(job_desc, part_list, submit_uid)
+	if job_desc.min_mem_per_cpu == nil then
+		slurm.log_user("min_mem_per_cpu is nil")
+	elseif job_desc.min_mem_per_cpu == slurm.NO_VAL64 then
+		slurm.log_user("min_mem_per_cpu is NO_VAL64")
+	else
+		slurm.log_user("min_mem_per_cpu is %u",
+			       job_desc.min_mem_per_cpu)
+	end
+
+	if job_desc.min_mem_per_node == nil then
+		slurm.log_user("min_mem_per_node is nil")
+	else
+		slurm.log_user("min_mem_per_node is %u",
+			       job_desc.min_mem_per_node)
+	end
+
+	return slurm.SUCCESS
+end
+
+function slurm_job_modify(job_desc, job_rec, part_list, modify_uid)
+	return slurm.SUCCESS
+end
+
+slurm.log_user("initialized")
+return slurm.SUCCESS
diff --git a/testsuite/expect/test7.3 b/testsuite/expect/test7.3
index 1ceec155a3..1bee0bbd04 100755
--- a/testsuite/expect/test7.3
+++ b/testsuite/expect/test7.3
@@ -30,10 +30,15 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set io_prog     "test$test_id.io"
 set test_prog   "test$test_id.prog"
 
+proc cleanup {} {
+	global io_prog test_prog
+
+	file delete $io_prog $test_prog
+}
+
 if {[get_config_param "FrontendName"] ne "MISSING"} {
     skip "This test is incompatible with front-end systems"
 }
@@ -46,8 +51,9 @@ file delete $io_prog $test_prog
 exec $bin_cc -O -o $io_prog ${io_prog}.c
 exec $bin_chmod 700 $io_prog
 
-compile_against_libslurm ${test_prog}
-fail_on_error "Cannot compile test program"
+if [compile_against_libslurm ${test_prog}] {
+	fail "Cannot compile test program"
+}
 
 #
 # Spawn initial program via srun
@@ -96,14 +102,11 @@ expect {
 		exp_continue
 	}
 	-re "error" {
-		log_error "Some error occurred"
-		set exit_code 1
-		exp_continue
+		fail "Some error occurred"
 	}
 	timeout {
-		log_error "Spawn IO not responding"
 		cancel_job $job_id
-		set exit_code 1
+		fail "Spawn IO not responding"
 	}
 	eof {
 		wait
@@ -113,9 +116,3 @@ expect {
 if {$matches != [expr $task_cnt * 3]} {
 	fail "Spawn IO communications failure"
 }
-
-if {$exit_code == 0} {
-	file delete $io_prog $test_prog
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test7.4 b/testsuite/expect/test7.4
index a8dbbee0c1..1d548264b2 100755
--- a/testsuite/expect/test7.4
+++ b/testsuite/expect/test7.4
@@ -44,6 +44,12 @@ source ./globals
 set exit_code     0
 set test_prog     "test$test_id.prog"
 
+proc cleanup {} {
+	global bin_rm test_prog
+
+	exec $bin_rm -f $test_prog ${test_prog}.o ${test_prog}.TVD.v3breakpoints ${test_prog}.TVD.v3breakpoints~
+}
+
 # Note this appears as a single argv value to totalviewcli
 set bulk "dset TV::bulk_launch_enabled true; dset TV::bulk_launch_tmpfile1_host_lines %R; dset TV::bulk_launch_string {$srun --jobid=%J -N%N -n%N -w`awk -F. \'BEGIN {ORS=\",\"} {if (NR==%N) ORS=\"\"; print \$1}\' %t1` -l --input=none %B/tvdsvr%K -callback_host %H -callback_ports %L -set_pws %P -verbosity %V -working_directory %D %F}"
 set no_bulk       "dset TV::bulk_launch_enabled false"
@@ -144,8 +150,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "totalviewcli not responding"
-		set exit_code 1
+		fail "totalviewcli not responding"
 	}
 	eof {
 		wait
@@ -224,8 +229,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "totalviewcli not responding"
-		set exit_code 1
+		fail "totalviewcli not responding"
 	}
 	eof {
 		wait
@@ -238,8 +242,6 @@ if {$matches != 12} {
 	fail "totalviewcli operation matches $matches of 12. Remove your ~/.totalview directory and try again"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $test_prog ${test_prog}.o ${test_prog}.TVD.v3breakpoints ${test_prog}.TVD.v3breakpoints~
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test7.5 b/testsuite/expect/test7.5
index 2da24b2375..ae764a4db8 100755
--- a/testsuite/expect/test7.5
+++ b/testsuite/expect/test7.5
@@ -38,6 +38,12 @@ set fini_cnt    0
 set usr1cnt     0
 set usr2cnt     0
 
+proc cleanup {} {
+	global bin_rm file_prog
+
+	exec $bin_rm -f $file_prog
+}
+
 #
 # Delete left-over program and rebuild it
 #
@@ -97,9 +103,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		log_debug "EOF"
@@ -163,9 +168,8 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
+		fail "srun not responding"
 	}
 	eof {
 		log_debug "EOF"
@@ -182,8 +186,6 @@ if {$fini_cnt > 0} {
 #
 # Post-processing
 #
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_prog
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test7.6 b/testsuite/expect/test7.6
index 0875964145..915d5c5fa8 100755
--- a/testsuite/expect/test7.6
+++ b/testsuite/expect/test7.6
@@ -45,6 +45,13 @@ set job_id        0
 set test_prog     "test$test_id.prog"
 set timeout       $max_job_delay
 
+proc cleanup {} {
+	global job_id bin_rm test_prog
+
+	cancel_job $job_id
+	exec $bin_rm -f $test_prog ${test_prog}.o ${test_prog}.TVD.v3breakpoints
+}
+
 # Note this appears as a single argv value to totalviewcli
 set no_bulk       "dset TV::bulk_launch_enabled false"
 
@@ -89,12 +96,11 @@ expect {
 		set job_id $expect_out(1,string)
 	}
 	timeout {
-		log_error "salloc not responding"
 		if {$job_id != 0} {
 			cancel_job $job_id
 		}
 		slow_kill [expr 0 - $salloc_pid]
-		set exit_code 1
+		fail "salloc not responding"
 	}
 	eof {
 		wait
@@ -169,8 +175,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "totalviewcli not responding"
-		set exit_code 1
+		fail "totalviewcli not responding"
 	}
 	eof {
 		wait
@@ -182,10 +187,7 @@ if {$no_capability != 0} {
 if {$matches != 12} {
 	fail "totalviewcli operation matches $matches of 12. Remove your ~/.totalview directory and try again"
 }
-cancel_job $job_id
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $test_prog ${test_prog}.o ${test_prog}.TVD.v3breakpoints
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test7.7 b/testsuite/expect/test7.7
index 5b75f07a33..e645f0be7f 100755
--- a/testsuite/expect/test7.7
+++ b/testsuite/expect/test7.7
@@ -33,6 +33,12 @@ set file_out   "test$test_id.output"
 set job_name   "test$test_id"
 set job_id      0
 
+proc cleanup {} {
+	global bin_rm file_in file_out
+
+	exec $bin_rm -f $file_in $file_out
+}
+
 proc test_alloc_size { task_cnt } {
 	global bin_cat bin_rm file_in file_out sbatch job_name number
 	global alloc_unit_num exit_code max_tasks
@@ -46,8 +52,7 @@ proc test_alloc_size { task_cnt } {
 			exp_continue
 		}
 		timeout {
-		    log_error "sbatch not responding"
-			set exit_code 1
+		    fail "sbatch not responding"
 		}
 		eof {
 			wait
@@ -193,8 +198,6 @@ for {set inx 1} {$inx < $max_tasks && $exit_code == 0} {incr inx} {
 #
 # Clean up and exit
 #
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test7.9 b/testsuite/expect/test7.9
index 750176f6da..ab5a94ba48 100755
--- a/testsuite/expect/test7.9
+++ b/testsuite/expect/test7.9
@@ -35,6 +35,12 @@ set file_out         "test$test_id.output"
 set file_prog        "test$test_id.prog"
 set iterations       50
 
+proc cleanup {} {
+	global bin_rm file_in file_prog file_out
+
+	exec $bin_rm -f $file_in $file_prog $file_out
+}
+
 set accounting_storage_enforce [get_config_param "AccountingStorageEnforce"]
 if {[param_contains $accounting_storage_enforce "nosteps"] || [param_contains $accounting_storage_enforce "nojobs"]} {
 	skip "This test can not be run with nosteps or nojobs (AccoutingStorageEnforce)"
@@ -110,8 +116,7 @@ expect {
 		exp_continue
 	}
 	timeout {
-		log_error "/bin/cat not responding"
-		set exit_code 1
+		fail "/bin/cat not responding"
 	}
 	eof {
 		wait
@@ -136,8 +141,6 @@ if {$matches != 0} {
 	log_debug "  To diagnose, use lsof to examine spawned job"
 }
 
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in $file_prog $file_out
-} else {
+if {$exit_code != 0} {
 	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
 }
diff --git a/testsuite/expect/test8.12 b/testsuite/expect/test8.12
index 827d7c2129..514908c020 100755
--- a/testsuite/expect/test8.12
+++ b/testsuite/expect/test8.12
@@ -28,13 +28,29 @@
 ############################################################################
 source ./globals
 
-set exit_code            0
 set job_id               0
 set user_name            [get_my_user_name]
 set default_partition    [default_partition]
 set res_name             "res_$test_name"
+set resv_over_run        false
+set config_file          [get_conf_path]/slurm.conf
+
+if { [get_config_param ResvOverRun] != "0 min" } {
+	set resv_over_run true
+}
 
 proc cleanup {} {
+	global resv_over_run config_file
+
+	subcleanup
+
+	if { $resv_over_run } {
+		restore_conf $config_file
+		reconfigure -fail
+	}
+}
+
+proc subcleanup {} {
 	global scontrol res_name job_id
 
 	cancel_job $job_id
@@ -56,77 +72,65 @@ proc setup {use_flex {start_time ""}} {
 	}
 }
 
-set nb_nodes [get_node_cnt_in_part]
+set nb_nodes [get_partition_param [default_partition] "TotalNodes"]
 if {$nb_nodes < 2} {
 	skip "Need 2 or more nodes in default partition"
 }
 
+if { $resv_over_run } {
+	save_conf $config_file
+	exec $bin_echo ResvOverRun=0 >> $config_file
+	reconfigure -fail
+}
+
 proc test_flex {use_flex submit_active} {
-	global res_name job_id
+	global res_name job_id resv_over_run
 
-	log_info "SUBTEST: Job using more nodes than reservation"
-	cleanup
+	# Subtest job using more nodes than reservation
+	subcleanup
 	if {$submit_active} {
 		setup $use_flex ""
-		wait_for {[get_resvation_param $res_name State] eq "ACTIVE"} {}
+		wait_for {[get_reservation_param $res_name State] eq "ACTIVE"} {}
 	} else {
 		setup $use_flex "+5"
 	}
-	set job_id [submit_job -none "-N2 --reservation=$res_name --wrap 'sleep 30'"]
+	set job_id [submit_job -none "-N2 --reservation=$res_name --wrap 'sleep 30' -o /dev/null -e /dev/null"]
 	if {$use_flex} {
-		if {[wait_for_job -timeout 30 $job_id RUNNING]} {
-			fail "Job didn't start while it should because with FLEX more nodes can be requested"
-		}
+		subtest {![wait_for_job -timeout 30 $job_id RUNNING]} "Job should be running because with FLEX more nodes can be requested"
 	} else {
 		if {$submit_active} {
-			if {$job_id} {
-				fail "Job submitted but it shouldn't because requested more nodes than in reservation without FLEX and ACTIVE"
-			}
-			log_debug "Previous submission error expected, don't worry"
+			subtest {$job_id == 0} "Job shouldn't be running requested more nodes than in reservation without FLEX and ACTIVE"
 		} else {
-			if {![wait_for_job -timeout 30 $job_id RUNNING]} {
-				fail "Job started but it shouldn't because requested more nodes than in reservation without FLEX"
-			}
+			subtest {[wait_for_job -timeout 30 $job_id RUNNING]} "Job shouldn't be running because requested more nodes than in reservation without FLEX"
 		}
 	}
 
-	log_info "SUBTEST: Job with EndTime after reservation end"
-	cleanup
+	# Subtest job with EndTime after reservation end
+	subcleanup
 	if {$submit_active} {
 		setup $use_flex ""
-		wait_for {[get_resvation_param $res_name State] eq "ACTIVE"} {}
+		wait_for {[get_reservation_param $res_name State] eq "ACTIVE"} {}
 	} else {
 		setup $use_flex "+5"
 	}
-	set job_id [submit_job -fail "-N1 --reservation=$res_name -t 120 --wrap 'sleep 100'"]
-	if {[wait_for_job -timeout 30 $job_id RUNNING]} {
-		fail "Job didn't start while it should"
-	}
-	if {[wait_for_job -timeout 200 -pollinterval 10 $job_id DONE]} {
-		fail "Job didn't end"
-	}
+	set job_id [submit_job -fail "-N1 --reservation=$res_name -t 120 --wrap 'sleep 100' -o /dev/null -e /dev/null"]
+	subtest {![wait_for_job -timeout 30 $job_id RUNNING]} "Job should be RUNNING"
+	subtest {![wait_for_job -timeout 200 -pollinterval 10 $job_id DONE]} "Job should be DONE"
+
 	if {$use_flex} {
-		if { [get_job_param $job_id JobState] ne "COMPLETED" } {
-			fail "Job didn't complete successfully and it should with FLEX"
-		}
+		subtest {[get_job_param $job_id JobState] == "COMPLETED" } "Job should complete successfully after reservation end when it was FLEX"
 	} else {
-		if { [get_job_param $job_id JobState] ne "TIMEOUT" } {
-			fail "Job didn't TIMEOUT it should without FLEX"
-		}
+		subtest {[get_job_param $job_id JobState] == "TIMEOUT" } "Job should TIMEOUT with reservation end without FLEX"
 	}
 
-	log_info "SUBTEST: Job start before reservation StartTime"
-	cleanup
+	# Subtest Job start before reservation StartTime
+	subcleanup
 	setup $use_flex "+60"
-	set job_id [submit_job -fail "-N1 --reservation=$res_name -t 300 --wrap 'sleep 30'"]
+	set job_id [submit_job -fail "-N1 --reservation=$res_name -t 300 --wrap 'sleep 30' -o /dev/null -e /dev/null"]
 	if {$use_flex} {
-		if {[wait_for_job -timeout 30 $job_id RUNNING]} {
-			fail "Job didn't start before reservation and it should with FLEX."
-		}
+		subtest {![wait_for_job -timeout 30 $job_id RUNNING]} "Job should start before reservation since it's FLEX."
 	} else {
-		if {![wait_for_job -timeout 30 $job_id RUNNING]} {
-			fail "Job started before reservation and it shouldn't without FLEX."
-		}
+		subtest {[wait_for_job -timeout 30 $job_id RUNNING]}  "Job shouldn't started before reservation since it's not FLEX."
 	}
 }
 
@@ -138,7 +142,3 @@ test_flex true false
 test_flex false true
 # Test without FLEX flag and when reservation is INACTIVE
 test_flex false false
-
-if {$exit_code} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test9.4 b/testsuite/expect/test9.4
index 2b60d033d9..9e637ea6d7 100755
--- a/testsuite/expect/test9.4
+++ b/testsuite/expect/test9.4
@@ -41,9 +41,21 @@ set file_in       "test$test_id.input"
 set file_in_task  "test$test_id.%t.input"
 set file_out_task "test$test_id.%t.output"
 set job_name      "test$test_id"
+set cycle_count   [get_cycle_count]
+set task_cnt      $max_stress_tasks
+
+proc cleanup {} {
+	global bin_rm file_in test_id task_cnt
+
+	# Destroy all input/output files
+	exec $bin_rm -f $file_in
+	for {set tsk 0} {$tsk < $task_cnt} {incr tsk} {
+		set file_in_glob  "test$test_id.$tsk.input"
+		set file_out_glob "test$test_id.$tsk.output"
+		exec $bin_rm -f $file_in_glob $file_out_glob
+	}
+}
 
-set cycle_count [get_cycle_count]
-set task_cnt    $max_stress_tasks
 if {[get_config_param "LaunchType"] ne "launch/slurm"} {
 	skip "This test is only compatible with systems using launch/slurm"
 } else {
@@ -90,10 +102,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
 	timeout {
-		log_error "srun not responding"
 		slow_kill $srun_pid
-		set exit_code 1
-		exp_continue
+		fail "srun not responding"
 	}
 	eof {
 		wait
@@ -136,13 +146,6 @@ for {set inx 0} {$inx < $cycle_count} {incr inx} {
 		}
 	}
 }
-# Destroy all input/output files
-exec $bin_rm -f $file_in
-for {set tsk 0} {$tsk < $task_cnt} {incr tsk} {
-	set file_in_glob  "test$test_id.$tsk.input"
-	set file_out_glob "test$test_id.$tsk.output"
-	exec $bin_rm -f $file_in_glob $file_out_glob
-}
 
 if {$exit_code != 0} {
 	fail "Only $success_cnt of [expr $cycle_count * $task_cnt] task I/O tests passed"
diff --git a/testsuite/expect/test9.5 b/testsuite/expect/test9.5
index 9af9cec2db..44705d8056 100755
--- a/testsuite/expect/test9.5
+++ b/testsuite/expect/test9.5
@@ -33,9 +33,20 @@ set file_in       "test$test_id.input"
 set file_in_task  "test$test_id.%t.input"
 set file_out      "test$test_id.output"
 set job_name      "test$test_id"
+set cycle_count   [get_cycle_count]
+set task_cnt      $max_stress_tasks
+
+proc cleanup {} {
+	global bin_rm file_in file_out task_cnt test_id
+
+	# Destroy all input/output files
+	exec $bin_rm -f $file_in $file_out
+	for {set tsk 0} {$tsk < $task_cnt} {incr tsk} {
+		set file_in_glob "test$test_id.$tsk.input"
+		exec $bin_rm -f $file_in_glob
+	}
+}
 
-set cycle_count [get_cycle_count]
-set task_cnt    $max_stress_tasks
 if {[get_config_param "LaunchType"] ne "launch/slurm"} {
 	skip "This test is only compatible with systems using launch/slurm"
 } else {
@@ -85,9 +96,8 @@ expect {
 		fail "Slurm appears to be down"
 	}
         timeout {
-                log_error "srun not responding"
                 slow_kill $srun_pid
-                set exit_code 1
+                fail "srun not responding"
         }
         eof {
 		wait
@@ -120,12 +130,6 @@ for {set inx 0} {$inx < $cycle_count} {incr inx} {
 		incr success_cnt
 	}
 }
-# Destroy all input/output files
-exec $bin_rm -f $file_in $file_out
-for {set tsk 0} {$tsk < $task_cnt} {incr tsk} {
-	set file_in_glob "test$test_id.$tsk.input"
-	exec $bin_rm -f $file_in_glob
-}
 
 if {$exit_code != 0} {
 	fail "Only $success_cnt of $cycle_count task I/O tests passed"
diff --git a/testsuite/expect/test9.7 b/testsuite/expect/test9.7
index a81932e60e..19776df149 100755
--- a/testsuite/expect/test9.7
+++ b/testsuite/expect/test9.7
@@ -27,7 +27,6 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
 set file_script  "./test$test_id.bash"
 set iterations   5
 set sleep_time   1
@@ -73,7 +72,3 @@ for {set inx 0} {$inx < $task_cnt} {incr inx} {
 if {$success_cnt != $task_cnt} {
 	fail "Only $success_cnt of $task_cnt tests passed"
 }
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/expect/test9.8 b/testsuite/expect/test9.8
index 10265a4c14..9eb5795d6c 100755
--- a/testsuite/expect/test9.8
+++ b/testsuite/expect/test9.8
@@ -30,13 +30,20 @@
 ############################################################################
 source ./globals
 
-set exit_code    0
 set file_in      "test$test_id.input"
 set job_cnt      10
 set delay        10
 set job_name     "test$test_id"
 set sleep_time   300
 set task_cnt     60
+set jobs_list    [list]
+
+proc cleanup {} {
+	global bin_rm file_in jobs_list
+
+	exec $bin_rm -f $file_in
+	cancel_job $jobs_list
+}
 
 if {![param_contains [get_config_param "SelectTypeParameters"] "CR_*MEMORY"]} {
 	set mem_per_step 0
@@ -73,199 +80,49 @@ $srun -N1 -n1 --mem=0 $bin_sleep $sleep_time
 #
 # Initiate $job_cnt batch jobs
 #
-set start_cnt 0
 set timeout 30
 for {set inx 0} {$inx < $job_cnt} {incr inx} {
-	set sbatch_pid [spawn $sbatch --gres=craynetwork:0 --job-name=$job_name --mem-per-cpu=[expr $mem_per_step * 10] --output=/dev/null --error=/dev/null -t5 $file_in]
-	expect {
-		-re "Submitted batch job ($number)" {
-			incr start_cnt
-			exp_continue
-		}
-		-re "Unable to contact" {
-			log_error "Slurm appears to be down"
-			exp_continue
-		}
-		timeout {
-			log_error "sbatch not responding"
-			slow_kill $sbatch_pid
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
+	set job_id [submit_job -fail "--gres=craynetwork:0 --job-name=$job_name --mem-per-cpu=[expr $mem_per_step * 10] --output=/dev/null --error=/dev/null -t5 $file_in"]
+	lappend jobs_list $job_id
+}
+log_debug "All $job_cnt jobs submitted"
+
+# Wait for at least $job_cnt jobs to be started
+# Because we want an external variable set with the match count, it is
+# simpler to use wait_for here than wait_for_command
+set job_count 0
+if [
+	wait_for -timeout $delay {$job_count >= $job_cnt} {
+		set job_count [
+			regexp -all $job_name [
+				run_command_output -fail "$squeue --state R --name $job_name"
+			]
+		]
 	}
+] {
+	log_warn "Not all jobs were started ($job_count < $job_cnt). This is ok as long as it is at least 1"
 }
-if {$start_cnt < $job_cnt} {
-	log_error "$job_cnt of $start_cnt jobs submitted"
-	set exit_code 1
-} else {
-	log_debug "All $start_cnt jobs submitted"
+if {$job_count < 1} {
+	fail "No jobs were started"
 }
 
-set user_name [get_my_user_name]
-
 #
 # There could be hundreds of job steps, we don't want to see
 # the details, but want to make sure that we did start many
 #
 set desired_tasks [expr $task_cnt * 2 / 3]
 
-#
-# Give the jobs a few seconds to get initiated, check for steps,
-# then kill them all
-#
-exec $bin_sleep $delay
-
-set job_count  0
-set step_count 0
-set timeout    60
-log_user 0
-while { 1 } {
-	set job_count 0
-	spawn $squeue --state R --name $job_name --user $user_name
-	expect {
-		-re "$job_name" {
-			incr job_count
-			exp_continue
-		}
-		timeout {
-			log_error "squeue not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-
-	set step_count 0
-	spawn $squeue --steps --name $job_name --user $user_name
-	expect {
-		-re "sleep" {
-			incr step_count
-			exp_continue
-		}
-		-re "error:" {
-			log_error "squeue error"
-			set exit_code 1
-			exp_continue
-		}
-		timeout {
-			log_error "squeue not responding"
-			set exit_code 1
-		}
-		eof {
-			wait
-		}
-	}
-	if {$step_count >= $desired_tasks || $step_count == 0} {
-		break
-	}
-	set scaled_task_cnt [expr $job_count * $desired_tasks]
-	if {$step_count >= $scaled_task_cnt} {
-		log_debug "Only started $job_count jobs, reducing step count target to $scaled_task_cnt"
-		set desired_tasks $scaled_task_cnt
-	}
-	exec $bin_sleep 3
-}
-
-log_user 1
-if {$step_count < $desired_tasks} {
-	log_error "Only started $job_count jobs and $step_count steps. We expected at least $desired_tasks and possibly hundreds"
-	set exit_code 1
-} else {
-	log_debug "We found $job_count jobs and $step_count steps"
-}
-spawn $scancel --quiet --user $user_name
-expect {
-	eof {
-		wait
-	}
-}
-
-#
-# Give a few seconds for clean-up and ensure things are still fine
-# If message are lost, slurmctld re-sends job kill RPC 120 seconds later
-# In any case, make sure that all jobs get completed
-#
-exec $bin_sleep     10
-set completing_jobs 0
-set running_jobs    0
-spawn $squeue --noheader --user $user_name
-expect {
-	-re "test9.8.*$user_name *CG" {
-		incr completing_jobs
-		exp_continue
-	}
-	-re "test9.8.*$user_name" {
-		incr running_jobs
-		exp_continue
-	}
-	eof {
-		wait
+# We want to see a decent number of steps running
+if [
+	wait_for {$step_count >= $desired_tasks} {
+		set step_count [
+			regexp -all sleep [
+				run_command_output -fail "$squeue --steps --name $job_name"
+			]
+		]
 	}
+] {
+	fail "Only started $job_count jobs and $step_count steps. We expected at least $desired_tasks and possibly hundreds"
 }
-#
-# The following logic handles the scancel request failing
-# due to a very busy system (reports failure above)
-#
-# Increasing the MessageTimeout configuration parameter
-# should fix this problem.
-#
-if {$running_jobs != 0} {
-	log_error "Jobs not all cancelled"
-	set exit_code 1
 
-	spawn $scancel --quiet --user $user_name
-	expect {
-		eof {
-			wait
-		}
-	}
-}
-if {$completing_jobs != 0} {
-	log_info "Waiting for slurmctld to re-send job kill RPC"
-	log_info "This will take 120 seconds.."
-	exec $bin_sleep 120
-	set completing_jobs 0
-	spawn $squeue --noheader --user $user_name
-	expect {
-		-re "$job_name *$user_name *CG" {
-			incr completing_jobs
-			exp_continue
-		}
-		eof {
-			wait
-		}
-	}
-	if {$completing_jobs != 0} {
-		log_error "Jobs not completing"
-		set exit_code 1
-	}
-}
-if {$completing_jobs != 0} {
-	set max_wait [expr $sleep_time - 120]
-	if {$max_wait > 0} {
-		set completing_jobs 0
-		exec $bin_sleep $max_wait
-		spawn $squeue --noheader --user $user_name
-		expect {
-			-re "$job_name *$user_name *CG" {
-				incr completing_jobs
-				exp_continue
-			}
-			eof {
-				wait
-			}
-		}
-	}
-}
-if {$completing_jobs != 0} {
-	log_error "Jobs not completing. Subsequent tests may fail!"
-}
-
-if {$exit_code == 0} {
-	exec $bin_rm -f $file_in
-} else {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
+log_debug "We found $job_count jobs and $step_count steps"
diff --git a/testsuite/expect/test9.9 b/testsuite/expect/test9.9
index 262a468615..59cf2dda95 100755
--- a/testsuite/expect/test9.9
+++ b/testsuite/expect/test9.9
@@ -25,7 +25,6 @@
 ############################################################################
 source ./globals
 
-set exit_code   0
 set test_script "./test$test_id.bash"
 
 #   job_blocks  Submit jobs in blocks of this size (job count)
@@ -47,7 +46,7 @@ if {[get_config_param "FrontendName"] ne "MISSING" || $enable_memory_leak_debug
 # NOTE: The throughput rate is highly dependent upon configuration
 #
 proc _submit_jobs { job_name test_file } {
-	global exit_code job_blocks job_cnt sbatch test_script
+	global job_blocks job_cnt sbatch test_script
 
 	log_user 0
 	for {set jobs_rem $job_cnt} {$jobs_rem > 0} { } {
@@ -73,7 +72,3 @@ proc _submit_jobs { job_name test_file } {
 set time_took [string trim [time {_submit_jobs "test$test_id" "/dev/null"}] " per iteration microseconds"]
 set jobs_per_sec [expr $job_cnt * 1000000 / $time_took]
 log_debug "Ran $job_cnt jobs in $time_took microseconds or $jobs_per_sec jobs per second"
-
-if {$exit_code != 0} {
-	fail "Test failed due to previous errors (\$exit_code = $exit_code)"
-}
diff --git a/testsuite/slurm_unit/Makefile.am b/testsuite/slurm_unit/Makefile.am
index c92bae8912..f0cef9d9f3 100644
--- a/testsuite/slurm_unit/Makefile.am
+++ b/testsuite/slurm_unit/Makefile.am
@@ -1,4 +1,4 @@
 AUTOMAKE_OPTIONS = foreign
 
-SUBDIRS = api common
+SUBDIRS = api common slurmd
 
diff --git a/testsuite/slurm_unit/Makefile.in b/testsuite/slurm_unit/Makefile.in
index 3553628664..73cbaeff2f 100644
--- a/testsuite/slurm_unit/Makefile.in
+++ b/testsuite/slurm_unit/Makefile.in
@@ -482,7 +482,7 @@ top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 AUTOMAKE_OPTIONS = foreign
-SUBDIRS = api common
+SUBDIRS = api common slurmd
 all: all-recursive
 
 .SUFFIXES:
diff --git a/testsuite/slurm_unit/common/Makefile.am b/testsuite/slurm_unit/common/Makefile.am
index 2830324bbc..4a7c372e0e 100644
--- a/testsuite/slurm_unit/common/Makefile.am
+++ b/testsuite/slurm_unit/common/Makefile.am
@@ -14,13 +14,25 @@ TESTS = \
 	pack-test
 
 if HAVE_CHECK
-MYCFLAGS  = @CHECK_CFLAGS@ -Wall -ansi -pedantic -std=c99
+MYCFLAGS  = @CHECK_CFLAGS@ -Wall
 MYCFLAGS += -D_ISO99_SOURCE -Wunused-but-set-variable
 TESTS += xtree-test \
-	 xhash-test
+	 xhash-test \
+	 data-test \
+	 slurm_opt-test \
+	 xstring-test \
+	 parse_time-test
 xtree_test_CFLAGS = $(MYCFLAGS)
 xtree_test_LDADD  = $(LDADD) @CHECK_LIBS@
 xhash_test_CFLAGS = $(MYCFLAGS)
 xhash_test_LDADD  = $(LDADD) @CHECK_LIBS@
+data_test_CFLAGS  = $(MYCFLAGS)
+data_test_LDADD   = $(LDADD) @CHECK_LIBS@
+slurm_opt_test_CFLAGS = $(MYCFLAGS)
+slurm_opt_test_LDADD  = $(LDADD) @CHECK_LIBS@
+xstring_test_CFLAGS   = $(MYCFLAGS)
+xstring_test_LDADD    = $(LDADD) @CHECK_LIBS@
+parse_time_test_CFLAGS= $(MYCFLAGS)
+parse_time_test_LDADD = $(LDADD) @CHECK_LIBS@
 endif
 
diff --git a/testsuite/slurm_unit/common/Makefile.in b/testsuite/slurm_unit/common/Makefile.in
index 5c94463b6d..6db9085b21 100644
--- a/testsuite/slurm_unit/common/Makefile.in
+++ b/testsuite/slurm_unit/common/Makefile.in
@@ -92,7 +92,11 @@ check_PROGRAMS = $(am__EXEEXT_2)
 TESTS = job-resources-test$(EXEEXT) log-test$(EXEEXT) \
 	pack-test$(EXEEXT) $(am__EXEEXT_1)
 @HAVE_CHECK_TRUE@am__append_1 = xtree-test \
-@HAVE_CHECK_TRUE@	 xhash-test
+@HAVE_CHECK_TRUE@	 xhash-test \
+@HAVE_CHECK_TRUE@	 data-test \
+@HAVE_CHECK_TRUE@	 slurm_opt-test \
+@HAVE_CHECK_TRUE@	 xstring-test \
+@HAVE_CHECK_TRUE@	 parse_time-test
 
 subdir = testsuite/slurm_unit/common
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
@@ -151,19 +155,29 @@ CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/slurm/slurm.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 @HAVE_CHECK_TRUE@am__EXEEXT_1 = xtree-test$(EXEEXT) \
-@HAVE_CHECK_TRUE@	xhash-test$(EXEEXT)
+@HAVE_CHECK_TRUE@	xhash-test$(EXEEXT) data-test$(EXEEXT) \
+@HAVE_CHECK_TRUE@	slurm_opt-test$(EXEEXT) xstring-test$(EXEEXT) \
+@HAVE_CHECK_TRUE@	parse_time-test$(EXEEXT)
 am__EXEEXT_2 = job-resources-test$(EXEEXT) log-test$(EXEEXT) \
 	pack-test$(EXEEXT) $(am__EXEEXT_1)
-job_resources_test_SOURCES = job-resources-test.c
-job_resources_test_OBJECTS = job-resources-test.$(OBJEXT)
-job_resources_test_LDADD = $(LDADD)
+data_test_SOURCES = data-test.c
+data_test_OBJECTS = data_test-data-test.$(OBJEXT)
 am__DEPENDENCIES_1 =
-job_resources_test_DEPENDENCIES = $(top_builddir)/src/api/libslurm.o \
+am__DEPENDENCIES_2 = $(top_builddir)/src/api/libslurm.o \
 	$(am__DEPENDENCIES_1)
+@HAVE_CHECK_TRUE@data_test_DEPENDENCIES = $(am__DEPENDENCIES_2)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
+data_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(data_test_CFLAGS) \
+	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+job_resources_test_SOURCES = job-resources-test.c
+job_resources_test_OBJECTS = job-resources-test.$(OBJEXT)
+job_resources_test_LDADD = $(LDADD)
+job_resources_test_DEPENDENCIES = $(top_builddir)/src/api/libslurm.o \
+	$(am__DEPENDENCIES_1)
 log_test_SOURCES = log-test.c
 log_test_OBJECTS = log-test.$(OBJEXT)
 log_test_LDADD = $(LDADD)
@@ -174,14 +188,32 @@ pack_test_OBJECTS = pack-test.$(OBJEXT)
 pack_test_LDADD = $(LDADD)
 pack_test_DEPENDENCIES = $(top_builddir)/src/api/libslurm.o \
 	$(am__DEPENDENCIES_1)
+parse_time_test_SOURCES = parse_time-test.c
+parse_time_test_OBJECTS = parse_time_test-parse_time-test.$(OBJEXT)
+@HAVE_CHECK_TRUE@parse_time_test_DEPENDENCIES = $(am__DEPENDENCIES_2)
+parse_time_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(parse_time_test_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \
+	-o $@
+slurm_opt_test_SOURCES = slurm_opt-test.c
+slurm_opt_test_OBJECTS = slurm_opt_test-slurm_opt-test.$(OBJEXT)
+@HAVE_CHECK_TRUE@slurm_opt_test_DEPENDENCIES = $(am__DEPENDENCIES_2)
+slurm_opt_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(slurm_opt_test_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o \
+	$@
 xhash_test_SOURCES = xhash-test.c
 xhash_test_OBJECTS = xhash_test-xhash-test.$(OBJEXT)
-am__DEPENDENCIES_2 = $(top_builddir)/src/api/libslurm.o \
-	$(am__DEPENDENCIES_1)
 @HAVE_CHECK_TRUE@xhash_test_DEPENDENCIES = $(am__DEPENDENCIES_2)
 xhash_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(xhash_test_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+xstring_test_SOURCES = xstring-test.c
+xstring_test_OBJECTS = xstring_test-xstring-test.$(OBJEXT)
+@HAVE_CHECK_TRUE@xstring_test_DEPENDENCIES = $(am__DEPENDENCIES_2)
+xstring_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(xstring_test_CFLAGS) \
+	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 xtree_test_SOURCES = xtree-test.c
 xtree_test_OBJECTS = xtree_test-xtree-test.$(OBJEXT)
 @HAVE_CHECK_TRUE@xtree_test_DEPENDENCIES = $(am__DEPENDENCIES_2)
@@ -203,9 +235,13 @@ am__v_at_1 =
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir) -I$(top_builddir)/slurm
 depcomp = $(SHELL) $(top_srcdir)/auxdir/depcomp
 am__maybe_remake_depfiles = depfiles
-am__depfiles_remade = ./$(DEPDIR)/job-resources-test.Po \
-	./$(DEPDIR)/log-test.Po ./$(DEPDIR)/pack-test.Po \
+am__depfiles_remade = ./$(DEPDIR)/data_test-data-test.Po \
+	./$(DEPDIR)/job-resources-test.Po ./$(DEPDIR)/log-test.Po \
+	./$(DEPDIR)/pack-test.Po \
+	./$(DEPDIR)/parse_time_test-parse_time-test.Po \
+	./$(DEPDIR)/slurm_opt_test-slurm_opt-test.Po \
 	./$(DEPDIR)/xhash_test-xhash-test.Po \
+	./$(DEPDIR)/xstring_test-xstring-test.Po \
 	./$(DEPDIR)/xtree_test-xtree-test.Po
 am__mv = mv -f
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
@@ -226,10 +262,12 @@ AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
 am__v_CCLD_0 = @echo "  CCLD    " $@;
 am__v_CCLD_1 = 
-SOURCES = job-resources-test.c log-test.c pack-test.c xhash-test.c \
+SOURCES = data-test.c job-resources-test.c log-test.c pack-test.c \
+	parse_time-test.c slurm_opt-test.c xhash-test.c xstring-test.c \
+	xtree-test.c
+DIST_SOURCES = data-test.c job-resources-test.c log-test.c pack-test.c \
+	parse_time-test.c slurm_opt-test.c xhash-test.c xstring-test.c \
 	xtree-test.c
-DIST_SOURCES = job-resources-test.c log-test.c pack-test.c \
-	xhash-test.c xtree-test.c
 RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
 	ctags-recursive dvi-recursive html-recursive info-recursive \
 	install-data-recursive install-dvi-recursive \
@@ -761,13 +799,20 @@ AUTOMAKE_OPTIONS = foreign
 SUBDIRS = bitstring slurm_protocol_pack slurmdb_pack
 AM_CPPFLAGS = -I$(top_srcdir) -ldl -lpthread
 LDADD = $(top_builddir)/src/api/libslurm.o $(DL_LIBS)
-@HAVE_CHECK_TRUE@MYCFLAGS = @CHECK_CFLAGS@ -Wall -ansi -pedantic \
-@HAVE_CHECK_TRUE@	-std=c99 -D_ISO99_SOURCE \
+@HAVE_CHECK_TRUE@MYCFLAGS = @CHECK_CFLAGS@ -Wall -D_ISO99_SOURCE \
 @HAVE_CHECK_TRUE@	-Wunused-but-set-variable
 @HAVE_CHECK_TRUE@xtree_test_CFLAGS = $(MYCFLAGS)
 @HAVE_CHECK_TRUE@xtree_test_LDADD = $(LDADD) @CHECK_LIBS@
 @HAVE_CHECK_TRUE@xhash_test_CFLAGS = $(MYCFLAGS)
 @HAVE_CHECK_TRUE@xhash_test_LDADD = $(LDADD) @CHECK_LIBS@
+@HAVE_CHECK_TRUE@data_test_CFLAGS = $(MYCFLAGS)
+@HAVE_CHECK_TRUE@data_test_LDADD = $(LDADD) @CHECK_LIBS@
+@HAVE_CHECK_TRUE@slurm_opt_test_CFLAGS = $(MYCFLAGS)
+@HAVE_CHECK_TRUE@slurm_opt_test_LDADD = $(LDADD) @CHECK_LIBS@
+@HAVE_CHECK_TRUE@xstring_test_CFLAGS = $(MYCFLAGS)
+@HAVE_CHECK_TRUE@xstring_test_LDADD = $(LDADD) @CHECK_LIBS@
+@HAVE_CHECK_TRUE@parse_time_test_CFLAGS = $(MYCFLAGS)
+@HAVE_CHECK_TRUE@parse_time_test_LDADD = $(LDADD) @CHECK_LIBS@
 all: all-recursive
 
 .SUFFIXES:
@@ -811,6 +856,10 @@ clean-checkPROGRAMS:
 	echo " rm -f" $$list; \
 	rm -f $$list
 
+data-test$(EXEEXT): $(data_test_OBJECTS) $(data_test_DEPENDENCIES) $(EXTRA_data_test_DEPENDENCIES) 
+	@rm -f data-test$(EXEEXT)
+	$(AM_V_CCLD)$(data_test_LINK) $(data_test_OBJECTS) $(data_test_LDADD) $(LIBS)
+
 job-resources-test$(EXEEXT): $(job_resources_test_OBJECTS) $(job_resources_test_DEPENDENCIES) $(EXTRA_job_resources_test_DEPENDENCIES) 
 	@rm -f job-resources-test$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(job_resources_test_OBJECTS) $(job_resources_test_LDADD) $(LIBS)
@@ -823,10 +872,22 @@ pack-test$(EXEEXT): $(pack_test_OBJECTS) $(pack_test_DEPENDENCIES) $(EXTRA_pack_
 	@rm -f pack-test$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(pack_test_OBJECTS) $(pack_test_LDADD) $(LIBS)
 
+parse_time-test$(EXEEXT): $(parse_time_test_OBJECTS) $(parse_time_test_DEPENDENCIES) $(EXTRA_parse_time_test_DEPENDENCIES) 
+	@rm -f parse_time-test$(EXEEXT)
+	$(AM_V_CCLD)$(parse_time_test_LINK) $(parse_time_test_OBJECTS) $(parse_time_test_LDADD) $(LIBS)
+
+slurm_opt-test$(EXEEXT): $(slurm_opt_test_OBJECTS) $(slurm_opt_test_DEPENDENCIES) $(EXTRA_slurm_opt_test_DEPENDENCIES) 
+	@rm -f slurm_opt-test$(EXEEXT)
+	$(AM_V_CCLD)$(slurm_opt_test_LINK) $(slurm_opt_test_OBJECTS) $(slurm_opt_test_LDADD) $(LIBS)
+
 xhash-test$(EXEEXT): $(xhash_test_OBJECTS) $(xhash_test_DEPENDENCIES) $(EXTRA_xhash_test_DEPENDENCIES) 
 	@rm -f xhash-test$(EXEEXT)
 	$(AM_V_CCLD)$(xhash_test_LINK) $(xhash_test_OBJECTS) $(xhash_test_LDADD) $(LIBS)
 
+xstring-test$(EXEEXT): $(xstring_test_OBJECTS) $(xstring_test_DEPENDENCIES) $(EXTRA_xstring_test_DEPENDENCIES) 
+	@rm -f xstring-test$(EXEEXT)
+	$(AM_V_CCLD)$(xstring_test_LINK) $(xstring_test_OBJECTS) $(xstring_test_LDADD) $(LIBS)
+
 xtree-test$(EXEEXT): $(xtree_test_OBJECTS) $(xtree_test_DEPENDENCIES) $(EXTRA_xtree_test_DEPENDENCIES) 
 	@rm -f xtree-test$(EXEEXT)
 	$(AM_V_CCLD)$(xtree_test_LINK) $(xtree_test_OBJECTS) $(xtree_test_LDADD) $(LIBS)
@@ -837,10 +898,14 @@ mostlyclean-compile:
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/data_test-data-test.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/job-resources-test.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/log-test.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack-test.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parse_time_test-parse_time-test.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/slurm_opt_test-slurm_opt-test.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xhash_test-xhash-test.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xstring_test-xstring-test.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xtree_test-xtree-test.Po@am__quote@ # am--include-marker
 
 $(am__depfiles_remade):
@@ -870,6 +935,48 @@ am--depfiles: $(am__depfiles_remade)
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
 
+data_test-data-test.o: data-test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(data_test_CFLAGS) $(CFLAGS) -MT data_test-data-test.o -MD -MP -MF $(DEPDIR)/data_test-data-test.Tpo -c -o data_test-data-test.o `test -f 'data-test.c' || echo '$(srcdir)/'`data-test.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/data_test-data-test.Tpo $(DEPDIR)/data_test-data-test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='data-test.c' object='data_test-data-test.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(data_test_CFLAGS) $(CFLAGS) -c -o data_test-data-test.o `test -f 'data-test.c' || echo '$(srcdir)/'`data-test.c
+
+data_test-data-test.obj: data-test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(data_test_CFLAGS) $(CFLAGS) -MT data_test-data-test.obj -MD -MP -MF $(DEPDIR)/data_test-data-test.Tpo -c -o data_test-data-test.obj `if test -f 'data-test.c'; then $(CYGPATH_W) 'data-test.c'; else $(CYGPATH_W) '$(srcdir)/data-test.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/data_test-data-test.Tpo $(DEPDIR)/data_test-data-test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='data-test.c' object='data_test-data-test.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(data_test_CFLAGS) $(CFLAGS) -c -o data_test-data-test.obj `if test -f 'data-test.c'; then $(CYGPATH_W) 'data-test.c'; else $(CYGPATH_W) '$(srcdir)/data-test.c'; fi`
+
+parse_time_test-parse_time-test.o: parse_time-test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(parse_time_test_CFLAGS) $(CFLAGS) -MT parse_time_test-parse_time-test.o -MD -MP -MF $(DEPDIR)/parse_time_test-parse_time-test.Tpo -c -o parse_time_test-parse_time-test.o `test -f 'parse_time-test.c' || echo '$(srcdir)/'`parse_time-test.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/parse_time_test-parse_time-test.Tpo $(DEPDIR)/parse_time_test-parse_time-test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='parse_time-test.c' object='parse_time_test-parse_time-test.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(parse_time_test_CFLAGS) $(CFLAGS) -c -o parse_time_test-parse_time-test.o `test -f 'parse_time-test.c' || echo '$(srcdir)/'`parse_time-test.c
+
+parse_time_test-parse_time-test.obj: parse_time-test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(parse_time_test_CFLAGS) $(CFLAGS) -MT parse_time_test-parse_time-test.obj -MD -MP -MF $(DEPDIR)/parse_time_test-parse_time-test.Tpo -c -o parse_time_test-parse_time-test.obj `if test -f 'parse_time-test.c'; then $(CYGPATH_W) 'parse_time-test.c'; else $(CYGPATH_W) '$(srcdir)/parse_time-test.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/parse_time_test-parse_time-test.Tpo $(DEPDIR)/parse_time_test-parse_time-test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='parse_time-test.c' object='parse_time_test-parse_time-test.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(parse_time_test_CFLAGS) $(CFLAGS) -c -o parse_time_test-parse_time-test.obj `if test -f 'parse_time-test.c'; then $(CYGPATH_W) 'parse_time-test.c'; else $(CYGPATH_W) '$(srcdir)/parse_time-test.c'; fi`
+
+slurm_opt_test-slurm_opt-test.o: slurm_opt-test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(slurm_opt_test_CFLAGS) $(CFLAGS) -MT slurm_opt_test-slurm_opt-test.o -MD -MP -MF $(DEPDIR)/slurm_opt_test-slurm_opt-test.Tpo -c -o slurm_opt_test-slurm_opt-test.o `test -f 'slurm_opt-test.c' || echo '$(srcdir)/'`slurm_opt-test.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/slurm_opt_test-slurm_opt-test.Tpo $(DEPDIR)/slurm_opt_test-slurm_opt-test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='slurm_opt-test.c' object='slurm_opt_test-slurm_opt-test.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(slurm_opt_test_CFLAGS) $(CFLAGS) -c -o slurm_opt_test-slurm_opt-test.o `test -f 'slurm_opt-test.c' || echo '$(srcdir)/'`slurm_opt-test.c
+
+slurm_opt_test-slurm_opt-test.obj: slurm_opt-test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(slurm_opt_test_CFLAGS) $(CFLAGS) -MT slurm_opt_test-slurm_opt-test.obj -MD -MP -MF $(DEPDIR)/slurm_opt_test-slurm_opt-test.Tpo -c -o slurm_opt_test-slurm_opt-test.obj `if test -f 'slurm_opt-test.c'; then $(CYGPATH_W) 'slurm_opt-test.c'; else $(CYGPATH_W) '$(srcdir)/slurm_opt-test.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/slurm_opt_test-slurm_opt-test.Tpo $(DEPDIR)/slurm_opt_test-slurm_opt-test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='slurm_opt-test.c' object='slurm_opt_test-slurm_opt-test.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(slurm_opt_test_CFLAGS) $(CFLAGS) -c -o slurm_opt_test-slurm_opt-test.obj `if test -f 'slurm_opt-test.c'; then $(CYGPATH_W) 'slurm_opt-test.c'; else $(CYGPATH_W) '$(srcdir)/slurm_opt-test.c'; fi`
+
 xhash_test-xhash-test.o: xhash-test.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xhash_test_CFLAGS) $(CFLAGS) -MT xhash_test-xhash-test.o -MD -MP -MF $(DEPDIR)/xhash_test-xhash-test.Tpo -c -o xhash_test-xhash-test.o `test -f 'xhash-test.c' || echo '$(srcdir)/'`xhash-test.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/xhash_test-xhash-test.Tpo $(DEPDIR)/xhash_test-xhash-test.Po
@@ -884,6 +991,20 @@ xhash_test-xhash-test.obj: xhash-test.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xhash_test_CFLAGS) $(CFLAGS) -c -o xhash_test-xhash-test.obj `if test -f 'xhash-test.c'; then $(CYGPATH_W) 'xhash-test.c'; else $(CYGPATH_W) '$(srcdir)/xhash-test.c'; fi`
 
+xstring_test-xstring-test.o: xstring-test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xstring_test_CFLAGS) $(CFLAGS) -MT xstring_test-xstring-test.o -MD -MP -MF $(DEPDIR)/xstring_test-xstring-test.Tpo -c -o xstring_test-xstring-test.o `test -f 'xstring-test.c' || echo '$(srcdir)/'`xstring-test.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/xstring_test-xstring-test.Tpo $(DEPDIR)/xstring_test-xstring-test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='xstring-test.c' object='xstring_test-xstring-test.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xstring_test_CFLAGS) $(CFLAGS) -c -o xstring_test-xstring-test.o `test -f 'xstring-test.c' || echo '$(srcdir)/'`xstring-test.c
+
+xstring_test-xstring-test.obj: xstring-test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xstring_test_CFLAGS) $(CFLAGS) -MT xstring_test-xstring-test.obj -MD -MP -MF $(DEPDIR)/xstring_test-xstring-test.Tpo -c -o xstring_test-xstring-test.obj `if test -f 'xstring-test.c'; then $(CYGPATH_W) 'xstring-test.c'; else $(CYGPATH_W) '$(srcdir)/xstring-test.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/xstring_test-xstring-test.Tpo $(DEPDIR)/xstring_test-xstring-test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='xstring-test.c' object='xstring_test-xstring-test.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xstring_test_CFLAGS) $(CFLAGS) -c -o xstring_test-xstring-test.obj `if test -f 'xstring-test.c'; then $(CYGPATH_W) 'xstring-test.c'; else $(CYGPATH_W) '$(srcdir)/xstring-test.c'; fi`
+
 xtree_test-xtree-test.o: xtree-test.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(xtree_test_CFLAGS) $(CFLAGS) -MT xtree_test-xtree-test.o -MD -MP -MF $(DEPDIR)/xtree_test-xtree-test.Tpo -c -o xtree_test-xtree-test.o `test -f 'xtree-test.c' || echo '$(srcdir)/'`xtree-test.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/xtree_test-xtree-test.Tpo $(DEPDIR)/xtree_test-xtree-test.Po
@@ -1179,6 +1300,34 @@ xhash-test.log: xhash-test$(EXEEXT)
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
 	"$$tst" $(AM_TESTS_FD_REDIRECT)
+data-test.log: data-test$(EXEEXT)
+	@p='data-test$(EXEEXT)'; \
+	b='data-test'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+slurm_opt-test.log: slurm_opt-test$(EXEEXT)
+	@p='slurm_opt-test$(EXEEXT)'; \
+	b='slurm_opt-test'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+xstring-test.log: xstring-test$(EXEEXT)
+	@p='xstring-test$(EXEEXT)'; \
+	b='xstring-test'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+parse_time-test.log: parse_time-test$(EXEEXT)
+	@p='parse_time-test$(EXEEXT)'; \
+	b='parse_time-test'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
 .test.log:
 	@p='$<'; \
 	$(am__set_b); \
@@ -1298,10 +1447,14 @@ clean-am: clean-checkPROGRAMS clean-generic clean-libtool \
 	mostlyclean-am
 
 distclean: distclean-recursive
-		-rm -f ./$(DEPDIR)/job-resources-test.Po
+		-rm -f ./$(DEPDIR)/data_test-data-test.Po
+	-rm -f ./$(DEPDIR)/job-resources-test.Po
 	-rm -f ./$(DEPDIR)/log-test.Po
 	-rm -f ./$(DEPDIR)/pack-test.Po
+	-rm -f ./$(DEPDIR)/parse_time_test-parse_time-test.Po
+	-rm -f ./$(DEPDIR)/slurm_opt_test-slurm_opt-test.Po
 	-rm -f ./$(DEPDIR)/xhash_test-xhash-test.Po
+	-rm -f ./$(DEPDIR)/xstring_test-xstring-test.Po
 	-rm -f ./$(DEPDIR)/xtree_test-xtree-test.Po
 	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
@@ -1348,10 +1501,14 @@ install-ps-am:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-		-rm -f ./$(DEPDIR)/job-resources-test.Po
+		-rm -f ./$(DEPDIR)/data_test-data-test.Po
+	-rm -f ./$(DEPDIR)/job-resources-test.Po
 	-rm -f ./$(DEPDIR)/log-test.Po
 	-rm -f ./$(DEPDIR)/pack-test.Po
+	-rm -f ./$(DEPDIR)/parse_time_test-parse_time-test.Po
+	-rm -f ./$(DEPDIR)/slurm_opt_test-slurm_opt-test.Po
 	-rm -f ./$(DEPDIR)/xhash_test-xhash-test.Po
+	-rm -f ./$(DEPDIR)/xstring_test-xstring-test.Po
 	-rm -f ./$(DEPDIR)/xtree_test-xtree-test.Po
 	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
diff --git a/testsuite/slurm_unit/common/data-test.c b/testsuite/slurm_unit/common/data-test.c
new file mode 100644
index 0000000000..b42e860817
--- /dev/null
+++ b/testsuite/slurm_unit/common/data-test.c
@@ -0,0 +1,371 @@
+/*****************************************************************************\
+ *  Copyright (C) 2019 SchedMD LLC
+ *  Written by Nathan Rini <nate@schedmd.com>
+ *
+ *  This file is part of Slurm, a resource management program.
+ *  For details, see <https://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  Slurm is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  Slurm is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with Slurm; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+\*****************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <check.h>
+
+#include "slurm/slurm_errno.h"
+#include "src/common/data.h"
+#include "src/common/log.h"
+#include "src/common/xmalloc.h"
+#include "src/common/xstring.h"
+
+#define check_with_data_get_bool_converted(str, b)                          \
+	do {                                                                \
+		bool bres;                                                  \
+		int rc;                                                     \
+		data_set_string(d, str);                                    \
+		rc = data_get_bool_converted(d, &bres);                     \
+		ck_assert_msg(rc == 0,                                      \
+			      "bool convert string:%s->%s rc:%s [%d]",      \
+			      str ? str : "(null)", (b ? "true" : "false"),	\
+			      slurm_strerror(rc), rc);                      \
+		if (!rc)                                                    \
+			ck_assert_msg(bres == b,                            \
+				      "bool converted: %s -> %s == %s",     \
+				      str ? str : "(null)", (bres ? "true" : "false"), \
+				      (b ? "true" : "false"));              \
+	} while (0);
+
+static data_for_each_cmd_t
+	_find_dict_bool(const char *key, const data_t *data, void *arg)
+{
+	int *found = arg;
+
+	ck_assert_msg(data_get_type(data) == DATA_TYPE_BOOL, "entry bool type");
+
+	if (data_get_bool(data))
+		(*found)++;
+
+	ck_assert_ptr_ne(key, NULL);
+	return DATA_FOR_EACH_CONT;
+}
+
+static data_for_each_cmd_t
+	_invert_dict_bool(const char *key, data_t *data, void *arg)
+{
+	ck_assert_msg(data_get_type(data) == DATA_TYPE_BOOL, "entry bool type");
+	ck_assert_ptr_ne(key, NULL);
+	data_set_bool(data, !data_get_bool(data));
+	return DATA_FOR_EACH_CONT;
+}
+
+static data_for_each_cmd_t
+	_del_dict_bool_true(const char *key, data_t *data, void *arg)
+{
+	int *max = arg;
+
+	ck_assert_ptr_ne(key, NULL);
+	ck_assert_msg(data_get_type(data) == DATA_TYPE_BOOL, "entry bool type");
+
+	if (*max <= 0)
+		return DATA_FOR_EACH_STOP;
+
+	if (data_get_bool(data)) {
+		*max -= 1;
+		return DATA_FOR_EACH_DELETE;
+	}
+
+	return DATA_FOR_EACH_CONT;
+}
+
+static data_for_each_cmd_t _del_list_odd(data_t *data, void *arg)
+{
+	int *max = arg;
+
+	ck_assert_msg(data_get_type(data) == DATA_TYPE_INT_64,
+		      "entry int type");
+
+	if (*max <= 0)
+		return DATA_FOR_EACH_STOP;
+
+	if (data_get_int(data) % 2 == 1) {
+		*max -= 1;
+		return DATA_FOR_EACH_DELETE;
+	}
+
+	return DATA_FOR_EACH_CONT;
+}
+
+data_for_each_cmd_t _check_list_order(const data_t *data, void *arg)
+{
+	int *found = arg;
+
+	ck_assert_msg(data_get_int(data) == *found,
+		      "check value");
+
+	*found += 1;
+	return DATA_FOR_EACH_CONT;
+}
+
+
+START_TEST(test_list_iteration)
+{
+	int max;
+	int found = 0;
+	data_t *d = data_new();
+	data_set_list(d);
+
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_LIST, "check list type");
+
+	data_set_int(data_list_append(d), 5);
+	data_set_int(data_list_prepend(d), 4);
+	data_set_int(data_list_append(d), 6);
+	data_set_int(data_list_prepend(d), 3);
+	data_set_int(data_list_append(d), 7);
+	data_set_int(data_list_prepend(d), 2);
+	data_set_int(data_list_append(d), 8);
+	data_set_int(data_list_prepend(d), 1);
+	data_set_int(data_list_append(d), 9);
+	data_set_int(data_list_prepend(d), 0);
+
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_LIST, "check list type");
+	ck_assert_msg(data_get_list_length(d) == 10, "list count");
+
+	found = 0;
+	ck_assert_msg(data_list_for_each_const(d, _check_list_order, &found) ==
+		      10, "order touch count");
+	ck_assert_msg(found == 10, "check max found");
+
+	data_set_int(data_list_append(d), 10);
+
+	found = 0;
+	ck_assert_msg(data_list_for_each_const(d, _check_list_order, &found) ==
+		      11, "order touch count");
+	ck_assert_msg(found == 11, "check max found");
+
+	max = 1;
+	data_list_for_each(d, _del_list_odd, &max);
+	ck_assert_msg(data_get_list_length(d) == 10, "list count");
+	ck_assert_msg(max == 0, "check remove count");
+
+	max = 20;
+	data_list_for_each(d, _del_list_odd, &max);
+	ck_assert_msg(data_get_list_length(d) == 6, "list count");
+	ck_assert_msg(max == 16, "check remove count");
+
+	FREE_NULL_DATA(d);
+}
+END_TEST
+
+START_TEST(test_dict_iteration)
+{
+	int max;
+	int found = 0;
+	data_t *d = data_new();
+	data_set_dict(d);
+
+	data_set_bool(data_key_set(d, "true1"), true);
+	data_set_bool(data_key_set(d, "true2"), true);
+	data_set_bool(data_key_set(d, "true3"), true);
+	data_set_bool(data_key_set(d, "true4"), true);
+	data_set_bool(data_key_set(d, "true5"), true);
+	data_set_bool(data_key_set(d, "false1"), false);
+	data_set_bool(data_key_set(d, "false2"), false);
+	data_set_bool(data_key_set(d, "false3"), false);
+	data_set_bool(data_key_set(d, "false4"), false);
+	data_set_bool(data_key_set(d, "false5"), false);
+	ck_assert_msg(data_get_dict_length(d) == 10, "dict cardinality");
+	ck_assert_msg(data_dict_for_each_const(d, _find_dict_bool, &found) ==
+		      10, "find true");
+	ck_assert_msg(found == 5, "found true");
+
+	ck_assert_msg(data_dict_for_each(d, _invert_dict_bool, NULL) == 10,
+		      "invert true");
+	ck_assert_msg(data_get_dict_length(d) == 10, "dict cardinality");
+	found = 0;
+	ck_assert_msg(data_dict_for_each_const(d, _find_dict_bool, &found) ==
+		      10, "find true");
+	ck_assert_msg(found == 5, "found true");
+
+	max = 1;
+	data_dict_for_each(d, _del_dict_bool_true, &max);
+	ck_assert_msg(max == 0, "remove 1 true");
+
+	found = 0;
+	ck_assert_msg(data_dict_for_each_const(d, _find_dict_bool, &found) == 9,
+		      "find true");
+	ck_assert_msg(found == 4, "found true");
+	ck_assert_msg(data_get_dict_length(d) == 9, "dict cardinality");
+
+	max = 0;
+	data_dict_for_each(d, _del_dict_bool_true, &max);
+	ck_assert_msg(max == 0, "no op remove");
+	ck_assert_msg(data_get_dict_length(d) == 9,
+		      "dict cardinality after no op");
+
+	max = 4;
+	data_dict_for_each(d, _del_dict_bool_true, &max);
+	ck_assert_msg(max == 0, "remove all true");
+	ck_assert_msg(data_get_dict_length(d) == 5, "dict cardinality");
+
+	FREE_NULL_DATA(d);
+}
+END_TEST
+
+START_TEST(test_dict_typeset)
+{
+	data_t *d = data_new();
+
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_NULL, "default type");
+	data_set_dict(d);
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_DICT, "dict type");
+	ck_assert_msg(data_get_dict_length(d) == 0, "dict cardinality");
+	data_key_set(d, "test1");
+	data_key_set(d, "test2");
+	data_key_set(d, "test3");
+	data_key_set(d, "test4");
+	data_key_set(d, "test5");
+	ck_assert_msg(data_get_dict_length(d) == 5, "dict cardinality");
+
+	data_set_list(d);
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_LIST, "list type");
+	ck_assert_msg(data_get_list_length(d) == 0, "list cardinality");
+	data_list_append(d);
+	data_list_prepend(d);
+	data_list_prepend(d);
+	data_list_append(d);
+	data_list_append(d);
+	ck_assert_msg(data_get_list_length(d) == 5, "list cardinality");
+
+	data_set_int(d, 100);
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_INT_64, "int type");
+	ck_assert_msg(data_get_int(d) == 100, "check int value");
+
+	char *str = NULL;
+	ck_assert_msg(data_get_string_converted(d, &str) == 0,
+		      "convert 100 to string");
+	ck_assert_msg(xstrcmp(str, "100") == 0, "check 100 got converted");
+	xfree(str);
+
+	ck_assert_msg(data_convert_type(d, DATA_TYPE_STRING) ==
+		      DATA_TYPE_STRING, "convert 100 to string");
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_STRING, "int type");
+	ck_assert_msg(xstrcmp(data_get_string(d), "100") == 0,
+		      "check 100 got converted");
+
+	int64_t b = 0;
+	ck_assert_msg(data_get_int_converted(d, &b) == 0,
+		      "convert 100 from string");
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_STRING,
+		      "check still string type");
+	ck_assert_msg(b == 100, "check string conversion from 100");
+
+	ck_assert_msg(data_convert_type(d, DATA_TYPE_INT_64) ==
+		      DATA_TYPE_INT_64, "convert 100 from string");
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_INT_64, "int type");
+	ck_assert_msg(data_get_int(d) == 100,
+		      "check string conversion from 100");
+
+	data_set_float(d, 3.14);
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_FLOAT, "float type");
+
+	str = NULL;
+	ck_assert_msg(data_get_string_converted(d, &str) == 0,
+		      "convert 3.14 to string");
+	ck_assert_msg(xstrcmp(str, "3.140000") == 0,
+		      "check 3.14 got converted");
+	xfree(str);
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_FLOAT, "float type");
+
+	ck_assert_msg(data_convert_type(d, DATA_TYPE_FLOAT) == DATA_TYPE_FLOAT,
+		      "convert 100 from string");
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_FLOAT, "int type");
+	ck_assert_msg(data_get_float(d) == 3.14,
+		      "check string conversion from 3.14");
+
+	data_set_null(d);
+	ck_assert_msg(data_get_type(d) == DATA_TYPE_NULL, "default type");
+
+	FREE_NULL_DATA(d);
+	ck_assert_msg(d == NULL, "free check");
+}
+END_TEST
+
+START_TEST(test_detection)
+{
+	data_t *d = data_new();
+
+	check_with_data_get_bool_converted("1", true);
+	check_with_data_get_bool_converted("100", true);
+	check_with_data_get_bool_converted("-100", true);
+	check_with_data_get_bool_converted("true", true);
+	check_with_data_get_bool_converted("taco", true);
+	check_with_data_get_bool_converted("0", false);
+	check_with_data_get_bool_converted("false", false);
+	check_with_data_get_bool_converted("-0", false);
+	check_with_data_get_bool_converted(NULL, false);
+
+	FREE_NULL_DATA(d);
+}
+END_TEST
+
+Suite *suite_data(void)
+{
+	Suite *s = suite_create("Data");
+	TCase *tc_core = tcase_create("Data");
+
+	tcase_add_test(tc_core, test_detection);
+	tcase_add_test(tc_core, test_dict_typeset);
+	tcase_add_test(tc_core, test_dict_iteration);
+	tcase_add_test(tc_core, test_list_iteration);
+
+	suite_add_tcase(s, tc_core);
+	return s;
+}
+
+int main(void)
+{
+	int number_failed;
+
+	log_options_t log_opts = LOG_OPTS_INITIALIZER;
+	log_opts.stderr_level = LOG_LEVEL_DEBUG5;
+	log_init("data-test", log_opts, 0, NULL);
+
+	if(data_init_static()) {
+		error("data_init_static() failed");
+		return EXIT_FAILURE;
+	}
+
+	SRunner *sr = srunner_create(suite_data());
+
+	srunner_run_all(sr, CK_ENV);
+	number_failed = srunner_ntests_failed(sr);
+	srunner_free(sr);
+
+	data_destroy_static();
+	return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
diff --git a/testsuite/slurm_unit/common/parse_time-test.c b/testsuite/slurm_unit/common/parse_time-test.c
new file mode 100644
index 0000000000..b483427c55
--- /dev/null
+++ b/testsuite/slurm_unit/common/parse_time-test.c
@@ -0,0 +1,95 @@
+/*****************************************************************************\
+ *  parse_time-test.c - unit test for parse_time.c
+ *****************************************************************************
+ *  Copyright (C) 2021 SchedMD LLC.
+ *  Written by Chad Vizino <chad@schedmd.com>
+ *
+ *  This file is part of Slurm, a resource management program.
+ *  For details, see <https://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  Slurm is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  Slurm is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with Slurm; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+\*****************************************************************************/
+
+#include <check.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "slurm/slurm.h"
+#include "src/common/parse_time.h"
+
+START_TEST(test_time_str2secs)
+{
+	ck_assert_int_eq(time_str2secs(NULL), (int)NO_VAL);
+	ck_assert_int_eq(time_str2secs(""), (int)NO_VAL);
+	ck_assert_int_eq(time_str2secs("INVALID TIME"), (int)NO_VAL);
+	ck_assert_int_eq(time_str2secs("-1"), (int)INFINITE);
+	ck_assert_int_eq(time_str2secs("INFINITE"), (int)INFINITE);
+	ck_assert_int_eq(time_str2secs("infinite"), (int)INFINITE);
+	ck_assert_int_eq(time_str2secs("UNLIMITED"), (int)INFINITE);
+	ck_assert_int_eq(time_str2secs("unlimited"), (int)INFINITE);
+	ck_assert_int_eq(time_str2secs("LONG --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- INVALID TIME"), (int)NO_VAL);
+	ck_assert_int_eq(time_str2secs("0"), 0);
+	ck_assert_int_eq(time_str2secs("60"), 60*60);
+	ck_assert_int_eq(time_str2secs("60:15"), 60*60 + 15);
+	ck_assert_int_eq(time_str2secs("60:0"), 60*60);
+	ck_assert_int_eq(time_str2secs("60:"), (int)NO_VAL);
+	ck_assert_int_eq(time_str2secs("60:-10"), (int)NO_VAL);
+	ck_assert_int_eq(time_str2secs("-60:10"), (int)NO_VAL);
+	ck_assert_int_eq(time_str2secs("1:60:15"), 1*60*60 + 60*60 + 15);
+	ck_assert_int_eq(time_str2secs("2:60:15"), 2*60*60 + 60*60 + 15);
+	ck_assert_int_eq(time_str2secs("0:0:15"), 15);
+	ck_assert_int_eq(time_str2secs("0:60:0"), 60*60);
+	ck_assert_int_eq(time_str2secs("0:0:0"), 0);
+	ck_assert_int_eq(time_str2secs("-0:-0:-0"), (int)NO_VAL);
+	ck_assert_int_eq(time_str2secs(" 0:0:0 "), (int)NO_VAL);
+	ck_assert_int_eq(time_str2secs("0-1:60:15"), 1*60*60 + 60*60 + 15);
+	ck_assert_int_eq(time_str2secs("1-1:60:15"), 1*60*60*24 + 1*60*60 + 60*60 + 15);
+	ck_assert_int_eq(time_str2secs("365-1:60:15"), 365*60*60*24 + 1*60*60 + 60*60 + 15);
+	ck_assert_int_eq(time_str2secs("365-0:0:0"), 365*60*60*24);
+}
+END_TEST
+
+Suite *parse_time_suite(void)
+{
+	Suite *s = suite_create("parse_time");
+	TCase *tc_core = tcase_create("parse_time");
+	tcase_add_test(tc_core, test_time_str2secs);
+	suite_add_tcase(s, tc_core);
+	return s;
+}
+
+int main(void)
+{
+	int number_failed;
+	SRunner *sr = srunner_create(parse_time_suite());
+
+	srunner_run_all(sr, CK_ENV);
+	number_failed = srunner_ntests_failed(sr);
+	srunner_free(sr);
+
+	return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
diff --git a/testsuite/slurm_unit/common/slurm_opt-test.c b/testsuite/slurm_unit/common/slurm_opt-test.c
new file mode 100644
index 0000000000..cc9e9c8981
--- /dev/null
+++ b/testsuite/slurm_unit/common/slurm_opt-test.c
@@ -0,0 +1,814 @@
+/*****************************************************************************\
+ *  Copyright (C) 2019 SchedMD LLC
+ *  Written by Nathan Rini <nate@schedmd.com>
+ *
+ *  This file is part of Slurm, a resource management program.
+ *  For details, see <https://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  Slurm is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  Slurm is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with Slurm; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+\*****************************************************************************/
+
+#include <check.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "slurm/slurm_errno.h"
+#include "src/common/log.h"
+#include "src/common/parse_time.h"
+#include "src/common/read_config.h"
+#include "src/common/slurm_opt.h"
+#include "src/common/slurm_protocol_defs.h"
+#include "src/common/uid.h"
+#include "src/common/xmalloc.h"
+#include "src/common/xstring.h"
+
+static void _help(void)
+{
+}
+
+static void _usage(void)
+{
+}
+
+START_TEST(test_data_job_macros)
+{
+	char *opt_string = NULL;
+	sbatch_opt_t sbopt = { 0 };
+	srun_opt_t sropt = { 0 };
+	slurm_opt_t opt = { .sbatch_opt = &sbopt,
+			    .srun_opt = &sropt,
+			    .help_func = _help,
+			    .usage_func = _usage };
+	struct option *spanked = slurm_option_table_create(&opt, &opt_string);
+	data_t *errors = data_set_list(data_new());
+	data_t *arg = data_new();
+	slurm_reset_all_options(&opt, true);
+
+	/* COMMON_STRING_OPTION */
+	data_set_string(arg, "wckey");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_WCKEY, arg,
+						errors) == 0, "LONG_OPT_WCKEY");
+	ck_assert_msg(!xstrcmp(opt.wckey, "wckey"), "wckey");
+	/* COMMON_SBATCH_STRING_OPTION */
+	data_set_bool(arg, true);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_BATCH, arg,
+						errors) == 0, "LONG_OPT_BATCH");
+	ck_assert_msg(!xstrcmp(opt.sbatch_opt->batch_features, "true"),
+		      "batch_features");
+	/* COMMON_BOOL_OPTION */
+	data_set_bool(arg, true);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_CONTIGUOUS, arg,
+						errors) == 0,
+		      "LONG_OPT_CONTIGUOUS=true");
+	ck_assert_msg(opt.contiguous == true, "contiguous=true");
+	data_set_bool(arg, false);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_CONTIGUOUS, arg,
+						errors) == 0,
+		      "LONG_OPT_CONTIGUOUS=false");
+	ck_assert_msg(opt.contiguous == false, "contiguous=false");
+	/* COMMON_INT_OPTION */
+	data_set_string(arg, "12345");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_CPUS_PER_GPU,
+						arg, errors) == 0,
+		      "LONG_OPT_CPUS_PER_GPU");
+	ck_assert_msg(opt.cpus_per_gpu == 12345, "cpus_per_gpu");
+	data_set_string(arg, "0");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_CPUS_PER_GPU,
+						arg, errors) == 0,
+		      "LONG_OPT_CPUS_PER_GPU");
+	ck_assert_msg(opt.cpus_per_gpu == 0, "cpus_per_gpu");
+	/* COMMON_MBYTES_OPTION */
+	data_set_string(arg, "1");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_TMP, arg,
+						errors) == 0, "LONG_OPT_TMP");
+	ck_assert_msg(opt.pn_min_tmp_disk == 1, "pn_min_tmp_disk");
+	data_set_string(arg, "1k");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_TMP, arg,
+						errors) == 0, "LONG_OPT_TMP");
+	ck_assert_msg(opt.pn_min_tmp_disk == 1, "pn_min_tmp_disk");
+	data_set_string(arg, "10M");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_TMP, arg,
+						errors) == 0, "LONG_OPT_TMP");
+	ck_assert_msg(opt.pn_min_tmp_disk == 10, "pn_min_tmp_disk");
+
+	slurm_option_table_destroy(spanked);
+	xfree(opt_string);
+	FREE_NULL_DATA(arg);
+	FREE_NULL_DATA(errors);
+	slurm_free_options_members(&opt);
+}
+END_TEST
+
+/* test non-macro options */
+START_TEST(test_data_job)
+{
+	char *opt_string = NULL;
+	sbatch_opt_t sbopt = { 0 };
+	srun_opt_t sropt = { 0 };
+	salloc_opt_t saopt = { 0 };
+	slurm_opt_t opt = { .sbatch_opt = &sbopt,
+			    .srun_opt = &sropt,
+			    .salloc_opt = &saopt,
+			    .help_func = _help,
+			    .usage_func = _usage };
+	struct option *spanked = slurm_option_table_create(&opt, &opt_string);
+	data_t *errors = data_set_list(data_new());
+	data_t *arg = data_new();
+	slurm_reset_all_options(&opt, true);
+
+	data_set_string(arg, "2000-01-01");
+	ck_assert_msg(slurm_process_option_data(&opt, 'b', arg, errors) == 0,
+		      "begin");
+	ck_assert_msg(opt.begin == parse_time("2000-01-01", 0), "begin value");
+
+	data_set_string(arg, "invalid time");
+	ck_assert_msg(slurm_process_option_data(&opt, 'b', arg, errors) != 0,
+		      "begin");
+	ck_assert_msg(opt.begin == 0, "begin invalid");
+
+	data_set_string(arg, "2");
+	ck_assert_msg(slurm_process_option_data(&opt, 'S', arg, errors) == 0,
+		      "core spec");
+	ck_assert_msg(opt.core_spec == 2, "core spec 2");
+	ck_assert_msg(opt.srun_opt->core_spec_set == true, "core spec set");
+
+	data_set_string(arg, "0");
+	ck_assert_msg(slurm_process_option_data(&opt, 'S', arg, errors) == 0,
+		      "core spec");
+	ck_assert_msg(opt.core_spec == 0, "core spec 0");
+	ck_assert_msg(opt.srun_opt->core_spec_set == false, "core spec unset");
+
+	opt.core_spec = 1234;
+	opt.srun_opt->core_spec_set = true;
+
+	data_set_string(arg, "taco");
+	ck_assert_msg(slurm_process_option_data(&opt, 'S', arg, errors) != 0,
+		      "core spec");
+	ck_assert_msg(opt.core_spec == 1234, "core spec nochange");
+	ck_assert_msg(opt.srun_opt->core_spec_set == true,
+		      "core spec nochange");
+
+	/* force enable all governors */
+	slurmctld_conf.cpu_freq_govs = 0xffffffff;
+	data_set_string(arg, "10-100:PowerSave");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_CPU_FREQ, arg,
+						errors) == 0, "cpu freq");
+	ck_assert_msg(opt.cpu_freq_min == 10, "cpu min freq");
+	ck_assert_msg(opt.cpu_freq_max == 100, "cpu max freq");
+	ck_assert_msg(opt.cpu_freq_gov == (CPU_FREQ_POWERSAVE |
+					   CPU_FREQ_RANGE_FLAG),
+		      "cpu freq gov");
+
+	data_set_string(arg, "low-highm1:Performance");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_CPU_FREQ, arg,
+						errors) == 0, "cpu freq");
+	ck_assert_msg(opt.cpu_freq_min == CPU_FREQ_LOW, "cpu min freq");
+	ck_assert_msg(opt.cpu_freq_max == CPU_FREQ_HIGHM1, "cpu max freq");
+	ck_assert_msg(opt.cpu_freq_gov == (CPU_FREQ_PERFORMANCE |
+					   CPU_FREQ_RANGE_FLAG),
+		      "cpu freq gov");
+
+	opt.cpu_freq_min = 12345;
+	opt.cpu_freq_max = 12345;
+	opt.cpu_freq_gov = 12345;
+	data_set_string(arg, "Performance");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_CPU_FREQ, arg,
+						errors) == 0, "cpu freq");
+	ck_assert_msg(opt.cpu_freq_min == NO_VAL, "cpu min freq");
+	ck_assert_msg(opt.cpu_freq_max == NO_VAL, "cpu max freq");
+	ck_assert_msg(opt.cpu_freq_gov == (CPU_FREQ_PERFORMANCE |
+					   CPU_FREQ_RANGE_FLAG),
+		      "cpu freq gov");
+
+	opt.cpu_freq_min = 12345;
+	opt.cpu_freq_max = 12345;
+	opt.cpu_freq_gov = 12345;
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_CPU_FREQ, arg,
+						errors) != 0, "cpu freq");
+	ck_assert_msg(opt.cpu_freq_min == NO_VAL, "cpu min freq");
+	ck_assert_msg(opt.cpu_freq_max == NO_VAL, "cpu max freq");
+	ck_assert_msg(opt.cpu_freq_gov == NO_VAL, "cpu freq gov");
+
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, 'c', arg, errors) != 0,
+		      "cpus per task");
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, 'c', arg, errors) != 0,
+		      "cpus per task");
+	data_set_string(
+		arg,
+		"99999999999999999999999999999999999999999999999999999999");
+	ck_assert_msg(slurm_process_option_data(&opt, 'c', arg, errors) != 0,
+		      "cpus per task");
+	data_set_string(arg, "-1");
+	ck_assert_msg(slurm_process_option_data(&opt, 'c', arg, errors) != 0,
+		      "cpus per task");
+	data_set_string(arg, "0");
+	ck_assert_msg(slurm_process_option_data(&opt, 'c', arg, errors) != 0,
+		      "cpus per task");
+	data_set_int(arg, 0);
+	ck_assert_msg(slurm_process_option_data(&opt, 'c', arg, errors) != 0,
+		      "cpus per task");
+	data_set_int(arg, 10);
+	ck_assert_msg(slurm_process_option_data(&opt, 'c', arg, errors) == 0,
+		      "cpus per task");
+	ck_assert_msg(opt.cpus_per_task == 10, "cpus per task 10");
+	ck_assert_msg(opt.cpus_set == true, "cpus set");
+
+	data_set_string(arg, "2000-01-01");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_DEADLINE, arg,
+						errors) == 0, "deadline");
+	ck_assert_msg(opt.deadline == parse_time("2000-01-01", 0),
+		      "deadline value");
+	data_set_string(arg, "invalid time");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_DEADLINE, arg,
+						errors) != 0, "deadline");
+	ck_assert_msg(opt.deadline == 0, "deadline invalid");
+
+	data_set_string(arg, "60");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_DELAY_BOOT, arg,
+						errors) == 0, "delay boot");
+	ck_assert_msg(opt.delay_boot == (60 * 60), "delay boot value");
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_DELAY_BOOT, arg,
+						errors) != 0, "delay boot");
+
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, 'm', arg, errors) != 0,
+		      "distribution");
+	ck_assert_msg(opt.distribution == SLURM_DIST_UNKNOWN,
+		      "distribution value");
+	ck_assert_msg(opt.plane_size == NO_VAL, "distribution value");
+
+	data_set_string(arg, "cyclic:block:fcyclic");
+	ck_assert_msg(slurm_process_option_data(&opt, 'm', arg, errors) == 0,
+		      "distribution");
+	ck_assert_msg(opt.distribution == SLURM_DIST_CYCLIC_BLOCK_CFULL,
+		      "distribution value");
+	ck_assert_msg(opt.plane_size == NO_VAL, "distribution value");
+
+	data_set_string(arg, "plane=10");
+	ck_assert_msg(slurm_process_option_data(&opt, 'm', arg, errors) == 0,
+		      "distribution");
+	ck_assert_msg(opt.distribution == SLURM_DIST_PLANE,
+		      "distribution value");
+	ck_assert_msg(opt.plane_size == 10, "distribution value");
+
+	data_set_string(arg, "/dev/stderr");
+	ck_assert_msg(slurm_process_option_data(&opt, 'e', arg, errors) == 0,
+		      "stderr");
+	ck_assert_msg(!xstrcmp(opt.efname, "/dev/stderr"), "stderr value");
+	data_set_string(arg, "none");
+	ck_assert_msg(slurm_process_option_data(&opt, 'e', arg, errors) == 0,
+		      "stderr");
+	ck_assert_msg(!xstrcmp(opt.efname, "/dev/null"), "stderr value");
+
+	data_set_string(arg, "exclusive");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_EXCLUSIVE, arg,
+						errors) == 0, "exclusive");
+	ck_assert_msg(opt.shared == JOB_SHARED_NONE, "exclusive value");
+	ck_assert_msg(opt.srun_opt->exclusive == true, "srun excl");
+
+	data_set_string(arg, "tacos");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_EXCLUSIVE, arg,
+						errors) != 0, "exclusive");
+
+	data_set_string(arg, "tacos");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GET_USER_ENV,
+						arg, errors) != 0,
+		      "get user env");
+
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GET_USER_ENV,
+						arg, errors) == 0,
+		      "get user env");
+	ck_assert_msg(opt.get_user_env_time == 0, "get user env timeout");
+	ck_assert_msg(opt.get_user_env_mode == -1, "get user mode");
+
+	data_set_string(arg, "10l");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GET_USER_ENV,
+						arg, errors) == 0,
+		      "get user env");
+	ck_assert_msg(opt.get_user_env_time == 10, "get user env timeout");
+	ck_assert_msg(opt.get_user_env_mode == 2, "get user mode");
+
+	opt.gid = NO_VAL;
+	data_set_string(arg, "invalid-group-tacos");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GID, arg, errors)
+		      != 0, "gid");
+	ck_assert_msg(opt.gid == NO_VAL, "gid value");
+	/* verify that group of slurmuser can be used */
+	data_set_string(arg, slurmctld_conf.slurm_user_name);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GID, arg, errors)
+		      == 0, "gid");
+	ck_assert_msg(opt.gid == gid_from_uid(slurmctld_conf.slurm_user_id),
+		      "gid value");
+
+	data_set_string(arg, "help");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GRES, arg,
+						errors) != 0, "gres");
+	data_set_string(arg, "list");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GRES, arg,
+						errors) != 0, "gres");
+	data_set_string(arg, "gpu:10");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GRES, arg,
+						errors) == 0, "gres");
+	ck_assert_msg(!xstrcmp(opt.gres, "gpu:10"), "gres value");
+
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GRES_FLAGS, arg,
+						errors) != 0, "gres flags");
+	opt.job_flags = 0;
+	data_set_string(arg, "disable-binding");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GRES_FLAGS, arg,
+						errors) == 0, "gres flags");
+	ck_assert_msg(opt.job_flags == GRES_DISABLE_BIND, "gres flags value");
+	opt.job_flags = 0;
+	data_set_string(arg, "enforce-binding");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_GRES_FLAGS, arg,
+						errors) == 0, "gres flags");
+	ck_assert_msg(opt.job_flags == GRES_ENFORCE_BIND, "gres flags value");
+
+	data_set_string(arg, "/dev/stdin");
+	ck_assert_msg(slurm_process_option_data(&opt, 'i', arg, errors) == 0,
+		      "stdin");
+	ck_assert_msg(!xstrcmp(opt.ifname, "/dev/stdin"), "stdin value");
+	data_set_string(arg, "none");
+	ck_assert_msg(slurm_process_option_data(&opt, 'i', arg, errors) == 0,
+		      "stdin");
+	ck_assert_msg(!xstrcmp(opt.ifname, "/dev/null"), "stdin value");
+
+	opt.job_flags = 0;
+	data_set_string(arg, "true");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_KILL_INV_DEP,
+						arg, errors) == 0,
+		      "kill on invalid dep");
+	ck_assert_msg(opt.job_flags == KILL_INV_DEP,
+		      "kill on invalid dep value");
+	opt.job_flags = 0;
+	data_set_string(arg, "false");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_KILL_INV_DEP,
+						arg, errors) == 0,
+		      "kill on invalid dep");
+	ck_assert_msg(opt.job_flags == NO_KILL_INV_DEP,
+		      "kill on invalid dep value");
+	opt.job_flags = 0;
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_KILL_INV_DEP,
+						arg, errors) == 0,
+		      "kill on invalid dep");
+	ck_assert_msg(opt.job_flags == NO_KILL_INV_DEP,
+		      "kill on invalid dep value");
+
+	opt.mail_type = 0;
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_MAIL_TYPE, arg,
+						errors) != 0,
+		      "kill on invalid dep");
+	ck_assert_msg(opt.mail_type == INFINITE16, "kill on invalid dep value");
+	opt.mail_type = 0;
+	data_set_string(arg, "BEGIN,END");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_MAIL_TYPE, arg,
+						errors) == 0, "mail type");
+	ck_assert_msg(opt.mail_type == (MAIL_JOB_BEGIN | MAIL_JOB_END),
+		      "mail type value");
+	opt.mail_type = 0;
+	data_set_string(arg, "none");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_MAIL_TYPE, arg,
+						errors) == 0, "mail type");
+	ck_assert_msg(opt.mail_type == 0, "mail type value");
+
+	data_set_string(arg, "-1");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_MEM, arg, errors)
+		      != 0, "memory");
+	data_set_string(arg, "10M");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_MEM, arg, errors)
+		      == 0, "memory");
+	ck_assert_msg(opt.pn_min_memory == 10, "memory value");
+
+	data_set_string(arg, "-1");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_MEM_BIND, arg,
+						errors) != 0, "memory bind");
+	data_set_string(arg, "help");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_MEM_BIND, arg,
+						errors) != 0, "memory bind");
+	opt.mem_bind_type = 0;
+	data_set_string(arg, "sort,verbose");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_MEM_BIND, arg,
+						errors) == 0, "memory bind");
+	ck_assert_msg(opt.mem_bind == 0, "memory bind value");
+	ck_assert_msg(opt.mem_bind_type == (MEM_BIND_SORT | MEM_BIND_VERBOSE),
+		      "memory bind type value");
+	opt.mem_bind_type = 0;
+	xfree(opt.mem_bind);
+	data_set_string(arg, "rank");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_MEM_BIND, arg,
+						errors) == 0, "memory bind");
+	ck_assert_msg(opt.mem_bind == 0, "memory bind value");
+	ck_assert_msg(opt.mem_bind_type == MEM_BIND_RANK,
+		      "memory bind type value");
+	opt.mem_bind_type = 0;
+	xfree(opt.mem_bind);
+	data_set_string(arg, "MAP_MEM:0,1");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_MEM_BIND, arg,
+						errors) == 0, "memory bind");
+	ck_assert_msg(!xstrcmp(opt.mem_bind, "0,1"), "memory bind value");
+	ck_assert_msg(opt.mem_bind_type == MEM_BIND_MAP,
+		      "memory bind type value");
+
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_NICE, arg,
+						errors) == 0, "nice");
+	ck_assert_msg(opt.nice == 100, "nice value");
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_NICE, arg,
+						errors) != 0, "nice");
+	data_set_string(arg, "900000000000000000000000");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_NICE, arg,
+						errors) != 0, "nice");
+
+	data_set_string(arg, "set");
+	ck_assert_msg(slurm_process_option_data(&opt, 'k', arg, errors) == 0,
+		      "no kill");
+	ck_assert_msg(opt.no_kill == true, "no kill value");
+	data_set_string(arg, "off");
+	ck_assert_msg(slurm_process_option_data(&opt, 'k', arg, errors) == 0,
+		      "no kill");
+	ck_assert_msg(opt.no_kill == false, "no kill value");
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, 'k', arg, errors) == 0,
+		      "no kill");
+	ck_assert_msg(opt.no_kill == true, "no kill value");
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, 'k', arg, errors) != 0,
+		      "no kill");
+
+	opt.sbatch_opt->requeue = true;
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_NO_REQUEUE, arg,
+						errors) == 0, "no requeue");
+	ck_assert_msg(opt.sbatch_opt->requeue == false, "no requeue value");
+
+	data_set_string(arg, "hostlist");
+	ck_assert_msg(slurm_process_option_data(&opt, 'w', arg, errors) == 0,
+		      "nodelist");
+	ck_assert_msg(!xstrcmp(opt.nodelist, "hostlist"), "nodelist check");
+	ck_assert_msg(opt.nodefile == 0, "verify no nodefile");
+
+	data_set_string(arg, "1-2");
+	ck_assert_msg(slurm_process_option_data(&opt, 'N', arg, errors) == 0,
+		      "nodes");
+	ck_assert_msg(opt.min_nodes == 1, "min nodes count");
+	ck_assert_msg(opt.max_nodes == 2, "mxn nodes count");
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, 'N', arg, errors) != 0,
+		      "nodes");
+	data_set_list(arg);
+	data_set_string(data_list_append(arg), "10");
+	data_set_string(data_list_append(arg), "100");
+	ck_assert_msg(slurm_process_option_data(&opt, 'N', arg, errors) == 0,
+		      "nodes");
+	ck_assert_msg(opt.min_nodes == 10, "min nodes count");
+	ck_assert_msg(opt.max_nodes == 100, "mxn nodes count");
+	data_set_string(data_list_append(arg), "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, 'N', arg, errors) != 0,
+		      "nodes");
+
+	data_set_string(arg, "100");
+	ck_assert_msg(slurm_process_option_data(&opt, 'n', arg, errors) == 0,
+		      "ntasks");
+	ck_assert_msg(opt.ntasks == 100, "ntasks value");
+	ck_assert_msg(opt.ntasks_set == true, "ntasks value");
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, 'n', arg, errors) != 0,
+		      "ntasks");
+	data_set_string(arg, "-1");
+	ck_assert_msg(slurm_process_option_data(&opt, 'n', arg, errors) != 0,
+		      "ntasks");
+
+	data_set_string(arg, "append");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_OPEN_MODE, arg,
+						errors) == 0, "open mode");
+	ck_assert_msg(opt.sbatch_opt->open_mode == OPEN_MODE_APPEND,
+		      "open mode value");
+	ck_assert_msg(opt.srun_opt->open_mode == OPEN_MODE_APPEND,
+		      "open mode value");
+	data_set_string(arg, "truncate");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_OPEN_MODE, arg,
+						errors) == 0, "open mode");
+	ck_assert_msg(opt.sbatch_opt->open_mode == OPEN_MODE_TRUNCATE,
+		      "open mode value");
+	ck_assert_msg(opt.srun_opt->open_mode == OPEN_MODE_TRUNCATE,
+		      "open mode value");
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_OPEN_MODE, arg,
+						errors) != 0, "open mode");
+
+	data_set_string(arg, "/dev/stdout");
+	ck_assert_msg(slurm_process_option_data(&opt, 'o', arg, errors) == 0,
+		      "stdout");
+	ck_assert_msg(!xstrcmp(opt.ofname, "/dev/stdout"), "stdout value");
+	data_set_string(arg, "none");
+	ck_assert_msg(slurm_process_option_data(&opt, 'o', arg, errors) == 0,
+		      "stdout");
+	ck_assert_msg(!xstrcmp(opt.ofname, "/dev/null"), "stdout value");
+
+	opt.srun_opt->exclusive = true;
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, 's', arg, errors) == 0,
+		      "oversubscribe");
+	ck_assert_msg(opt.srun_opt->exclusive == false, "oversubscribe");
+
+	data_set_string(arg, "top");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_PRIORITY, arg,
+						errors) == 0, "priority");
+	ck_assert_msg(opt.priority == (NO_VAL - 1), "priority value");
+	data_set_string(arg, "100");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_PRIORITY, arg,
+						errors) == 0, "priority");
+	ck_assert_msg(opt.priority == 100, "priority value");
+	data_set_string(arg, "-100");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_PRIORITY, arg,
+						errors) != 0, "priority");
+	data_set_string(arg, "8832828382838283892839823928392");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_PRIORITY, arg,
+						errors) != 0, "priority");
+
+	opt.sbatch_opt->requeue = 12345;
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_REQUEUE, arg,
+						errors) == 0, "requeue");
+	ck_assert_msg(opt.sbatch_opt->requeue == 1, "requeue value");
+
+	opt.job_flags = 0;
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_SPREAD_JOB, arg,
+						errors) == 0, "spread value");
+	ck_assert_msg(opt.job_flags == SPREAD_JOB, "spread job value");
+
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_SWITCH_WAIT, arg,
+						errors) == 0, "switch wait");
+	ck_assert_msg(opt.wait4switch == NO_VAL, "switch wait value");
+	data_set_string(arg, "-1");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_SWITCH_WAIT, arg,
+						errors) == 0, "switch wait");
+	ck_assert_msg(opt.wait4switch == INFINITE, "switch wait value");
+	data_set_string(arg, "60");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_SWITCH_WAIT, arg,
+						errors) == 0, "switch wait");
+	ck_assert_msg(opt.wait4switch == (60 * 60), "switch wait value");
+
+	opt.wait4switch = 12345;
+	opt.req_switch = 1;
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_SWITCHES, arg,
+						errors) == 0, "switches");
+	ck_assert_msg(opt.req_switch == 0, "switches value");
+	ck_assert_msg(opt.wait4switch == 12345, "wait 4 switches value");
+	opt.wait4switch = 12345;
+	opt.req_switch = 1;
+	data_set_string(arg, "10@16");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_SWITCHES, arg,
+						errors) == 0, "switches");
+	ck_assert_msg(opt.req_switch == 10, "switches value");
+	ck_assert_msg(opt.wait4switch == (16 * 60), "wait 4 switches value");
+	opt.wait4switch = 12345;
+	opt.req_switch = 1;
+	data_set_string(arg, "10");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_SWITCHES, arg,
+						errors) == 0, "switches");
+	ck_assert_msg(opt.req_switch == 10, "switches value");
+	ck_assert_msg(opt.wait4switch == 12345, "wait 4 switches value");
+	data_set_dict(arg);
+	data_set_string(data_key_set(arg, "count"), "10");
+	data_set_string(data_key_set(arg, "timeout"), "16");
+	opt.wait4switch = 12345;
+	opt.req_switch = 1;
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_SWITCHES, arg,
+						errors) == 0, "switches");
+	ck_assert_msg(opt.req_switch == 10, "switches value");
+	ck_assert_msg(opt.wait4switch == (16 * 60), "wait 4 switches value");
+	data_set_dict(arg);
+	data_set_string(data_key_set(arg, "count"), "10");
+	opt.wait4switch = 12345;
+	opt.req_switch = 1;
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_SWITCHES, arg,
+						errors) == 0, "switches");
+	ck_assert_msg(opt.req_switch == 10, "switches value");
+	ck_assert_msg(opt.wait4switch == 12345, "wait 4 switches value");
+	data_set_dict(arg);
+	data_set_string(data_key_set(arg, "timeout"), "16");
+	opt.wait4switch = 12345;
+	opt.req_switch = 1;
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_SWITCHES, arg,
+						errors) == 0, "switches");
+	ck_assert_msg(opt.req_switch == 1, "switches value");
+	ck_assert_msg(opt.wait4switch == (16 * 60), "wait 4 switches value");
+
+	opt.sbatch_opt->test_only = 0;
+	opt.srun_opt->test_only = 0;
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_TEST_ONLY, arg,
+						errors) == 0, "test-only");
+	ck_assert_msg(opt.sbatch_opt->test_only == 1, "test-only value");
+	ck_assert_msg(opt.srun_opt->test_only == 1, "test-only value");
+
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_THREAD_SPEC, arg,
+						errors) != 0, "thread-spec");
+	data_set_string(arg, "1245");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_THREAD_SPEC, arg,
+						errors) == 0, "thread-spec");
+	ck_assert_msg(opt.core_spec == (1245 | CORE_SPEC_THREAD),
+		      "thread-spec value");
+	data_set_int(arg, CORE_SPEC_THREAD);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_THREAD_SPEC, arg,
+						errors) != 0, "thread-spec");
+	data_set_int(arg, 0);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_THREAD_SPEC, arg,
+						errors) != 0, "thread-spec");
+
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, 't', arg, errors) != 0,
+		      "time-limit");
+	data_set_string(arg, "0");
+	ck_assert_msg(slurm_process_option_data(&opt, 't', arg, errors) == 0,
+		      "time-limit");
+	ck_assert_msg(opt.time_limit == INFINITE, "time-limit value");
+	data_set_string(arg, "60");
+	ck_assert_msg(slurm_process_option_data(&opt, 't', arg, errors) == 0,
+		      "time-limit");
+	ck_assert_msg(opt.time_limit == 60, "time-limit value");
+
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_TIME_MIN, arg,
+						errors) != 0, "time-min");
+	data_set_string(arg, "0");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_TIME_MIN, arg,
+						errors) == 0, "time-min");
+	ck_assert_msg(opt.time_min == INFINITE, "time-min value");
+	data_set_string(arg, "60");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_TIME_MIN, arg,
+						errors) == 0, "time-min");
+	ck_assert_msg(opt.time_min == 60, "time_min value");
+
+	opt.uid = NO_VAL;
+	data_set_string(arg, "invalid-group-tacos");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_UID, arg, errors)
+		      != 0, "gid");
+	ck_assert_msg(opt.uid == NO_VAL, "uid value");
+	/* verify that slurmuser can be used */
+	data_set_string(arg, slurmctld_conf.slurm_user_name);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_UID, arg, errors)
+		      == 0, "uid");
+	ck_assert_msg(opt.uid == slurmctld_conf.slurm_user_id, "uid value");
+
+	data_set_string(arg, "invalid");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_UMASK, arg,
+						errors) != 0, "umask");
+	data_set_string(arg, "0770");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_UMASK, arg,
+						errors) == 0, "umask");
+	ck_assert_msg(opt.sbatch_opt->umask == 00770, "umask value");
+	data_set_string(arg, "0");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_UMASK, arg,
+						errors) == 0, "umask");
+	ck_assert_msg(opt.sbatch_opt->umask == 0, "umask value");
+
+	opt.job_flags = 0;
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_USE_MIN_NODES,
+						arg, errors) == 0,
+		      "use min nodes");
+	ck_assert_msg(opt.job_flags == USE_MIN_NODES, "use min nodes value");
+
+	data_set_null(arg);
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_WAIT_ALL_NODES,
+						arg, errors) != 0,
+		      "wait-all-nodes");
+	data_set_string(arg, "0");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_WAIT_ALL_NODES,
+						arg, errors) == 0,
+		      "wait-all-nodes");
+	ck_assert_msg(opt.salloc_opt->wait_all_nodes == 0,
+		      "wait-all-nodes value");
+	ck_assert_msg(opt.sbatch_opt->wait_all_nodes == 0,
+		      "wait-all-nodes value");
+	data_set_string(arg, "1");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_WAIT_ALL_NODES,
+						arg, errors) == 0,
+		      "wait-all-nodes");
+	ck_assert_msg(opt.salloc_opt->wait_all_nodes == 1,
+		      "wait-all-nodes value");
+	ck_assert_msg(opt.sbatch_opt->wait_all_nodes == 1,
+		      "wait-all-nodes value");
+	data_set_string(arg, "988328328");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_WAIT_ALL_NODES,
+						arg, errors) != 0,
+		      "wait-all-nodes");
+	data_set_string(arg, "-1");
+	ck_assert_msg(slurm_process_option_data(&opt, LONG_OPT_WAIT_ALL_NODES,
+						arg, errors) != 0,
+		      "wait-all-nodes");
+
+	slurm_option_table_destroy(spanked);
+	xfree(opt_string);
+	FREE_NULL_DATA(arg);
+	FREE_NULL_DATA(errors);
+	slurm_free_options_members(&opt);
+}
+END_TEST
+
+Suite *slurm_opt_suite(void)
+{
+	Suite *s = suite_create("slurm_opt");
+	TCase *tc_core = tcase_create("Core");
+	tcase_add_test(tc_core, test_data_job);
+	tcase_add_test(tc_core, test_data_job_macros);
+	suite_add_tcase(s, tc_core);
+	return s;
+}
+
+int main(void)
+{
+	/* Set up Slurm logging */
+	log_options_t log_opts = LOG_OPTS_INITIALIZER;
+	log_opts.stderr_level = LOG_LEVEL_DEBUG5;
+	log_init("slurm_opt-test", log_opts, 0, NULL);
+
+	/* Call slurm_conf_init() with a mock slurm.conf*/
+	int fd;
+	char *slurm_unit_conf_filename = xstrdup("slurm_unit.conf-XXXXXX");
+	if ((fd = mkstemp(slurm_unit_conf_filename)) == -1) {
+		error("error creating slurm_unit.conf (%s)",
+		      slurm_unit_conf_filename);
+		return EXIT_FAILURE;
+	} else
+		debug("fake slurm.conf created: %s", slurm_unit_conf_filename);
+
+	char slurm_unit_conf_content[] = "ClusterName=slurm_unit\n"
+					 "PluginDir=.\n"
+					 "SlurmctldHost=slurm_unit\n";
+	size_t csize = sizeof(slurm_unit_conf_content);
+	ssize_t rc = write(fd, slurm_unit_conf_content, csize);
+	if (rc < csize) {
+		error("error writting slurm_unit.conf (%s)",
+		      slurm_unit_conf_filename);
+		return EXIT_FAILURE;
+	}
+	if (slurm_conf_init(slurm_unit_conf_filename)) {
+		error("slurm_conf_init() failed");
+		return EXIT_FAILURE;
+	}
+
+	unlink(slurm_unit_conf_filename);
+	xfree(slurm_unit_conf_filename);
+	close(fd);
+
+	/* data_init_static() is necessary on this test */
+	if(data_init_static()) {
+		error("data_init_static() failed");
+		return EXIT_FAILURE;
+	}
+
+	/* Start the actual libcheck code */
+	int number_failed;
+	SRunner *sr = srunner_create(slurm_opt_suite());
+
+	srunner_run_all(sr, CK_ENV);
+	number_failed = srunner_ntests_failed(sr);
+	srunner_free(sr);
+
+	/* Cleanup */
+	data_destroy_static();
+
+	return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
diff --git a/testsuite/slurm_unit/common/xhash-test.c b/testsuite/slurm_unit/common/xhash-test.c
index 22c9fdccb4..9c4f1f057d 100644
--- a/testsuite/slurm_unit/common/xhash-test.c
+++ b/testsuite/slurm_unit/common/xhash-test.c
@@ -95,11 +95,11 @@ START_TEST(test_init_free)
 
 	/* invalid case */
 	ht = xhash_init(NULL, NULL);
-	fail_unless(ht == NULL, "allocated table without identifying function");
+	ck_assert_msg(ht == NULL, "allocated table without identifying function");
 
 	/* alloc and free */
 	ht = xhash_init(hashable_identify, NULL);
-	fail_unless(ht != NULL, "hash table was not allocated");
+	ck_assert_msg(ht != NULL, "hash table was not allocated");
 	xhash_free(ht);
 }
 END_TEST
@@ -111,15 +111,15 @@ START_TEST(test_add)
 	int i, len = sizeof(a)/sizeof(a[0]);
 	char buffer[255];
 	ht = xhash_init(hashable_identify, NULL);
-	fail_unless(xhash_add(NULL, a) == NULL, "invalid cases not null");
-	fail_unless(xhash_add(ht, NULL) == NULL, "invalid cases not null");
-	fail_unless(xhash_add(ht, a)   != NULL, "xhash_add failed");
-	fail_unless(xhash_add(ht, a+1) != NULL, "xhash_add failed");
-	fail_unless(xhash_add(ht, a+2) != NULL, "xhash_add failed");
-	fail_unless(xhash_add(ht, a+3) != NULL, "xhash_add failed");
+	ck_assert_msg(xhash_add(NULL, a) == NULL, "invalid cases not null");
+	ck_assert_msg(xhash_add(ht, NULL) == NULL, "invalid cases not null");
+	ck_assert_msg(xhash_add(ht, a)   != NULL, "xhash_add failed");
+	ck_assert_msg(xhash_add(ht, a+1) != NULL, "xhash_add failed");
+	ck_assert_msg(xhash_add(ht, a+2) != NULL, "xhash_add failed");
+	ck_assert_msg(xhash_add(ht, a+3) != NULL, "xhash_add failed");
 	for (i = 0; i < len; ++i) {
 		snprintf(buffer, sizeof(buffer), "%d", i);
-		fail_unless(xhash_get_str(ht, buffer) == (a + i),
+		ck_assert_msg(xhash_get_str(ht, buffer) == (a + i),
 				"bad hashable item returned");
 	}
 	xhash_free(ht);
@@ -133,14 +133,14 @@ START_TEST(test_find)
 	int i;
 
 	/* test bad match */
-	fail_unless(xhash_get_str(ht, "bad") == NULL  , "invalid case not null");
-	fail_unless(xhash_get_str(ht, "-1") == NULL   , "invalid case not null");
-	fail_unless(xhash_get_str(ht, "10000") == NULL, "invalid case not null");
+	ck_assert_msg(xhash_get_str(ht, "bad") == NULL  , "invalid case not null");
+	ck_assert_msg(xhash_get_str(ht, "-1") == NULL   , "invalid case not null");
+	ck_assert_msg(xhash_get_str(ht, "10000") == NULL, "invalid case not null");
 
 	/* test all good indexes */
 	for (i = 0; i < g_hashableslen; ++i) {
 		snprintf(buffer, sizeof(buffer), "%d", i);
-		fail_unless(xhash_get_str(ht, buffer) == (g_hashables + i),
+		ck_assert_msg(xhash_get_str(ht, buffer) == (g_hashables + i),
 				"bad hashable item returned");
 	}
 }
@@ -170,32 +170,32 @@ START_TEST(test_delete)
 
 	/* invalid cases */
 	xhash_delete_str(NULL, "1");
-	fail_unless(xhash_get_str(ht, "1") != NULL, "invalid case null");
+	ck_assert_msg(xhash_get_str(ht, "1") != NULL, "invalid case null");
 	/* Deleting non-existent item should do nothing. */
 	xhash_delete(ht, NULL, 0);
-	fail_unless(xhash_count(ht) == g_hashableslen,
+	ck_assert_msg(xhash_count(ht) == g_hashableslen,
 			"invalid delete has been done");
 	result = test_delete_helper();
-	fail_unless(result == 0,
+	ck_assert_msg(result == 0,
 			"no item should have been deleted, but %d were deleted",
 			result);
 
 	/* test correct deletion */
 	xhash_delete_str(ht, "10");
-	fail_unless(xhash_get_str(ht, "10") == NULL, "item not deleted");
-	fail_unless(xhash_count(ht) == (g_hashableslen-1), "bad count");
+	ck_assert_msg(xhash_get_str(ht, "10") == NULL, "item not deleted");
+	ck_assert_msg(xhash_count(ht) == (g_hashableslen-1), "bad count");
 	/* left edge */
 	xhash_delete_str(ht, "0");
-	fail_unless(xhash_get_str(ht, "0") == NULL, "item not deleted");
-	fail_unless(xhash_count(ht) == (g_hashableslen-2), "bad count");
+	ck_assert_msg(xhash_get_str(ht, "0") == NULL, "item not deleted");
+	ck_assert_msg(xhash_count(ht) == (g_hashableslen-2), "bad count");
 	/* right edge */
 	snprintf(buffer, sizeof(buffer), "%u", (g_hashableslen-2));
 	xhash_delete_str(ht, buffer);
-	fail_unless(xhash_get_str(ht, "0") == NULL, "item not deleted");
-	fail_unless(xhash_count(ht) == (g_hashableslen-3), "bad count");
+	ck_assert_msg(xhash_get_str(ht, "0") == NULL, "item not deleted");
+	ck_assert_msg(xhash_count(ht) == (g_hashableslen-3), "bad count");
 
 	result = test_delete_helper();
-	fail_unless(result == 3, "bad number of items were deleted: %d",
+	ck_assert_msg(result == 3, "bad number of items were deleted: %d",
 			result);
 }
 END_TEST
@@ -204,14 +204,14 @@ START_TEST(test_count)
 {
 	xhash_t* ht = g_ht;
 	hashable_t a[4] = {{"0", 0}, {"1", 1}, {"2", 2}, {"3", 3}};
-	fail_unless(xhash_count(ht) == g_hashableslen,
+	ck_assert_msg(xhash_count(ht) == g_hashableslen,
 		"invalid count (fixture table)");
 	ht = xhash_init(hashable_identify, NULL);
 	xhash_add(ht, a);
 	xhash_add(ht, a+1);
 	xhash_add(ht, a+2);
 	xhash_add(ht, a+3);
-	fail_unless(xhash_count(ht) == 4, "invalid count (fresh table)");
+	ck_assert_msg(xhash_count(ht) == 4, "invalid count (fresh table)");
 	xhash_free(ht);
 }
 END_TEST
@@ -228,7 +228,7 @@ START_TEST(test_walk)
 	int i;
 	xhash_walk(ht, test_walk_helper_callback, NULL);
 	for (i = 0; i < g_hashableslen; ++i) {
-		fail_unless(g_hashables[i].idn == UINT32_MAX,
+		ck_assert_msg(g_hashables[i].idn == UINT32_MAX,
 				"hashable item was not walked over");
 	}
 }
diff --git a/testsuite/slurm_unit/common/xstring-test.c b/testsuite/slurm_unit/common/xstring-test.c
new file mode 100644
index 0000000000..805b33d99c
--- /dev/null
+++ b/testsuite/slurm_unit/common/xstring-test.c
@@ -0,0 +1,125 @@
+/*****************************************************************************\
+ *  Copyright (C) 2019 SchedMD LLC
+ *  Written by Nathan Rini <nate@schedmd.com>
+ *
+ *  This file is part of Slurm, a resource management program.
+ *  For details, see <https://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  Slurm is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  Slurm is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with Slurm; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+ \*****************************************************************************/
+
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+#include <check.h>
+
+#include <src/common/xmalloc.h>
+#include <src/common/xstring.h>
+
+typedef struct {
+	const char *input;
+	const char *expected;
+} xstrtrim_data_t;
+
+static xstrtrim_data_t xstrtrim_data[] = {
+	{"",""},
+	{" a ", "a"},
+	{"", ""},
+	{" a ", "a"},
+	{"   ", ""},
+	{"	   ", ""},
+	/* test with spaces */
+	{" aaaaaaaa ", "aaaaaaaa"},
+	{"  aaaaaaaa ", "aaaaaaaa"},
+	{"  aaaaaaaa  ", "aaaaaaaa"},
+	{" aaaaaaaa  ", "aaaaaaaa"},
+	{"           aaaaaaaa ", "aaaaaaaa"},
+	{"           aaaaaaaa           ", "aaaaaaaa"},
+	{"aaaaaaaa           ", "aaaaaaaa"},
+	{"aaaaaaaa", "aaaaaaaa"},
+	{"aa   aa  aa   aa", "aa   aa  aa   aa"},
+	{"      aa   aa  aa   aa", "aa   aa  aa   aa"},
+	{"      aa   aa  aa   aa       ", "aa   aa  aa   aa"},
+	{"aa   aa  aa   aa       ", "aa   aa  aa   aa"},
+	/* test with spaces and tabs */
+	{"	", ""},
+	{"  	", ""},
+	{"  	  ", ""},
+	{"  	  	", ""},
+	{"	aaaaaaaa	", "aaaaaaaa"},
+	{"           	aaaaaaaa	", "aaaaaaaa"},
+	{"           	aaaaaaaa           	", "aaaaaaaa"},
+	{"aaaaaaaa	           ", "aaaaaaaa"},
+	{"aaaaaaaa", "aaaaaaaa"},
+	{"aa   	aa  aa   	aa", "aa   	aa  aa   	aa"},
+	{"      	aa   aa  	 aa   	aa", "aa   aa  	 aa   	aa"},
+	{"	      aa   aa  aa   aa       	", "aa   aa  aa   aa"},
+	{"aa   aa  aa   aa       	", "aa   aa  aa   aa"},
+	{"aa   aa  aa   aa       	", "aa   aa  aa   aa"}
+};
+
+/* check xstrtrim against given expected xstrtrim result */
+START_TEST(test_xstrtrim)
+{
+	const char *input = xstrtrim_data[_i].input;
+	const char *expected = xstrtrim_data[_i].expected;
+	char *buf = xstrdup(input);
+
+	xstrtrim(buf);
+	ck_assert_msg(strcmp(buf, expected) == 0, "check xstrtrim: \"%s\" -> \"%s\" == \"%s\"",
+		      input, buf, expected);
+
+	xfree(buf);
+}
+END_TEST
+
+Suite *xstring_suite(void)
+{
+	Suite *s = suite_create("xstring");
+	TCase *tc_core = tcase_create("Core");
+	tcase_add_loop_test(tc_core, test_xstrtrim, 0 , sizeof(xstrtrim_data) /
+			    sizeof(xstrtrim_data_t) );
+	suite_add_tcase(s, tc_core);
+	return s;
+}
+
+int main(int argc, char *argv[])
+{
+	log_options_t log_opts = LOG_OPTS_INITIALIZER;
+	log_opts.stderr_level = LOG_LEVEL_DEBUG5;
+	log_init("xstring-test", log_opts, 0, NULL);
+
+	int number_failed;
+	SRunner *sr = srunner_create(xstring_suite());
+
+	srunner_run_all(sr, CK_ENV);
+	number_failed = srunner_ntests_failed(sr);
+	srunner_free(sr);
+
+	return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
diff --git a/testsuite/slurm_unit/common/xtree-test.c b/testsuite/slurm_unit/common/xtree-test.c
index c7e9c15244..d94e1ab534 100644
--- a/testsuite/slurm_unit/common/xtree-test.c
+++ b/testsuite/slurm_unit/common/xtree-test.c
@@ -96,15 +96,15 @@ START_TEST(test_xtree_creation_unmanaged)
 {
     xtree_t* tree = &mytree_empty;
 
-    fail_unless(tree->root == NULL,
+    ck_assert_msg(tree->root == NULL,
             "tree has a root on creation");
-    fail_unless(tree->count == 0,
+    ck_assert_msg(tree->count == 0,
             "tree has nodes on creation");
-    fail_unless(tree->depth == 0,
+    ck_assert_msg(tree->depth == 0,
             "tree has a depth on creation");
-    fail_unless(xtree_depth_const(tree) == 0,
+    ck_assert_msg(xtree_depth_const(tree) == 0,
             "tree depth is not 0 on creation");
-    fail_unless(tree->state == XTREE_STATE_DEPTHCACHED,
+    ck_assert_msg(tree->state == XTREE_STATE_DEPTHCACHED,
             "tree is not cached on creation");
 }
 END_TEST
@@ -114,87 +114,87 @@ START_TEST(test_xtree_add_root_node_unmanaged)
     xtree_t* tree = &mytree_empty;
     char* fake_addr = (char*)1;
 
-    fail_unless(xtree_add_child(tree, NULL, fake_addr, XTREE_APPEND) != NULL,
+    ck_assert_msg(xtree_add_child(tree, NULL, fake_addr, XTREE_APPEND) != NULL,
             "unable to add root node");
-    fail_unless(tree->root != NULL,
+    ck_assert_msg(tree->root != NULL,
             "root node has not been allocated");
-    fail_unless(tree->free == NULL,
+    ck_assert_msg(tree->free == NULL,
             "bad free function in the tree");
-    fail_unless(tree->count == 1,
+    ck_assert_msg(tree->count == 1,
             "there should be at least one node and only one in node count");
-    fail_unless(xtree_depth_const(tree) == 1,
+    ck_assert_msg(xtree_depth_const(tree) == 1,
             "tree should have a depth of one (depth %d)",
             xtree_depth_const(tree));
-    fail_unless(tree->root->data == (void*)1,
+    ck_assert_msg(tree->root->data == (void*)1,
             "node data is incorrect");
-    fail_unless(tree->root->parent == NULL,
+    ck_assert_msg(tree->root->parent == NULL,
             "root node has a parent");
-    fail_unless(tree->root->start == NULL && tree->root->end == NULL,
+    ck_assert_msg(tree->root->start == NULL && tree->root->end == NULL,
             "root node should not already have child in it");
-    fail_unless(tree->root->next == NULL && tree->root->previous == NULL,
+    ck_assert_msg(tree->root->next == NULL && tree->root->previous == NULL,
             "root node have invalid siblings");
 
     xtree_refresh_depth(tree);
-    fail_unless(tree->depth == 1,
+    ck_assert_msg(tree->depth == 1,
             "root node refreshed should have one depth (root level)");
-    fail_unless(tree->state == XTREE_STATE_DEPTHCACHED,
+    ck_assert_msg(tree->state == XTREE_STATE_DEPTHCACHED,
             "root node should now have its depth been cached");
 
     ++fake_addr;
-    fail_unless(xtree_add_child(tree, NULL, fake_addr, XTREE_APPEND) == NULL,
+    ck_assert_msg(xtree_add_child(tree, NULL, fake_addr, XTREE_APPEND) == NULL,
             "xtree_add_child with NULL parent and root node in tree should "
             "return a NULL pointer");
-    fail_unless(tree->root->data == (void*)1,
+    ck_assert_msg(tree->root->data == (void*)1,
             "xtree_add_child generated an operation and should not in context");
-    fail_unless(tree->root->start == NULL,
+    ck_assert_msg(tree->root->start == NULL,
             "xtree_add_child had added an invalid child");
-    fail_unless(tree->root->start == tree->root->end,
+    ck_assert_msg(tree->root->start == tree->root->end,
             "xtree_add_child invalidated root node child list");
 
-    fail_unless(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
             != NULL,
             "unable to add child node to root node");
-    fail_unless(tree->count == 2,
+    ck_assert_msg(tree->count == 2,
             "bad tree node count");
-    fail_unless(xtree_depth_const(tree) == 2,
+    ck_assert_msg(xtree_depth_const(tree) == 2,
             "bad depth after root's first child");
-    fail_unless(tree->state != XTREE_STATE_DEPTHCACHED,
+    ck_assert_msg(tree->state != XTREE_STATE_DEPTHCACHED,
             "tree should not have already cached level count");
 
-    fail_unless(tree->root &&
+    ck_assert_msg(tree->root &&
             tree->root->data == (void*)1 &&
             tree->root->parent == NULL &&
             tree->root->next == NULL && tree->root->previous == NULL,
             "root node has badly been modified");
-    fail_unless(!!tree->root->start,
+    ck_assert_msg(!!tree->root->start,
             "root has no child, but should have one");
-    fail_unless(tree->root->start == tree->root->end,
+    ck_assert_msg(tree->root->start == tree->root->end,
             "root child list is inconsistent");
 
-    fail_unless(tree->root->start->data == (void*)2,
+    ck_assert_msg(tree->root->start->data == (void*)2,
             "bad child data");
-    fail_unless(tree->root->start->parent == tree->root,
+    ck_assert_msg(tree->root->start->parent == tree->root,
             "child parent does not point to root node");
-    fail_unless(!tree->root->start->start,
+    ck_assert_msg(!tree->root->start->start,
             "child should be unique for now");
-    fail_unless(tree->root->start->start == tree->root->start->end,
+    ck_assert_msg(tree->root->start->start == tree->root->start->end,
             "child children list is inconsistent");
-    fail_unless(!tree->root->start->next && !tree->root->start->previous,
+    ck_assert_msg(!tree->root->start->next && !tree->root->start->previous,
             "child should not have siblings");
 
     ++fake_addr;
-    fail_unless(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
             != NULL,
             "unable to add second child");
 
-    fail_unless(tree->root->start != tree->root->end,
+    ck_assert_msg(tree->root->start != tree->root->end,
             "root should have more children");
-    fail_unless(tree->root->start->next == tree->root->end &&
+    ck_assert_msg(tree->root->start->next == tree->root->end &&
             tree->root->end->previous == tree->root->start &&
             tree->root->end->next == NULL &&
             tree->root->start->previous == NULL,
             "root children list is inconsistent");
-    fail_unless(tree->root->end->data == (void*)3,
+    ck_assert_msg(tree->root->end->data == (void*)3,
             "root second child has bad data");
 }
 END_TEST
@@ -203,9 +203,9 @@ char test_table[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
 static void myfree(xtree_node_t* x)
 {
     int* item = (int*)x->data;
-    fail_unless(*item < 10 && *item >= 0,
+    ck_assert_msg(*item < 10 && *item >= 0,
             "bad data passed to freeing function");
-    fail_unless(test_table[*item] == 1,
+    ck_assert_msg(test_table[*item] == 1,
             "item was duplicated/corrupted");
     test_table[*item] = 0;
     xfree(item);
@@ -230,7 +230,7 @@ START_TEST(test_xtree_freeing_elements)
     xtree_set_freefunc(tree, (xtree_free_data_function_t) myfree);
 
     x = (int*)xmalloc(sizeof(int));
-    fail_unless(x != NULL,
+    ck_assert_msg(x != NULL,
             "unable to allocate memory for test");
     *x = i;
     test_table[i] = 1;
@@ -239,7 +239,7 @@ START_TEST(test_xtree_freeing_elements)
 
     for(i = 1; i < 10; ++i) {
         x = (int*)xmalloc(sizeof(int));
-        fail_unless(x != NULL,
+        ck_assert_msg(x != NULL,
                 "unable to allocate memory for test");
         *x = i;
         test_table[i] = 1;
@@ -252,7 +252,7 @@ START_TEST(test_xtree_freeing_elements)
     xtree_free(tree);
 
     for(i = 0; i < 10; ++i) {
-        fail_unless(test_table[i] == 0,
+        ck_assert_msg(test_table[i] == 0,
                 "one element has not been freed in the table (num %d)",
                 i);
     }
@@ -273,42 +273,42 @@ START_TEST(test_xtree_with_add_child)
     xtree_node_t* level1_2 = NULL;
     char* fake_addr = (char*)1;
 
-    fail_unless(xtree_add_child(tree, NULL, fake_addr, XTREE_APPEND) != NULL,
+    ck_assert_msg(xtree_add_child(tree, NULL, fake_addr, XTREE_APPEND) != NULL,
             NULL);
     ++fake_addr;
-    fail_unless(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
             != NULL, NULL);
     ++fake_addr;
-    fail_unless(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
             != NULL, NULL);
     ++fake_addr;
-    fail_unless(xtree_add_child(tree, tree->root->start, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_child(tree, tree->root->start, fake_addr, XTREE_APPEND)
             != NULL, NULL);
     ++fake_addr;
-    fail_unless(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
             != NULL, NULL);
     ++fake_addr;
-    fail_unless(xtree_add_child(tree, tree->root, fake_addr, XTREE_PREPEND)
+    ck_assert_msg(xtree_add_child(tree, tree->root, fake_addr, XTREE_PREPEND)
             != NULL, NULL);
     ++fake_addr;
-    fail_unless(xtree_add_child(tree, tree->root->start->next,
+    ck_assert_msg(xtree_add_child(tree, tree->root->start->next,
                 fake_addr, XTREE_PREPEND)
             != NULL, NULL);
 
-    fail_unless(tree->root->start->data == (void*)6 &&
+    ck_assert_msg(tree->root->start->data == (void*)6 &&
             tree->root->start->next->data == (void*)2 &&
             tree->root->start->next->next->data == (void*)3 &&
             tree->root->start->next->next->next->data == (void*)5,
             "bad tree for children level 1 browsing the tree forward");
-    fail_unless(tree->root->end->data == (void*)5 &&
+    ck_assert_msg(tree->root->end->data == (void*)5 &&
             tree->root->end->previous->data == (void*)3 &&
             tree->root->end->previous->previous->data == (void*)2 &&
             tree->root->end->previous->previous->previous->data == (void*)6,
             "bad tree for children level 1 browsing backward");
-    fail_unless(tree->root->start->previous == NULL &&
+    ck_assert_msg(tree->root->start->previous == NULL &&
             tree->root->end->next == NULL,
             "bad tree edges");
-    fail_unless(tree->root->start->start == NULL && /* 6 */
+    ck_assert_msg(tree->root->start->start == NULL && /* 6 */
             tree->root->start->next->start != NULL && /* 2 */
             tree->root->start->next->end != NULL && /* 2 */
             tree->root->start->next->start != /* 2 */
@@ -317,7 +317,7 @@ START_TEST(test_xtree_with_add_child)
             tree->root->start->next->next->next->start == NULL, /* 5 */
             "bad tree structure for children of child list level 1");
     level1_2 = tree->root->start->next;
-    fail_unless(level1_2->start->data == (void*)7 &&
+    ck_assert_msg(level1_2->start->data == (void*)7 &&
             level1_2->start->start == NULL &&
             level1_2->start->previous == NULL &&
             level1_2->start->next ==
@@ -340,46 +340,46 @@ START_TEST(test_xtree_with_add_sibling)
     xtree_t* tree = &mytree_empty;
     char* fake_addr = (char*)1;
 
-    fail_unless(xtree_add_sibling(tree, NULL, fake_addr, XTREE_APPEND) != NULL,
+    ck_assert_msg(xtree_add_sibling(tree, NULL, fake_addr, XTREE_APPEND) != NULL,
             NULL); /* 1 */
     ++fake_addr;
-    fail_unless(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_child(tree, tree->root, fake_addr, XTREE_APPEND)
             != NULL, NULL); /* 2 */
-    fail_unless(xtree_add_sibling(tree, tree->root, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_sibling(tree, tree->root, fake_addr, XTREE_APPEND)
             == NULL, "add_sibling should return null when used with root node");
     ++fake_addr;
-    fail_unless(xtree_add_sibling(tree, tree->root->start, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_sibling(tree, tree->root->start, fake_addr, XTREE_APPEND)
             != NULL, NULL); /* 3 */
     ++fake_addr;
-    fail_unless(xtree_add_sibling(tree, tree->root->end, fake_addr, XTREE_PREPEND)
+    ck_assert_msg(xtree_add_sibling(tree, tree->root->end, fake_addr, XTREE_PREPEND)
             != NULL, NULL); /* 4 */
     ++fake_addr;
-    fail_unless(xtree_add_sibling(tree, tree->root->end, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_sibling(tree, tree->root->end, fake_addr, XTREE_APPEND)
             != NULL, NULL); /* 5 */
     ++fake_addr;
-    fail_unless(xtree_add_sibling(tree, tree->root->start, fake_addr, XTREE_APPEND)
+    ck_assert_msg(xtree_add_sibling(tree, tree->root->start, fake_addr, XTREE_APPEND)
             != NULL, NULL); /* 6 */
     ++fake_addr;
-    fail_unless(xtree_add_sibling(tree, tree->root->start, fake_addr, XTREE_PREPEND)
+    ck_assert_msg(xtree_add_sibling(tree, tree->root->start, fake_addr, XTREE_PREPEND)
             != NULL, NULL); /* 7 */
 
-    fail_unless(tree->root->data == (void*)1,
+    ck_assert_msg(tree->root->data == (void*)1,
             "bad root node");
 
-    fail_unless(tree->root->start->data == (void*)7 &&
+    ck_assert_msg(tree->root->start->data == (void*)7 &&
             tree->root->start->next->data == (void*)2 &&
             tree->root->start->next->next->data == (void*)6 &&
             tree->root->start->next->next->next->data == (void*)4,
             "bad tree structure browsing forward");
-    fail_unless(tree->root->end->data == (void*)5 &&
+    ck_assert_msg(tree->root->end->data == (void*)5 &&
             tree->root->end->previous->data == (void*)3 &&
             tree->root->end->previous->previous->data == (void*)4 &&
             tree->root->end->previous->previous->previous->data == (void*)6,
             "bad tree structure browsing backward");
-    fail_unless(tree->root->start->previous == NULL &&
+    ck_assert_msg(tree->root->start->previous == NULL &&
             tree->root->end->next == NULL,
             "bad tree edges");
-    fail_unless(tree->root->start->start == NULL && /* 7 */
+    ck_assert_msg(tree->root->start->start == NULL && /* 7 */
             tree->root->start->next->start == NULL && /* 2 */
             tree->root->start->next->next->start == NULL && /* 6 */
             tree->root->end->start == NULL && /* 5 */
@@ -394,18 +394,18 @@ START_TEST(test_xtree_depth)
     xtree_t* tree = &mytree_by_addchild;
     uint32_t size;
 
-    fail_unless(~tree->state & XTREE_STATE_DEPTHCACHED,
+    ck_assert_msg(~tree->state & XTREE_STATE_DEPTHCACHED,
             "state is cached, should not be");
     size = xtree_depth(tree);
-    fail_unless(size == 3, "bad depth, returned: %lu", size);
-    fail_unless(xtree_depth(tree) == size, "error refreshing the cached depth");
-    fail_unless(xtree_depth_const(tree) == size, NULL);
-    fail_unless(xtree_depth_const_node(tree, tree->root) == size, NULL);
-    fail_unless(xtree_depth_const_node(tree, tree->root->start),
+    ck_assert_msg(size == 3, "bad depth, returned: %u", size);
+    ck_assert_msg(xtree_depth(tree) == size, "error refreshing the cached depth");
+    ck_assert_msg(xtree_depth_const(tree) == size, NULL);
+    ck_assert_msg(xtree_depth_const_node(tree, tree->root) == size, NULL);
+    ck_assert_msg(xtree_depth_const_node(tree, tree->root->start),
             "bad subtree level depth");
-    fail_unless(xtree_depth_const_node(tree, tree->root->start->next),
+    ck_assert_msg(xtree_depth_const_node(tree, tree->root->start->next),
             "bad subtree level depth");
-    fail_unless(xtree_depth_const_node(tree, tree->root->start->next->start),
+    ck_assert_msg(xtree_depth_const_node(tree, tree->root->start->next->start),
             "bad subtree level depth");
 }
 END_TEST
@@ -473,39 +473,39 @@ START_TEST(test_xtree_walk)
 
     node = xtree_add_child(tree, tree->root->start->next->end, (void*)8,
             XTREE_APPEND);
-    fail_unless(node == tree->root->start->next->end->start,
+    ck_assert_msg(node == tree->root->start->next->end->start,
             "fail to add required node for tests");
 
     /* invalid cases */
     node = xtree_walk(tree, NULL, UINT32_MAX, 0, NULL, NULL);
-    fail_unless(node == NULL, "invalid case, however returned not null");
+    ck_assert_msg(node == NULL, "invalid case, however returned not null");
     node = xtree_walk(NULL, tree->root, UINT32_MAX, 0, NULL, NULL);
-    fail_unless(node == NULL, "invalid case, however returned not null");
+    ck_assert_msg(node == NULL, "invalid case, however returned not null");
     node = xtree_walk(tree, tree->root, UINT32_MAX, 0, NULL, NULL);
-    fail_unless(node == NULL, "invalid case, however returned not null");
+    ck_assert_msg(node == NULL, "invalid case, however returned not null");
 
     /* should not execute function */
     node = xtree_walk(tree, tree->root, UINT32_MAX, 0,
             action_test, &walk_data);
-    fail_unless(node == NULL, "invalid case, however returned not null");
-    fail_unless(walk_data.executed == 0,
+    ck_assert_msg(node == NULL, "invalid case, however returned not null");
+    ck_assert_msg(walk_data.executed == 0,
             "invalid case (min > max) but got executed");
-    fail_unless(walk_data.error == 0,
+    ck_assert_msg(walk_data.error == 0,
             "invalid case, error detected but should not have been executed");
-    fail_unless(walk_data.table_pos == table,
+    ck_assert_msg(walk_data.table_pos == table,
             "invalid case table_pos advanced but should not");
 
     /* test tree walk through */
     node = xtree_walk(tree, NULL, 0, UINT32_MAX, action_test, &walk_data);
-    fail_unless(walk_data.executed == 1,
+    ck_assert_msg(walk_data.executed == 1,
             "should have executed at least one time");
-    fail_unless(walk_data.table_pos != NULL,
+    ck_assert_msg(walk_data.table_pos != NULL,
             "invalid pointer value for table_pos");
 #if 0
 /* FIXME: Test below are failing in v14.11.0 with message:
  * .... expected: 1: 1: 0: 0, got 1: 16: 0
  * None of this code is actually used, so commenting it out for now */
-    fail_unless(walk_data.table_pos ==
+    ck_assert_msg(walk_data.table_pos ==
             (table + (sizeof(table)/sizeof(table[0]))),
             /* ^^^^^^ invalid addr but normal at the end of normal execution */
             "unexpected stop (data, which, level, couple index)"
@@ -519,8 +519,8 @@ START_TEST(test_xtree_walk)
             walk_data.got.node_data,
             walk_data.got.which,
             walk_data.got.level);
-    fail_unless(node == NULL, "returned value indicates unexpected stop");
-    fail_unless(walk_data.error == 0, "error counter was incremented");
+    ck_assert_msg(node == NULL, "returned value indicates unexpected stop");
+    ck_assert_msg(walk_data.error == 0, "error counter was incremented");
 #endif
 }
 END_TEST
@@ -537,50 +537,50 @@ START_TEST(test_xtree_find)
 
     /* test not found result or bad params */
     node = xtree_find(tree, compare_test, NULL);
-    fail_unless(node == NULL,
-            "bad result (should be NULL): %x",
+    ck_assert_msg(node == NULL,
+            "bad result (should be NULL): %p",
             (node)?node->data:NULL);
     /* the test ^^^^ is necessary since this is a macro/function, the node is
      * deferred at the same time it is being tested */
 
     node = xtree_find(tree, NULL, (void*)4);
-    fail_unless(node == NULL,
-            "bad result (should be NULL): %x",
+    ck_assert_msg(node == NULL,
+            "bad result (should be NULL): %p",
             (node)?node->data:NULL);
 
     node = xtree_find(tree, compare_test, (void*)10);
-    fail_unless(node == NULL,
-            "bad result (should be NULL): %x",
+    ck_assert_msg(node == NULL,
+            "bad result (should be NULL): %p",
             (node)?node->data:NULL);
 
     /* test different node depth */
     node = xtree_find(tree, compare_test, (void*)1);
-    fail_unless(node != NULL,
+    ck_assert_msg(node != NULL,
             "result is null however it should have been found");
-    fail_unless(node == tree->root,
-            "root node should have been found, but found : %x",
+    ck_assert_msg(node == tree->root,
+            "root node should have been found, but found : %p",
             (node)?node->data:NULL);
 
     node = xtree_find(tree, compare_test, (void*)4);
-    fail_unless(node != NULL,
+    ck_assert_msg(node != NULL,
             "result is null however it should have been found");
-    fail_unless(tree->root->start->next->end == node,
-            "bad result (search 4): %x",
+    ck_assert_msg(tree->root->start->next->end == node,
+            "bad result (search 4): %p",
             (node)?node->data:NULL);
 
     node = xtree_find(tree, compare_test, (void*)5);
-    fail_unless(node != NULL,
+    ck_assert_msg(node != NULL,
             "result is null however it should have been found");
-    fail_unless(tree->root->end == node,
-            "bad result (search 5): %x",
+    ck_assert_msg(tree->root->end == node,
+            "bad result (search 5): %p",
             (node)?node->data:NULL);
 
     /* test node with parent and with childs */
     node = xtree_find(tree, compare_test, (void*)2);
-    fail_unless(node != NULL,
+    ck_assert_msg(node != NULL,
             "result is null however it should have been found");
-    fail_unless(tree->root->start->next == node,
-            "bad result (search 2): %x",
+    ck_assert_msg(tree->root->start->next == node,
+            "bad result (search 2): %p",
             (node)?node->data:NULL);
 
 }
@@ -591,63 +591,63 @@ START_TEST(test_xtree_delete)
     xtree_t* tree = &mytree_by_addchild;
 
     /* bad args */
-    fail_unless(xtree_depth(tree) == 3, NULL);
-    fail_unless(xtree_delete(NULL, tree->root) == NULL, "bad return");
-    fail_unless(xtree_get_count(tree) == 7, "bad count update");
-    fail_unless(tree->state & XTREE_STATE_DEPTHCACHED,
+    ck_assert_msg(xtree_depth(tree) == 3, NULL);
+    ck_assert_msg(xtree_delete(NULL, tree->root) == NULL, "bad return");
+    ck_assert_msg(xtree_get_count(tree) == 7, "bad count update");
+    ck_assert_msg(tree->state & XTREE_STATE_DEPTHCACHED,
             "level should still be cached");
-    fail_unless(xtree_delete(tree, NULL) == NULL, "bad return");
-    fail_unless(xtree_get_count(tree) == 7, "bad count update");
-    fail_unless(tree->state & XTREE_STATE_DEPTHCACHED,
+    ck_assert_msg(xtree_delete(tree, NULL) == NULL, "bad return");
+    ck_assert_msg(xtree_get_count(tree) == 7, "bad count update");
+    ck_assert_msg(tree->state & XTREE_STATE_DEPTHCACHED,
             "level should still be cached");
-    fail_unless(xtree_depth(tree) == 3, NULL);
+    ck_assert_msg(xtree_depth(tree) == 3, NULL);
 
     /* tree structure */
-    fail_unless(xtree_delete(tree, tree->root->start) == tree->root,
+    ck_assert_msg(xtree_delete(tree, tree->root->start) == tree->root,
             "parent of 6 should have been root node");
-    fail_unless(xtree_depth(tree) == 3, NULL);
-    fail_unless(tree->root->start->data == (void*)2 &&
+    ck_assert_msg(xtree_depth(tree) == 3, NULL);
+    ck_assert_msg(tree->root->start->data == (void*)2 &&
             tree->root->start->next->data == (void*)3 &&
             tree->root->start->next->next->data == (void*)5,
             "children should be now 2 -> 3 -> 5");
-    fail_unless(tree->root->start->previous == NULL,
+    ck_assert_msg(tree->root->start->previous == NULL,
             "bad children list edges");
-    fail_unless(xtree_get_count(tree) == 6, "bad count update");
-    fail_unless(tree->state & XTREE_STATE_DEPTHCACHED,
+    ck_assert_msg(xtree_get_count(tree) == 6, "bad count update");
+    ck_assert_msg(tree->state & XTREE_STATE_DEPTHCACHED,
             "level should still be cached");
-    fail_unless(tree->depth == 3 && xtree_depth(tree) == 3,
+    ck_assert_msg(tree->depth == 3 && xtree_depth(tree) == 3,
             "depth should not have changed");
 
     /* structure and depth changing */
-    fail_unless(xtree_delete(tree, tree->root->start->start) ==
+    ck_assert_msg(xtree_delete(tree, tree->root->start->start) ==
             tree->root->start,
             "parent of 7 should have been node 2");
-    fail_unless(xtree_depth(tree) == 3, NULL);
-    fail_unless(tree->state & XTREE_STATE_DEPTHCACHED,
+    ck_assert_msg(xtree_depth(tree) == 3, NULL);
+    ck_assert_msg(tree->state & XTREE_STATE_DEPTHCACHED,
             "level should still be cached");
-    fail_unless(tree->depth == 3, "depth should not have changed");
-    fail_unless(xtree_get_count(tree) == 5, "bad count update");
+    ck_assert_msg(tree->depth == 3, "depth should not have changed");
+    ck_assert_msg(xtree_get_count(tree) == 5, "bad count update");
 
-    fail_unless(xtree_delete(tree, tree->root->start->start) ==
+    ck_assert_msg(xtree_delete(tree, tree->root->start->start) ==
             tree->root->start,
             "parent of 4 should have been node 2");
-    fail_unless(tree->root->start->start == NULL &&
+    ck_assert_msg(tree->root->start->start == NULL &&
             tree->root->start->end == NULL,
             "bad edges for node 2");
-    fail_unless(tree->root->start->data == (void*)2 &&
+    ck_assert_msg(tree->root->start->data == (void*)2 &&
             tree->root->start->next->data == (void*)3 &&
             tree->root->start->next->next->data == (void*)5,
             "tree deconstruction");
-    fail_unless(tree->root->start->previous == NULL &&
+    ck_assert_msg(tree->root->start->previous == NULL &&
             tree->root->end->next == NULL,
             "tree edges deconstruction");
-    fail_unless(~tree->state & XTREE_STATE_DEPTHCACHED,
+    ck_assert_msg(~tree->state & XTREE_STATE_DEPTHCACHED,
             "level should not be cached");
-    fail_unless(xtree_depth(tree) == 2,
+    ck_assert_msg(xtree_depth(tree) == 2,
             "the last removal should have reduced depth");
 
     /* root node delete test */
-    fail_unless(xtree_delete(tree, tree->root) == NULL, "bad return");
+    ck_assert_msg(xtree_delete(tree, tree->root) == NULL, "bad return");
 }
 END_TEST
 
@@ -658,72 +658,72 @@ START_TEST(test_xtree_get_parents)
     uint32_t size = 0;
 
     /* stress~ */
-    fail_unless(xtree_get_parents(NULL, NULL, NULL) == NULL, "bad behavior");
-    fail_unless(xtree_get_parents(tree, NULL, NULL) == NULL, "bad behavior");
-    fail_unless(xtree_get_parents(NULL, tree->root->start, NULL) == NULL,
+    ck_assert_msg(xtree_get_parents(NULL, NULL, NULL) == NULL, "bad behavior");
+    ck_assert_msg(xtree_get_parents(tree, NULL, NULL) == NULL, "bad behavior");
+    ck_assert_msg(xtree_get_parents(NULL, tree->root->start, NULL) == NULL,
             "bad behavior");
-    fail_unless(xtree_get_parents(NULL, NULL, &size) == NULL, "bad behavior");
-    fail_unless(xtree_get_parents(tree, NULL, &size) == NULL, "bad behavior");
-    fail_unless(xtree_get_parents(tree, tree->root->start, NULL) == NULL,
+    ck_assert_msg(xtree_get_parents(NULL, NULL, &size) == NULL, "bad behavior");
+    ck_assert_msg(xtree_get_parents(tree, NULL, &size) == NULL, "bad behavior");
+    ck_assert_msg(xtree_get_parents(tree, tree->root->start, NULL) == NULL,
             "bad behavior");
-    fail_unless(xtree_get_parents(tree, tree->root, &size) == NULL,
+    ck_assert_msg(xtree_get_parents(tree, tree->root, &size) == NULL,
             "bad behavior");
 
     /* node 6 */
     parents = xtree_get_parents(tree, tree->root->start, &size);
-    fail_unless(parents != NULL, "should have a parent here");
-    fail_unless(size == 1, "should have parents' list size == 1");
-    fail_unless(parents[0] == tree->root,
+    ck_assert_msg(parents != NULL, "should have a parent here");
+    ck_assert_msg(size == 1, "should have parents' list size == 1");
+    ck_assert_msg(parents[0] == tree->root,
             "parents list of 6 should be root node");
     xfree(parents);
 
     /* node 1 */
     parents = xtree_get_parents(tree, tree->root, &size);
-    fail_unless(parents == NULL, "root node should not have a parent list");
+    ck_assert_msg(parents == NULL, "root node should not have a parent list");
 
     /* node 2 */
     parents = xtree_get_parents(tree, tree->root->start->next, &size);
-    fail_unless(parents != NULL, "should have a parent here");
-    fail_unless(size == 1, "should have parents' list size == 1");
-    fail_unless(parents[0] == tree->root,
+    ck_assert_msg(parents != NULL, "should have a parent here");
+    ck_assert_msg(size == 1, "should have parents' list size == 1");
+    ck_assert_msg(parents[0] == tree->root,
             "parents list of 2 should be root node");
     xfree(parents);
 
     /* node 3 */
     parents = xtree_get_parents(tree, tree->root->start->next->next, &size);
-    fail_unless(parents != NULL, "should have a parent here");
-    fail_unless(size == 1, "should have parents' list size == 1");
-    fail_unless(parents[0] == tree->root,
+    ck_assert_msg(parents != NULL, "should have a parent here");
+    ck_assert_msg(size == 1, "should have parents' list size == 1");
+    ck_assert_msg(parents[0] == tree->root,
             "parents list of 3 should be root node");
     xfree(parents);
 
     /* node 5 */
     parents = xtree_get_parents(tree, tree->root->end, &size);
-    fail_unless(parents != NULL, "should have a parent here");
-    fail_unless(size == 1, "should have parents' list size == 1");
-    fail_unless(parents[0] == tree->root,
+    ck_assert_msg(parents != NULL, "should have a parent here");
+    ck_assert_msg(size == 1, "should have parents' list size == 1");
+    ck_assert_msg(parents[0] == tree->root,
             "parents list of 5 should be root node");
     xfree(parents);
 
     /* node 7 */
     parents = xtree_get_parents(tree, tree->root->start->next->start, &size);
-    fail_unless(parents != NULL, "should have parents here");
-    fail_unless(size == 2, "should have parents' list size == 2");
-    fail_unless(parents[0] == tree->root->start->next,
-            "parents[0] of 7 should be node 2 (actually %x)",
+    ck_assert_msg(parents != NULL, "should have parents here");
+    ck_assert_msg(size == 2, "should have parents' list size == 2");
+    ck_assert_msg(parents[0] == tree->root->start->next,
+            "parents[0] of 7 should be node 2 (actually %p)",
             (parents[0])?parents[0]->data:NULL);
-    fail_unless(parents[1] == tree->root,
+    ck_assert_msg(parents[1] == tree->root,
             "parents[1] of 7 should be root node");
     xfree(parents);
 
     /* node 4 */
     parents = xtree_get_parents(tree, tree->root->start->next->end, &size);
-    fail_unless(parents != NULL, "should have parents here");
-    fail_unless(size == 2, "should have parents' list size == 2");
-    fail_unless(parents[0] == tree->root->start->next,
-            "parents[0] of 4 should be node 2 (actually %x)",
+    ck_assert_msg(parents != NULL, "should have parents here");
+    ck_assert_msg(size == 2, "should have parents' list size == 2");
+    ck_assert_msg(parents[0] == tree->root->start->next,
+            "parents[0] of 4 should be node 2 (actually %p)",
             (parents[0])?parents[0]->data:NULL);
-    fail_unless(parents[1] == tree->root,
+    ck_assert_msg(parents[1] == tree->root,
             "parents[1] of 7 should be root node");
     xfree(parents);
 }
@@ -737,23 +737,23 @@ START_TEST(test_xtree_common)
 
     /* invalid cases */
     node = xtree_common(NULL, NULL, 10);
-    fail_unless(node == NULL, "invalid case, however returned not null");
+    ck_assert_msg(node == NULL, "invalid case, however returned not null");
     node = xtree_common(tree, NULL, 10);
-    fail_unless(node == NULL, "invalid case, however returned not null");
+    ck_assert_msg(node == NULL, "invalid case, however returned not null");
     node_list[0] = NULL;
     node_list[1] = tree->root->end;
     node_list[2] = tree->root->start;
     node = xtree_common(tree, node_list, 3);
-    fail_unless(node == NULL, "invalid case, however returned not null");
+    ck_assert_msg(node == NULL, "invalid case, however returned not null");
     node_list[0] = tree->root;
     node = xtree_common(tree, node_list, 1);
-    fail_unless(node == NULL, "invalid case, however returned not null");
+    ck_assert_msg(node == NULL, "invalid case, however returned not null");
     node_list[0] = tree->root->start;
     node_list[1] = tree->root->end;
     node = xtree_common(NULL, node_list, 2);
-    fail_unless(node == NULL, "invalid case, however returned not null");
+    ck_assert_msg(node == NULL, "invalid case, however returned not null");
     node = xtree_common(tree, node_list, 0);
-    fail_unless(node == NULL, "invalid case, however returned not null");
+    ck_assert_msg(node == NULL, "invalid case, however returned not null");
 
     /* test for good common ancestor */
 
@@ -761,57 +761,57 @@ START_TEST(test_xtree_common)
     node_list[0] = tree->root->start->next->start;
     node_list[1] = tree->root->end;
     node = xtree_common(tree, node_list, 2);
-    fail_unless(node == tree->root, "bad returned node : %x",
+    ck_assert_msg(node == tree->root, "bad returned node : %p",
             (node)?node->data:NULL);
 
     /* 2, 7 -> 1 */
     node_list[0] = tree->root->start->next;
     node_list[1] = tree->root->start->next->start;
     node = xtree_common(tree, node_list, 2);
-    fail_unless(node == tree->root, "bad returned node");
+    ck_assert_msg(node == tree->root, "bad returned node");
 
     /* 4, 7 -> 2 */
     node_list[0] = tree->root->start->next->end;
     node = xtree_common(tree, node_list, 2);
-    fail_unless(node == tree->root->start->next, "bad returned node");
+    ck_assert_msg(node == tree->root->start->next, "bad returned node");
 
     /* 4, 7, 2 -> 1 */
     node_list[2] = tree->root->start->next;
     node = xtree_common(tree, node_list, 3);
-    fail_unless(node == tree->root, "bad returned node");
+    ck_assert_msg(node == tree->root, "bad returned node");
 
     /* 6, 7 -> 1 */
     node_list[0] = tree->root->start;
     node = xtree_common(tree, node_list, 2);
-    fail_unless(node == tree->root, "bad returned node");
+    ck_assert_msg(node == tree->root, "bad returned node");
 
     /* 2, 7 -> 1 */
     node_list[0] = tree->root->start->next;
     node = xtree_common(tree, node_list, 2);
-    fail_unless(node == tree->root, "bad returned node");
+    ck_assert_msg(node == tree->root, "bad returned node");
 
     /* 2, 1 -> NULL */
     node_list[1] = tree->root;
     node = xtree_common(tree, node_list, 2);
-    fail_unless(node == NULL, "bad returned node");
+    ck_assert_msg(node == NULL, "bad returned node");
 
     /* 2, 3, 5, 6 -> 1 */
     node_list[1] = tree->root->end->previous;
     node_list[2] = tree->root->end;
     node_list[3] = tree->root->start;
     node = xtree_common(tree, node_list, 4);
-    fail_unless(node == tree->root, "bad returned node");
+    ck_assert_msg(node == tree->root, "bad returned node");
 
     /* 2, 3, 5, 6, 7, 4 -> 1 */
     node_list[4] = tree->root->start->next->start;
     node_list[5] = tree->root->start->next->end;
     node = xtree_common(tree, node_list, 6);
-    fail_unless(node == tree->root, "bad returned node");
+    ck_assert_msg(node == tree->root, "bad returned node");
 
     /* 2, 3, 5, 6, 7, 4, 1 -> NULL */
     node_list[6] = tree->root;
     node = xtree_common(tree, node_list, 7);
-    fail_unless(node == NULL, "bad returned node");
+    ck_assert_msg(node == NULL, "bad returned node");
 }
 END_TEST
 
@@ -823,40 +823,40 @@ START_TEST(test_xtree_get_leaves)
 
     /* invalid cases */
     nodes = xtree_get_leaves(NULL, NULL, NULL);
-    fail_unless(nodes == NULL, "invalid case, however returned not null");
+    ck_assert_msg(nodes == NULL, "invalid case, however returned not null");
     nodes = xtree_get_leaves(tree, NULL, NULL);
-    fail_unless(nodes == NULL, "invalid case, however returned not null");
+    ck_assert_msg(nodes == NULL, "invalid case, however returned not null");
     nodes = xtree_get_leaves(tree, tree->root, NULL);
-    fail_unless(nodes == NULL, "invalid case, however returned not null");
+    ck_assert_msg(nodes == NULL, "invalid case, however returned not null");
     nodes = xtree_get_leaves(tree, NULL, &size);
-    fail_unless(nodes == NULL, "invalid case, however returned not null");
+    ck_assert_msg(nodes == NULL, "invalid case, however returned not null");
     nodes = xtree_get_leaves(NULL, tree->root, &size);
-    fail_unless(nodes == NULL, "invalid case, however returned not null");
+    ck_assert_msg(nodes == NULL, "invalid case, however returned not null");
     nodes = xtree_get_leaves(NULL, tree->root, NULL);
-    fail_unless(nodes == NULL, "invalid case, however returned not null");
+    ck_assert_msg(nodes == NULL, "invalid case, however returned not null");
     nodes = xtree_get_leaves(tree, NULL, &size);
-    fail_unless(nodes == NULL, "invalid case, however returned not null");
+    ck_assert_msg(nodes == NULL, "invalid case, however returned not null");
 
     /* get real leaves */
     nodes = xtree_get_leaves(tree, tree->root->start, &size);
-    fail_unless(nodes == NULL, "should have no leaves descending 6");
+    ck_assert_msg(nodes == NULL, "should have no leaves descending 6");
 
     nodes = xtree_get_leaves(tree, tree->root->start->next, &size);
-    fail_unless(size == 2, "should have 2 leaves from 2");
-    fail_unless(nodes[0] == tree->root->start->next->start,
+    ck_assert_msg(size == 2, "should have 2 leaves from 2");
+    ck_assert_msg(nodes[0] == tree->root->start->next->start,
             "nodes[0] != nodes 7");
-    fail_unless(nodes[1] == tree->root->start->next->end,
+    ck_assert_msg(nodes[1] == tree->root->start->next->end,
             "nodes[1] != nodes 4");
     xfree(nodes);
 
     nodes = xtree_get_leaves(tree, tree->root, &size);
-    fail_unless(size != 6, "should have 6 leaves from root node");
-    fail_unless(nodes[0] == tree->root->start, "bad leaves result");
-    fail_unless(nodes[1] == tree->root->start->next->start, "bad leaves result");
-    fail_unless(nodes[2] == tree->root->start->next->end,
+    ck_assert_msg(size != 6, "should have 6 leaves from root node");
+    ck_assert_msg(nodes[0] == tree->root->start, "bad leaves result");
+    ck_assert_msg(nodes[1] == tree->root->start->next->start, "bad leaves result");
+    ck_assert_msg(nodes[2] == tree->root->start->next->end,
             "bad leaves result");
-    fail_unless(nodes[3] == tree->root->start->next->next, "bad leaves result");
-    fail_unless(nodes[4] == tree->root->end,
+    ck_assert_msg(nodes[3] == tree->root->start->next->next, "bad leaves result");
+    ck_assert_msg(nodes[4] == tree->root->end,
             "bad leaves result");
     xfree(nodes);
 }
diff --git a/testsuite/slurm_unit/slurmd/Makefile.am b/testsuite/slurm_unit/slurmd/Makefile.am
new file mode 100644
index 0000000000..329a50b07a
--- /dev/null
+++ b/testsuite/slurm_unit/slurmd/Makefile.am
@@ -0,0 +1,4 @@
+AUTOMAKE_OPTIONS = foreign
+
+SUBDIRS = common
+
diff --git a/testsuite/slurm_unit/slurmd/Makefile.in b/testsuite/slurm_unit/slurmd/Makefile.in
new file mode 100644
index 0000000000..530baa8c41
--- /dev/null
+++ b/testsuite/slurm_unit/slurmd/Makefile.in
@@ -0,0 +1,803 @@
+# Makefile.in generated by automake 1.16.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = testsuite/slurm_unit/slurmd
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/auxdir/ax_check_compile_flag.m4 \
+	$(top_srcdir)/auxdir/ax_check_zlib.m4 \
+	$(top_srcdir)/auxdir/ax_gcc_builtin.m4 \
+	$(top_srcdir)/auxdir/ax_lib_hdf5.m4 \
+	$(top_srcdir)/auxdir/ax_pthread.m4 \
+	$(top_srcdir)/auxdir/libtool.m4 \
+	$(top_srcdir)/auxdir/ltoptions.m4 \
+	$(top_srcdir)/auxdir/ltsugar.m4 \
+	$(top_srcdir)/auxdir/ltversion.m4 \
+	$(top_srcdir)/auxdir/lt~obsolete.m4 \
+	$(top_srcdir)/auxdir/slurm.m4 \
+	$(top_srcdir)/auxdir/slurmrestd.m4 \
+	$(top_srcdir)/auxdir/x_ac_affinity.m4 \
+	$(top_srcdir)/auxdir/x_ac_c99.m4 \
+	$(top_srcdir)/auxdir/x_ac_cgroup.m4 \
+	$(top_srcdir)/auxdir/x_ac_cray.m4 \
+	$(top_srcdir)/auxdir/x_ac_curl.m4 \
+	$(top_srcdir)/auxdir/x_ac_databases.m4 \
+	$(top_srcdir)/auxdir/x_ac_debug.m4 \
+	$(top_srcdir)/auxdir/x_ac_deprecated.m4 \
+	$(top_srcdir)/auxdir/x_ac_dlfcn.m4 \
+	$(top_srcdir)/auxdir/x_ac_env.m4 \
+	$(top_srcdir)/auxdir/x_ac_freeipmi.m4 \
+	$(top_srcdir)/auxdir/x_ac_http_parser.m4 \
+	$(top_srcdir)/auxdir/x_ac_hwloc.m4 \
+	$(top_srcdir)/auxdir/x_ac_json.m4 \
+	$(top_srcdir)/auxdir/x_ac_jwt.m4 \
+	$(top_srcdir)/auxdir/x_ac_lua.m4 \
+	$(top_srcdir)/auxdir/x_ac_lz4.m4 \
+	$(top_srcdir)/auxdir/x_ac_man2html.m4 \
+	$(top_srcdir)/auxdir/x_ac_munge.m4 \
+	$(top_srcdir)/auxdir/x_ac_netloc.m4 \
+	$(top_srcdir)/auxdir/x_ac_nvml.m4 \
+	$(top_srcdir)/auxdir/x_ac_ofed.m4 \
+	$(top_srcdir)/auxdir/x_ac_pam.m4 \
+	$(top_srcdir)/auxdir/x_ac_pmix.m4 \
+	$(top_srcdir)/auxdir/x_ac_printf_null.m4 \
+	$(top_srcdir)/auxdir/x_ac_ptrace.m4 \
+	$(top_srcdir)/auxdir/x_ac_readline.m4 \
+	$(top_srcdir)/auxdir/x_ac_rrdtool.m4 \
+	$(top_srcdir)/auxdir/x_ac_rsmi.m4 \
+	$(top_srcdir)/auxdir/x_ac_setproctitle.m4 \
+	$(top_srcdir)/auxdir/x_ac_systemd.m4 \
+	$(top_srcdir)/auxdir/x_ac_ucx.m4 \
+	$(top_srcdir)/auxdir/x_ac_uid_gid_size.m4 \
+	$(top_srcdir)/auxdir/x_ac_x11.m4 \
+	$(top_srcdir)/auxdir/x_ac_yaml.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/slurm/slurm.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
+	ctags-recursive dvi-recursive html-recursive info-recursive \
+	install-data-recursive install-dvi-recursive \
+	install-exec-recursive install-html-recursive \
+	install-info-recursive install-pdf-recursive \
+	install-ps-recursive install-recursive installcheck-recursive \
+	installdirs-recursive pdf-recursive ps-recursive \
+	tags-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+am__recursive_targets = \
+  $(RECURSIVE_TARGETS) \
+  $(RECURSIVE_CLEAN_TARGETS) \
+  $(am__extra_recursive_targets)
+AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
+	distdir distdir-am
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+am__DIST_COMMON = $(srcdir)/Makefile.in
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AR_FLAGS = @AR_FLAGS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CHECK_CFLAGS = @CHECK_CFLAGS@
+CHECK_LIBS = @CHECK_LIBS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CRAY_JOB_CPPFLAGS = @CRAY_JOB_CPPFLAGS@
+CRAY_JOB_LDFLAGS = @CRAY_JOB_LDFLAGS@
+CRAY_SELECT_CPPFLAGS = @CRAY_SELECT_CPPFLAGS@
+CRAY_SELECT_LDFLAGS = @CRAY_SELECT_LDFLAGS@
+CRAY_SWITCH_CPPFLAGS = @CRAY_SWITCH_CPPFLAGS@
+CRAY_SWITCH_LDFLAGS = @CRAY_SWITCH_LDFLAGS@
+CRAY_TASK_CPPFLAGS = @CRAY_TASK_CPPFLAGS@
+CRAY_TASK_LDFLAGS = @CRAY_TASK_LDFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DATAWARP_CPPFLAGS = @DATAWARP_CPPFLAGS@
+DATAWARP_LDFLAGS = @DATAWARP_LDFLAGS@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DL_LIBS = @DL_LIBS@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+FREEIPMI_CPPFLAGS = @FREEIPMI_CPPFLAGS@
+FREEIPMI_LDFLAGS = @FREEIPMI_LDFLAGS@
+FREEIPMI_LIBS = @FREEIPMI_LIBS@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_COMPILE_RESOURCES = @GLIB_COMPILE_RESOURCES@
+GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
+GLIB_LIBS = @GLIB_LIBS@
+GLIB_MKENUMS = @GLIB_MKENUMS@
+GOBJECT_QUERY = @GOBJECT_QUERY@
+GREP = @GREP@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_LIBS = @GTK_LIBS@
+H5CC = @H5CC@
+H5FC = @H5FC@
+HAVEMYSQLCONFIG = @HAVEMYSQLCONFIG@
+HAVE_MAN2HTML = @HAVE_MAN2HTML@
+HDF5_CC = @HDF5_CC@
+HDF5_CFLAGS = @HDF5_CFLAGS@
+HDF5_CPPFLAGS = @HDF5_CPPFLAGS@
+HDF5_FC = @HDF5_FC@
+HDF5_FFLAGS = @HDF5_FFLAGS@
+HDF5_FLIBS = @HDF5_FLIBS@
+HDF5_LDFLAGS = @HDF5_LDFLAGS@
+HDF5_LIBS = @HDF5_LIBS@
+HDF5_TYPE = @HDF5_TYPE@
+HDF5_VERSION = @HDF5_VERSION@
+HTTP_PARSER_CPPFLAGS = @HTTP_PARSER_CPPFLAGS@
+HTTP_PARSER_LDFLAGS = @HTTP_PARSER_LDFLAGS@
+HWLOC_CPPFLAGS = @HWLOC_CPPFLAGS@
+HWLOC_LDFLAGS = @HWLOC_LDFLAGS@
+HWLOC_LIBS = @HWLOC_LIBS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+JSON_CPPFLAGS = @JSON_CPPFLAGS@
+JSON_LDFLAGS = @JSON_LDFLAGS@
+JWT_CPPFLAGS = @JWT_CPPFLAGS@
+JWT_LDFLAGS = @JWT_LDFLAGS@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBCURL = @LIBCURL@
+LIBCURL_CPPFLAGS = @LIBCURL_CPPFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIB_SLURM = @LIB_SLURM@
+LIB_SLURM_BUILD = @LIB_SLURM_BUILD@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
+LZ4_CPPFLAGS = @LZ4_CPPFLAGS@
+LZ4_LDFLAGS = @LZ4_LDFLAGS@
+LZ4_LIBS = @LZ4_LIBS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MKDIR_P = @MKDIR_P@
+MUNGE_CPPFLAGS = @MUNGE_CPPFLAGS@
+MUNGE_DIR = @MUNGE_DIR@
+MUNGE_LDFLAGS = @MUNGE_LDFLAGS@
+MUNGE_LIBS = @MUNGE_LIBS@
+MYSQL_CFLAGS = @MYSQL_CFLAGS@
+MYSQL_LIBS = @MYSQL_LIBS@
+NETLOC_CPPFLAGS = @NETLOC_CPPFLAGS@
+NETLOC_LDFLAGS = @NETLOC_LDFLAGS@
+NETLOC_LIBS = @NETLOC_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+NUMA_LIBS = @NUMA_LIBS@
+NVML_CPPFLAGS = @NVML_CPPFLAGS@
+NVML_LIBS = @NVML_LIBS@
+OBJCOPY = @OBJCOPY@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OFED_CPPFLAGS = @OFED_CPPFLAGS@
+OFED_LDFLAGS = @OFED_LDFLAGS@
+OFED_LIBS = @OFED_LIBS@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PAM_DIR = @PAM_DIR@
+PAM_LIBS = @PAM_LIBS@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+PMIX_V1_CPPFLAGS = @PMIX_V1_CPPFLAGS@
+PMIX_V1_LDFLAGS = @PMIX_V1_LDFLAGS@
+PMIX_V2_CPPFLAGS = @PMIX_V2_CPPFLAGS@
+PMIX_V2_LDFLAGS = @PMIX_V2_LDFLAGS@
+PMIX_V3_CPPFLAGS = @PMIX_V3_CPPFLAGS@
+PMIX_V3_LDFLAGS = @PMIX_V3_LDFLAGS@
+PMIX_V4_CPPFLAGS = @PMIX_V4_CPPFLAGS@
+PMIX_V4_LDFLAGS = @PMIX_V4_LDFLAGS@
+PROJECT = @PROJECT@
+PTHREAD_CC = @PTHREAD_CC@
+PTHREAD_CFLAGS = @PTHREAD_CFLAGS@
+PTHREAD_LIBS = @PTHREAD_LIBS@
+RANLIB = @RANLIB@
+READLINE_LIBS = @READLINE_LIBS@
+RELEASE = @RELEASE@
+RRDTOOL_CPPFLAGS = @RRDTOOL_CPPFLAGS@
+RRDTOOL_LDFLAGS = @RRDTOOL_LDFLAGS@
+RRDTOOL_LIBS = @RRDTOOL_LIBS@
+RSMI_CPPFLAGS = @RSMI_CPPFLAGS@
+RSMI_LDFLAGS = @RSMI_LDFLAGS@
+RSMI_LIBS = @RSMI_LIBS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SLEEP_CMD = @SLEEP_CMD@
+SLURMCTLD_PORT = @SLURMCTLD_PORT@
+SLURMCTLD_PORT_COUNT = @SLURMCTLD_PORT_COUNT@
+SLURMDBD_PORT = @SLURMDBD_PORT@
+SLURMD_PORT = @SLURMD_PORT@
+SLURMRESTD_PORT = @SLURMRESTD_PORT@
+SLURM_API_AGE = @SLURM_API_AGE@
+SLURM_API_CURRENT = @SLURM_API_CURRENT@
+SLURM_API_MAJOR = @SLURM_API_MAJOR@
+SLURM_API_REVISION = @SLURM_API_REVISION@
+SLURM_API_VERSION = @SLURM_API_VERSION@
+SLURM_MAJOR = @SLURM_MAJOR@
+SLURM_MICRO = @SLURM_MICRO@
+SLURM_MINOR = @SLURM_MINOR@
+SLURM_PREFIX = @SLURM_PREFIX@
+SLURM_VERSION_NUMBER = @SLURM_VERSION_NUMBER@
+SLURM_VERSION_STRING = @SLURM_VERSION_STRING@
+STRIP = @STRIP@
+SUCMD = @SUCMD@
+SYSTEMD_TASKSMAX_OPTION = @SYSTEMD_TASKSMAX_OPTION@
+UCX_CPPFLAGS = @UCX_CPPFLAGS@
+UCX_LDFLAGS = @UCX_LDFLAGS@
+UCX_LIBS = @UCX_LIBS@
+UTIL_LIBS = @UTIL_LIBS@
+VERSION = @VERSION@
+YAML_CPPFLAGS = @YAML_CPPFLAGS@
+YAML_LDFLAGS = @YAML_LDFLAGS@
+ZLIB_CPPFLAGS = @ZLIB_CPPFLAGS@
+ZLIB_LDFLAGS = @ZLIB_LDFLAGS@
+ZLIB_LIBS = @ZLIB_LIBS@
+_libcurl_config = @_libcurl_config@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+ac_have_man2html = @ac_have_man2html@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+ax_pthread_config = @ax_pthread_config@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lua_CFLAGS = @lua_CFLAGS@
+lua_LIBS = @lua_LIBS@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+runstatedir = @runstatedir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AUTOMAKE_OPTIONS = foreign
+SUBDIRS = common
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign testsuite/slurm_unit/slurmd/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign testsuite/slurm_unit/slurmd/Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(am__recursive_targets):
+	@fail=; \
+	if $(am__make_keepgoing); then \
+	  failcom='fail=yes'; \
+	else \
+	  failcom='exit 1'; \
+	fi; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-recursive
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-recursive
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-recursive
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(am__recursive_targets) install-am install-strip
+
+.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
+	check-am clean clean-generic clean-libtool cscopelist-am ctags \
+	ctags-am distclean distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	installdirs-am maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
+	ps ps-am tags tags-am uninstall uninstall-am
+
+.PRECIOUS: Makefile
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/testsuite/slurm_unit/slurmd/common/Makefile.am b/testsuite/slurm_unit/slurmd/common/Makefile.am
new file mode 100644
index 0000000000..1fd041caf5
--- /dev/null
+++ b/testsuite/slurm_unit/slurmd/common/Makefile.am
@@ -0,0 +1,20 @@
+AUTOMAKE_OPTIONS = foreign
+
+AM_CPPFLAGS = -I$(top_srcdir) -ldl -lpthread
+LDADD = $(top_builddir)/src/api/libslurm.o \
+	$(top_builddir)/src/slurmd/common/libslurmd_common.o \
+	$(HWLOC_LDFLAGS) $(HWLOC_LIBS) \
+	$(DL_LIBS)
+
+check_PROGRAMS = $(TESTS)
+
+
+
+if HAVE_CHECK
+MYCFLAGS  = @CHECK_CFLAGS@ -Wall -std=c99
+
+TESTS = reverse_tree_math-test
+
+reverse_tree_math_test_CFLAGS = $(MYCFLAGS)
+reverse_tree_math_test_LDADD  = $(LDADD) @CHECK_LIBS@
+endif
diff --git a/testsuite/slurm_unit/slurmd/common/Makefile.in b/testsuite/slurm_unit/slurmd/common/Makefile.in
new file mode 100644
index 0000000000..d5d31bb788
--- /dev/null
+++ b/testsuite/slurm_unit/slurmd/common/Makefile.in
@@ -0,0 +1,1183 @@
+# Makefile.in generated by automake 1.16.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+check_PROGRAMS = $(am__EXEEXT_1)
+@HAVE_CHECK_TRUE@TESTS = reverse_tree_math-test$(EXEEXT)
+subdir = testsuite/slurm_unit/slurmd/common
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/auxdir/ax_check_compile_flag.m4 \
+	$(top_srcdir)/auxdir/ax_check_zlib.m4 \
+	$(top_srcdir)/auxdir/ax_gcc_builtin.m4 \
+	$(top_srcdir)/auxdir/ax_lib_hdf5.m4 \
+	$(top_srcdir)/auxdir/ax_pthread.m4 \
+	$(top_srcdir)/auxdir/libtool.m4 \
+	$(top_srcdir)/auxdir/ltoptions.m4 \
+	$(top_srcdir)/auxdir/ltsugar.m4 \
+	$(top_srcdir)/auxdir/ltversion.m4 \
+	$(top_srcdir)/auxdir/lt~obsolete.m4 \
+	$(top_srcdir)/auxdir/slurm.m4 \
+	$(top_srcdir)/auxdir/slurmrestd.m4 \
+	$(top_srcdir)/auxdir/x_ac_affinity.m4 \
+	$(top_srcdir)/auxdir/x_ac_c99.m4 \
+	$(top_srcdir)/auxdir/x_ac_cgroup.m4 \
+	$(top_srcdir)/auxdir/x_ac_cray.m4 \
+	$(top_srcdir)/auxdir/x_ac_curl.m4 \
+	$(top_srcdir)/auxdir/x_ac_databases.m4 \
+	$(top_srcdir)/auxdir/x_ac_debug.m4 \
+	$(top_srcdir)/auxdir/x_ac_deprecated.m4 \
+	$(top_srcdir)/auxdir/x_ac_dlfcn.m4 \
+	$(top_srcdir)/auxdir/x_ac_env.m4 \
+	$(top_srcdir)/auxdir/x_ac_freeipmi.m4 \
+	$(top_srcdir)/auxdir/x_ac_http_parser.m4 \
+	$(top_srcdir)/auxdir/x_ac_hwloc.m4 \
+	$(top_srcdir)/auxdir/x_ac_json.m4 \
+	$(top_srcdir)/auxdir/x_ac_jwt.m4 \
+	$(top_srcdir)/auxdir/x_ac_lua.m4 \
+	$(top_srcdir)/auxdir/x_ac_lz4.m4 \
+	$(top_srcdir)/auxdir/x_ac_man2html.m4 \
+	$(top_srcdir)/auxdir/x_ac_munge.m4 \
+	$(top_srcdir)/auxdir/x_ac_netloc.m4 \
+	$(top_srcdir)/auxdir/x_ac_nvml.m4 \
+	$(top_srcdir)/auxdir/x_ac_ofed.m4 \
+	$(top_srcdir)/auxdir/x_ac_pam.m4 \
+	$(top_srcdir)/auxdir/x_ac_pmix.m4 \
+	$(top_srcdir)/auxdir/x_ac_printf_null.m4 \
+	$(top_srcdir)/auxdir/x_ac_ptrace.m4 \
+	$(top_srcdir)/auxdir/x_ac_readline.m4 \
+	$(top_srcdir)/auxdir/x_ac_rrdtool.m4 \
+	$(top_srcdir)/auxdir/x_ac_rsmi.m4 \
+	$(top_srcdir)/auxdir/x_ac_setproctitle.m4 \
+	$(top_srcdir)/auxdir/x_ac_systemd.m4 \
+	$(top_srcdir)/auxdir/x_ac_ucx.m4 \
+	$(top_srcdir)/auxdir/x_ac_uid_gid_size.m4 \
+	$(top_srcdir)/auxdir/x_ac_x11.m4 \
+	$(top_srcdir)/auxdir/x_ac_yaml.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/slurm/slurm.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+@HAVE_CHECK_TRUE@am__EXEEXT_1 = reverse_tree_math-test$(EXEEXT)
+reverse_tree_math_test_SOURCES = reverse_tree_math-test.c
+reverse_tree_math_test_OBJECTS =  \
+	reverse_tree_math_test-reverse_tree_math-test.$(OBJEXT)
+am__DEPENDENCIES_1 =
+am__DEPENDENCIES_2 = $(top_builddir)/src/api/libslurm.o \
+	$(top_builddir)/src/slurmd/common/libslurmd_common.o \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1)
+@HAVE_CHECK_TRUE@reverse_tree_math_test_DEPENDENCIES =  \
+@HAVE_CHECK_TRUE@	$(am__DEPENDENCIES_2)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+reverse_tree_math_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(reverse_tree_math_test_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir) -I$(top_builddir)/slurm
+depcomp = $(SHELL) $(top_srcdir)/auxdir/depcomp
+am__maybe_remake_depfiles = depfiles
+am__depfiles_remade =  \
+	./$(DEPDIR)/reverse_tree_math_test-reverse_tree_math-test.Po
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = reverse_tree_math-test.c
+DIST_SOURCES = reverse_tree_math-test.c
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+am__tty_colors_dummy = \
+  mgn= red= grn= lgn= blu= brg= std=; \
+  am__color_tests=no
+am__tty_colors = { \
+  $(am__tty_colors_dummy); \
+  if test "X$(AM_COLOR_TESTS)" = Xno; then \
+    am__color_tests=no; \
+  elif test "X$(AM_COLOR_TESTS)" = Xalways; then \
+    am__color_tests=yes; \
+  elif test "X$$TERM" != Xdumb && { test -t 1; } 2>/dev/null; then \
+    am__color_tests=yes; \
+  fi; \
+  if test $$am__color_tests = yes; then \
+    red='[0;31m'; \
+    grn='[0;32m'; \
+    lgn='[1;32m'; \
+    blu='[1;34m'; \
+    mgn='[0;35m'; \
+    brg='[1m'; \
+    std='[m'; \
+  fi; \
+}
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__recheck_rx = ^[ 	]*:recheck:[ 	]*
+am__global_test_result_rx = ^[ 	]*:global-test-result:[ 	]*
+am__copy_in_global_log_rx = ^[ 	]*:copy-in-global-log:[ 	]*
+# A command that, given a newline-separated list of test names on the
+# standard input, print the name of the tests that are to be re-run
+# upon "make recheck".
+am__list_recheck_tests = $(AWK) '{ \
+  recheck = 1; \
+  while ((rc = (getline line < ($$0 ".trs"))) != 0) \
+    { \
+      if (rc < 0) \
+        { \
+          if ((getline line2 < ($$0 ".log")) < 0) \
+	    recheck = 0; \
+          break; \
+        } \
+      else if (line ~ /$(am__recheck_rx)[nN][Oo]/) \
+        { \
+          recheck = 0; \
+          break; \
+        } \
+      else if (line ~ /$(am__recheck_rx)[yY][eE][sS]/) \
+        { \
+          break; \
+        } \
+    }; \
+  if (recheck) \
+    print $$0; \
+  close ($$0 ".trs"); \
+  close ($$0 ".log"); \
+}'
+# A command that, given a newline-separated list of test names on the
+# standard input, create the global log from their .trs and .log files.
+am__create_global_log = $(AWK) ' \
+function fatal(msg) \
+{ \
+  print "fatal: making $@: " msg | "cat >&2"; \
+  exit 1; \
+} \
+function rst_section(header) \
+{ \
+  print header; \
+  len = length(header); \
+  for (i = 1; i <= len; i = i + 1) \
+    printf "="; \
+  printf "\n\n"; \
+} \
+{ \
+  copy_in_global_log = 1; \
+  global_test_result = "RUN"; \
+  while ((rc = (getline line < ($$0 ".trs"))) != 0) \
+    { \
+      if (rc < 0) \
+         fatal("failed to read from " $$0 ".trs"); \
+      if (line ~ /$(am__global_test_result_rx)/) \
+        { \
+          sub("$(am__global_test_result_rx)", "", line); \
+          sub("[ 	]*$$", "", line); \
+          global_test_result = line; \
+        } \
+      else if (line ~ /$(am__copy_in_global_log_rx)[nN][oO]/) \
+        copy_in_global_log = 0; \
+    }; \
+  if (copy_in_global_log) \
+    { \
+      rst_section(global_test_result ": " $$0); \
+      while ((rc = (getline line < ($$0 ".log"))) != 0) \
+      { \
+        if (rc < 0) \
+          fatal("failed to read from " $$0 ".log"); \
+        print line; \
+      }; \
+      printf "\n"; \
+    }; \
+  close ($$0 ".trs"); \
+  close ($$0 ".log"); \
+}'
+# Restructured Text title.
+am__rst_title = { sed 's/.*/   &   /;h;s/./=/g;p;x;s/ *$$//;p;g' && echo; }
+# Solaris 10 'make', and several other traditional 'make' implementations,
+# pass "-e" to $(SHELL), and POSIX 2008 even requires this.  Work around it
+# by disabling -e (using the XSI extension "set +e") if it's set.
+am__sh_e_setup = case $$- in *e*) set +e;; esac
+# Default flags passed to test drivers.
+am__common_driver_flags = \
+  --color-tests "$$am__color_tests" \
+  --enable-hard-errors "$$am__enable_hard_errors" \
+  --expect-failure "$$am__expect_failure"
+# To be inserted before the command running the test.  Creates the
+# directory for the log if needed.  Stores in $dir the directory
+# containing $f, in $tst the test, in $log the log.  Executes the
+# developer- defined test setup AM_TESTS_ENVIRONMENT (if any), and
+# passes TESTS_ENVIRONMENT.  Set up options for the wrapper that
+# will run the test scripts (or their associated LOG_COMPILER, if
+# thy have one).
+am__check_pre = \
+$(am__sh_e_setup);					\
+$(am__vpath_adj_setup) $(am__vpath_adj)			\
+$(am__tty_colors);					\
+srcdir=$(srcdir); export srcdir;			\
+case "$@" in						\
+  */*) am__odir=`echo "./$@" | sed 's|/[^/]*$$||'`;;	\
+    *) am__odir=.;; 					\
+esac;							\
+test "x$$am__odir" = x"." || test -d "$$am__odir" 	\
+  || $(MKDIR_P) "$$am__odir" || exit $$?;		\
+if test -f "./$$f"; then dir=./;			\
+elif test -f "$$f"; then dir=;				\
+else dir="$(srcdir)/"; fi;				\
+tst=$$dir$$f; log='$@'; 				\
+if test -n '$(DISABLE_HARD_ERRORS)'; then		\
+  am__enable_hard_errors=no; 				\
+else							\
+  am__enable_hard_errors=yes; 				\
+fi; 							\
+case " $(XFAIL_TESTS) " in				\
+  *[\ \	]$$f[\ \	]* | *[\ \	]$$dir$$f[\ \	]*) \
+    am__expect_failure=yes;;				\
+  *)							\
+    am__expect_failure=no;;				\
+esac; 							\
+$(AM_TESTS_ENVIRONMENT) $(TESTS_ENVIRONMENT)
+# A shell command to get the names of the tests scripts with any registered
+# extension removed (i.e., equivalently, the names of the test logs, with
+# the '.log' extension removed).  The result is saved in the shell variable
+# '$bases'.  This honors runtime overriding of TESTS and TEST_LOGS.  Sadly,
+# we cannot use something simpler, involving e.g., "$(TEST_LOGS:.log=)",
+# since that might cause problem with VPATH rewrites for suffix-less tests.
+# See also 'test-harness-vpath-rewrite.sh' and 'test-trs-basic.sh'.
+am__set_TESTS_bases = \
+  bases='$(TEST_LOGS)'; \
+  bases=`for i in $$bases; do echo $$i; done | sed 's/\.log$$//'`; \
+  bases=`echo $$bases`
+RECHECK_LOGS = $(TEST_LOGS)
+AM_RECURSIVE_TARGETS = check recheck
+TEST_SUITE_LOG = test-suite.log
+TEST_EXTENSIONS = @EXEEXT@ .test
+LOG_DRIVER = $(SHELL) $(top_srcdir)/auxdir/test-driver
+LOG_COMPILE = $(LOG_COMPILER) $(AM_LOG_FLAGS) $(LOG_FLAGS)
+am__set_b = \
+  case '$@' in \
+    */*) \
+      case '$*' in \
+        */*) b='$*';; \
+          *) b=`echo '$@' | sed 's/\.log$$//'`; \
+       esac;; \
+    *) \
+      b='$*';; \
+  esac
+am__test_logs1 = $(TESTS:=.log)
+am__test_logs2 = $(am__test_logs1:@EXEEXT@.log=.log)
+TEST_LOGS = $(am__test_logs2:.test.log=.log)
+TEST_LOG_DRIVER = $(SHELL) $(top_srcdir)/auxdir/test-driver
+TEST_LOG_COMPILE = $(TEST_LOG_COMPILER) $(AM_TEST_LOG_FLAGS) \
+	$(TEST_LOG_FLAGS)
+am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/auxdir/depcomp \
+	$(top_srcdir)/auxdir/test-driver
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AR_FLAGS = @AR_FLAGS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CHECK_CFLAGS = @CHECK_CFLAGS@
+CHECK_LIBS = @CHECK_LIBS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CRAY_JOB_CPPFLAGS = @CRAY_JOB_CPPFLAGS@
+CRAY_JOB_LDFLAGS = @CRAY_JOB_LDFLAGS@
+CRAY_SELECT_CPPFLAGS = @CRAY_SELECT_CPPFLAGS@
+CRAY_SELECT_LDFLAGS = @CRAY_SELECT_LDFLAGS@
+CRAY_SWITCH_CPPFLAGS = @CRAY_SWITCH_CPPFLAGS@
+CRAY_SWITCH_LDFLAGS = @CRAY_SWITCH_LDFLAGS@
+CRAY_TASK_CPPFLAGS = @CRAY_TASK_CPPFLAGS@
+CRAY_TASK_LDFLAGS = @CRAY_TASK_LDFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DATAWARP_CPPFLAGS = @DATAWARP_CPPFLAGS@
+DATAWARP_LDFLAGS = @DATAWARP_LDFLAGS@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DL_LIBS = @DL_LIBS@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+FREEIPMI_CPPFLAGS = @FREEIPMI_CPPFLAGS@
+FREEIPMI_LDFLAGS = @FREEIPMI_LDFLAGS@
+FREEIPMI_LIBS = @FREEIPMI_LIBS@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_COMPILE_RESOURCES = @GLIB_COMPILE_RESOURCES@
+GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
+GLIB_LIBS = @GLIB_LIBS@
+GLIB_MKENUMS = @GLIB_MKENUMS@
+GOBJECT_QUERY = @GOBJECT_QUERY@
+GREP = @GREP@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_LIBS = @GTK_LIBS@
+H5CC = @H5CC@
+H5FC = @H5FC@
+HAVEMYSQLCONFIG = @HAVEMYSQLCONFIG@
+HAVE_MAN2HTML = @HAVE_MAN2HTML@
+HDF5_CC = @HDF5_CC@
+HDF5_CFLAGS = @HDF5_CFLAGS@
+HDF5_CPPFLAGS = @HDF5_CPPFLAGS@
+HDF5_FC = @HDF5_FC@
+HDF5_FFLAGS = @HDF5_FFLAGS@
+HDF5_FLIBS = @HDF5_FLIBS@
+HDF5_LDFLAGS = @HDF5_LDFLAGS@
+HDF5_LIBS = @HDF5_LIBS@
+HDF5_TYPE = @HDF5_TYPE@
+HDF5_VERSION = @HDF5_VERSION@
+HTTP_PARSER_CPPFLAGS = @HTTP_PARSER_CPPFLAGS@
+HTTP_PARSER_LDFLAGS = @HTTP_PARSER_LDFLAGS@
+HWLOC_CPPFLAGS = @HWLOC_CPPFLAGS@
+HWLOC_LDFLAGS = @HWLOC_LDFLAGS@
+HWLOC_LIBS = @HWLOC_LIBS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+JSON_CPPFLAGS = @JSON_CPPFLAGS@
+JSON_LDFLAGS = @JSON_LDFLAGS@
+JWT_CPPFLAGS = @JWT_CPPFLAGS@
+JWT_LDFLAGS = @JWT_LDFLAGS@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBCURL = @LIBCURL@
+LIBCURL_CPPFLAGS = @LIBCURL_CPPFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIB_SLURM = @LIB_SLURM@
+LIB_SLURM_BUILD = @LIB_SLURM_BUILD@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
+LZ4_CPPFLAGS = @LZ4_CPPFLAGS@
+LZ4_LDFLAGS = @LZ4_LDFLAGS@
+LZ4_LIBS = @LZ4_LIBS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MKDIR_P = @MKDIR_P@
+MUNGE_CPPFLAGS = @MUNGE_CPPFLAGS@
+MUNGE_DIR = @MUNGE_DIR@
+MUNGE_LDFLAGS = @MUNGE_LDFLAGS@
+MUNGE_LIBS = @MUNGE_LIBS@
+MYSQL_CFLAGS = @MYSQL_CFLAGS@
+MYSQL_LIBS = @MYSQL_LIBS@
+NETLOC_CPPFLAGS = @NETLOC_CPPFLAGS@
+NETLOC_LDFLAGS = @NETLOC_LDFLAGS@
+NETLOC_LIBS = @NETLOC_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+NUMA_LIBS = @NUMA_LIBS@
+NVML_CPPFLAGS = @NVML_CPPFLAGS@
+NVML_LIBS = @NVML_LIBS@
+OBJCOPY = @OBJCOPY@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OFED_CPPFLAGS = @OFED_CPPFLAGS@
+OFED_LDFLAGS = @OFED_LDFLAGS@
+OFED_LIBS = @OFED_LIBS@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PAM_DIR = @PAM_DIR@
+PAM_LIBS = @PAM_LIBS@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+PMIX_V1_CPPFLAGS = @PMIX_V1_CPPFLAGS@
+PMIX_V1_LDFLAGS = @PMIX_V1_LDFLAGS@
+PMIX_V2_CPPFLAGS = @PMIX_V2_CPPFLAGS@
+PMIX_V2_LDFLAGS = @PMIX_V2_LDFLAGS@
+PMIX_V3_CPPFLAGS = @PMIX_V3_CPPFLAGS@
+PMIX_V3_LDFLAGS = @PMIX_V3_LDFLAGS@
+PMIX_V4_CPPFLAGS = @PMIX_V4_CPPFLAGS@
+PMIX_V4_LDFLAGS = @PMIX_V4_LDFLAGS@
+PROJECT = @PROJECT@
+PTHREAD_CC = @PTHREAD_CC@
+PTHREAD_CFLAGS = @PTHREAD_CFLAGS@
+PTHREAD_LIBS = @PTHREAD_LIBS@
+RANLIB = @RANLIB@
+READLINE_LIBS = @READLINE_LIBS@
+RELEASE = @RELEASE@
+RRDTOOL_CPPFLAGS = @RRDTOOL_CPPFLAGS@
+RRDTOOL_LDFLAGS = @RRDTOOL_LDFLAGS@
+RRDTOOL_LIBS = @RRDTOOL_LIBS@
+RSMI_CPPFLAGS = @RSMI_CPPFLAGS@
+RSMI_LDFLAGS = @RSMI_LDFLAGS@
+RSMI_LIBS = @RSMI_LIBS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SLEEP_CMD = @SLEEP_CMD@
+SLURMCTLD_PORT = @SLURMCTLD_PORT@
+SLURMCTLD_PORT_COUNT = @SLURMCTLD_PORT_COUNT@
+SLURMDBD_PORT = @SLURMDBD_PORT@
+SLURMD_PORT = @SLURMD_PORT@
+SLURMRESTD_PORT = @SLURMRESTD_PORT@
+SLURM_API_AGE = @SLURM_API_AGE@
+SLURM_API_CURRENT = @SLURM_API_CURRENT@
+SLURM_API_MAJOR = @SLURM_API_MAJOR@
+SLURM_API_REVISION = @SLURM_API_REVISION@
+SLURM_API_VERSION = @SLURM_API_VERSION@
+SLURM_MAJOR = @SLURM_MAJOR@
+SLURM_MICRO = @SLURM_MICRO@
+SLURM_MINOR = @SLURM_MINOR@
+SLURM_PREFIX = @SLURM_PREFIX@
+SLURM_VERSION_NUMBER = @SLURM_VERSION_NUMBER@
+SLURM_VERSION_STRING = @SLURM_VERSION_STRING@
+STRIP = @STRIP@
+SUCMD = @SUCMD@
+SYSTEMD_TASKSMAX_OPTION = @SYSTEMD_TASKSMAX_OPTION@
+UCX_CPPFLAGS = @UCX_CPPFLAGS@
+UCX_LDFLAGS = @UCX_LDFLAGS@
+UCX_LIBS = @UCX_LIBS@
+UTIL_LIBS = @UTIL_LIBS@
+VERSION = @VERSION@
+YAML_CPPFLAGS = @YAML_CPPFLAGS@
+YAML_LDFLAGS = @YAML_LDFLAGS@
+ZLIB_CPPFLAGS = @ZLIB_CPPFLAGS@
+ZLIB_LDFLAGS = @ZLIB_LDFLAGS@
+ZLIB_LIBS = @ZLIB_LIBS@
+_libcurl_config = @_libcurl_config@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+ac_have_man2html = @ac_have_man2html@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+ax_pthread_config = @ax_pthread_config@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lua_CFLAGS = @lua_CFLAGS@
+lua_LIBS = @lua_LIBS@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+runstatedir = @runstatedir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AUTOMAKE_OPTIONS = foreign
+AM_CPPFLAGS = -I$(top_srcdir) -ldl -lpthread
+LDADD = $(top_builddir)/src/api/libslurm.o \
+	$(top_builddir)/src/slurmd/common/libslurmd_common.o \
+	$(HWLOC_LDFLAGS) $(HWLOC_LIBS) \
+	$(DL_LIBS)
+
+@HAVE_CHECK_TRUE@MYCFLAGS = @CHECK_CFLAGS@ -Wall -std=c99
+@HAVE_CHECK_TRUE@reverse_tree_math_test_CFLAGS = $(MYCFLAGS)
+@HAVE_CHECK_TRUE@reverse_tree_math_test_LDADD = $(LDADD) @CHECK_LIBS@
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .log .o .obj .test .test$(EXEEXT) .trs
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign testsuite/slurm_unit/slurmd/common/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign testsuite/slurm_unit/slurmd/common/Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-checkPROGRAMS:
+	@list='$(check_PROGRAMS)'; test -n "$$list" || exit 0; \
+	echo " rm -f" $$list; \
+	rm -f $$list || exit $$?; \
+	test -n "$(EXEEXT)" || exit 0; \
+	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
+	echo " rm -f" $$list; \
+	rm -f $$list
+
+reverse_tree_math-test$(EXEEXT): $(reverse_tree_math_test_OBJECTS) $(reverse_tree_math_test_DEPENDENCIES) $(EXTRA_reverse_tree_math_test_DEPENDENCIES) 
+	@rm -f reverse_tree_math-test$(EXEEXT)
+	$(AM_V_CCLD)$(reverse_tree_math_test_LINK) $(reverse_tree_math_test_OBJECTS) $(reverse_tree_math_test_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reverse_tree_math_test-reverse_tree_math-test.Po@am__quote@ # am--include-marker
+
+$(am__depfiles_remade):
+	@$(MKDIR_P) $(@D)
+	@echo '# dummy' >$@-t && $(am__mv) $@-t $@
+
+am--depfiles: $(am__depfiles_remade)
+
+.c.o:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
+
+reverse_tree_math_test-reverse_tree_math-test.o: reverse_tree_math-test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(reverse_tree_math_test_CFLAGS) $(CFLAGS) -MT reverse_tree_math_test-reverse_tree_math-test.o -MD -MP -MF $(DEPDIR)/reverse_tree_math_test-reverse_tree_math-test.Tpo -c -o reverse_tree_math_test-reverse_tree_math-test.o `test -f 'reverse_tree_math-test.c' || echo '$(srcdir)/'`reverse_tree_math-test.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/reverse_tree_math_test-reverse_tree_math-test.Tpo $(DEPDIR)/reverse_tree_math_test-reverse_tree_math-test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='reverse_tree_math-test.c' object='reverse_tree_math_test-reverse_tree_math-test.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(reverse_tree_math_test_CFLAGS) $(CFLAGS) -c -o reverse_tree_math_test-reverse_tree_math-test.o `test -f 'reverse_tree_math-test.c' || echo '$(srcdir)/'`reverse_tree_math-test.c
+
+reverse_tree_math_test-reverse_tree_math-test.obj: reverse_tree_math-test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(reverse_tree_math_test_CFLAGS) $(CFLAGS) -MT reverse_tree_math_test-reverse_tree_math-test.obj -MD -MP -MF $(DEPDIR)/reverse_tree_math_test-reverse_tree_math-test.Tpo -c -o reverse_tree_math_test-reverse_tree_math-test.obj `if test -f 'reverse_tree_math-test.c'; then $(CYGPATH_W) 'reverse_tree_math-test.c'; else $(CYGPATH_W) '$(srcdir)/reverse_tree_math-test.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/reverse_tree_math_test-reverse_tree_math-test.Tpo $(DEPDIR)/reverse_tree_math_test-reverse_tree_math-test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='reverse_tree_math-test.c' object='reverse_tree_math_test-reverse_tree_math-test.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(reverse_tree_math_test_CFLAGS) $(CFLAGS) -c -o reverse_tree_math_test-reverse_tree_math-test.obj `if test -f 'reverse_tree_math-test.c'; then $(CYGPATH_W) 'reverse_tree_math-test.c'; else $(CYGPATH_W) '$(srcdir)/reverse_tree_math-test.c'; fi`
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+# Recover from deleted '.trs' file; this should ensure that
+# "rm -f foo.log; make foo.trs" re-run 'foo.test', and re-create
+# both 'foo.log' and 'foo.trs'.  Break the recipe in two subshells
+# to avoid problems with "make -n".
+.log.trs:
+	rm -f $< $@
+	$(MAKE) $(AM_MAKEFLAGS) $<
+
+# Leading 'am--fnord' is there to ensure the list of targets does not
+# expand to empty, as could happen e.g. with make check TESTS=''.
+am--fnord $(TEST_LOGS) $(TEST_LOGS:.log=.trs): $(am__force_recheck)
+am--force-recheck:
+	@:
+
+$(TEST_SUITE_LOG): $(TEST_LOGS)
+	@$(am__set_TESTS_bases); \
+	am__f_ok () { test -f "$$1" && test -r "$$1"; }; \
+	redo_bases=`for i in $$bases; do \
+	              am__f_ok $$i.trs && am__f_ok $$i.log || echo $$i; \
+	            done`; \
+	if test -n "$$redo_bases"; then \
+	  redo_logs=`for i in $$redo_bases; do echo $$i.log; done`; \
+	  redo_results=`for i in $$redo_bases; do echo $$i.trs; done`; \
+	  if $(am__make_dryrun); then :; else \
+	    rm -f $$redo_logs && rm -f $$redo_results || exit 1; \
+	  fi; \
+	fi; \
+	if test -n "$$am__remaking_logs"; then \
+	  echo "fatal: making $(TEST_SUITE_LOG): possible infinite" \
+	       "recursion detected" >&2; \
+	elif test -n "$$redo_logs"; then \
+	  am__remaking_logs=yes $(MAKE) $(AM_MAKEFLAGS) $$redo_logs; \
+	fi; \
+	if $(am__make_dryrun); then :; else \
+	  st=0;  \
+	  errmsg="fatal: making $(TEST_SUITE_LOG): failed to create"; \
+	  for i in $$redo_bases; do \
+	    test -f $$i.trs && test -r $$i.trs \
+	      || { echo "$$errmsg $$i.trs" >&2; st=1; }; \
+	    test -f $$i.log && test -r $$i.log \
+	      || { echo "$$errmsg $$i.log" >&2; st=1; }; \
+	  done; \
+	  test $$st -eq 0 || exit 1; \
+	fi
+	@$(am__sh_e_setup); $(am__tty_colors); $(am__set_TESTS_bases); \
+	ws='[ 	]'; \
+	results=`for b in $$bases; do echo $$b.trs; done`; \
+	test -n "$$results" || results=/dev/null; \
+	all=`  grep "^$$ws*:test-result:"           $$results | wc -l`; \
+	pass=` grep "^$$ws*:test-result:$$ws*PASS"  $$results | wc -l`; \
+	fail=` grep "^$$ws*:test-result:$$ws*FAIL"  $$results | wc -l`; \
+	skip=` grep "^$$ws*:test-result:$$ws*SKIP"  $$results | wc -l`; \
+	xfail=`grep "^$$ws*:test-result:$$ws*XFAIL" $$results | wc -l`; \
+	xpass=`grep "^$$ws*:test-result:$$ws*XPASS" $$results | wc -l`; \
+	error=`grep "^$$ws*:test-result:$$ws*ERROR" $$results | wc -l`; \
+	if test `expr $$fail + $$xpass + $$error` -eq 0; then \
+	  success=true; \
+	else \
+	  success=false; \
+	fi; \
+	br='==================='; br=$$br$$br$$br$$br; \
+	result_count () \
+	{ \
+	    if test x"$$1" = x"--maybe-color"; then \
+	      maybe_colorize=yes; \
+	    elif test x"$$1" = x"--no-color"; then \
+	      maybe_colorize=no; \
+	    else \
+	      echo "$@: invalid 'result_count' usage" >&2; exit 4; \
+	    fi; \
+	    shift; \
+	    desc=$$1 count=$$2; \
+	    if test $$maybe_colorize = yes && test $$count -gt 0; then \
+	      color_start=$$3 color_end=$$std; \
+	    else \
+	      color_start= color_end=; \
+	    fi; \
+	    echo "$${color_start}# $$desc $$count$${color_end}"; \
+	}; \
+	create_testsuite_report () \
+	{ \
+	  result_count $$1 "TOTAL:" $$all   "$$brg"; \
+	  result_count $$1 "PASS: " $$pass  "$$grn"; \
+	  result_count $$1 "SKIP: " $$skip  "$$blu"; \
+	  result_count $$1 "XFAIL:" $$xfail "$$lgn"; \
+	  result_count $$1 "FAIL: " $$fail  "$$red"; \
+	  result_count $$1 "XPASS:" $$xpass "$$red"; \
+	  result_count $$1 "ERROR:" $$error "$$mgn"; \
+	}; \
+	{								\
+	  echo "$(PACKAGE_STRING): $(subdir)/$(TEST_SUITE_LOG)" |	\
+	    $(am__rst_title);						\
+	  create_testsuite_report --no-color;				\
+	  echo;								\
+	  echo ".. contents:: :depth: 2";				\
+	  echo;								\
+	  for b in $$bases; do echo $$b; done				\
+	    | $(am__create_global_log);					\
+	} >$(TEST_SUITE_LOG).tmp || exit 1;				\
+	mv $(TEST_SUITE_LOG).tmp $(TEST_SUITE_LOG);			\
+	if $$success; then						\
+	  col="$$grn";							\
+	 else								\
+	  col="$$red";							\
+	  test x"$$VERBOSE" = x || cat $(TEST_SUITE_LOG);		\
+	fi;								\
+	echo "$${col}$$br$${std}"; 					\
+	echo "$${col}Testsuite summary for $(PACKAGE_STRING)$${std}";	\
+	echo "$${col}$$br$${std}"; 					\
+	create_testsuite_report --maybe-color;				\
+	echo "$$col$$br$$std";						\
+	if $$success; then :; else					\
+	  echo "$${col}See $(subdir)/$(TEST_SUITE_LOG)$${std}";		\
+	  if test -n "$(PACKAGE_BUGREPORT)"; then			\
+	    echo "$${col}Please report to $(PACKAGE_BUGREPORT)$${std}";	\
+	  fi;								\
+	  echo "$$col$$br$$std";					\
+	fi;								\
+	$$success || exit 1
+
+check-TESTS: $(check_PROGRAMS)
+	@list='$(RECHECK_LOGS)';           test -z "$$list" || rm -f $$list
+	@list='$(RECHECK_LOGS:.log=.trs)'; test -z "$$list" || rm -f $$list
+	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
+	@set +e; $(am__set_TESTS_bases); \
+	log_list=`for i in $$bases; do echo $$i.log; done`; \
+	trs_list=`for i in $$bases; do echo $$i.trs; done`; \
+	log_list=`echo $$log_list`; trs_list=`echo $$trs_list`; \
+	$(MAKE) $(AM_MAKEFLAGS) $(TEST_SUITE_LOG) TEST_LOGS="$$log_list"; \
+	exit $$?;
+recheck: all $(check_PROGRAMS)
+	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
+	@set +e; $(am__set_TESTS_bases); \
+	bases=`for i in $$bases; do echo $$i; done \
+	         | $(am__list_recheck_tests)` || exit 1; \
+	log_list=`for i in $$bases; do echo $$i.log; done`; \
+	log_list=`echo $$log_list`; \
+	$(MAKE) $(AM_MAKEFLAGS) $(TEST_SUITE_LOG) \
+	        am__force_recheck=am--force-recheck \
+	        TEST_LOGS="$$log_list"; \
+	exit $$?
+reverse_tree_math-test.log: reverse_tree_math-test$(EXEEXT)
+	@p='reverse_tree_math-test$(EXEEXT)'; \
+	b='reverse_tree_math-test'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+.test.log:
+	@p='$<'; \
+	$(am__set_b); \
+	$(am__check_pre) $(TEST_LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+@am__EXEEXT_TRUE@.test$(EXEEXT).log:
+@am__EXEEXT_TRUE@	@p='$<'; \
+@am__EXEEXT_TRUE@	$(am__set_b); \
+@am__EXEEXT_TRUE@	$(am__check_pre) $(TEST_LOG_DRIVER) --test-name "$$f" \
+@am__EXEEXT_TRUE@	--log-file $$b.log --trs-file $$b.trs \
+@am__EXEEXT_TRUE@	$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \
+@am__EXEEXT_TRUE@	"$$tst" $(AM_TESTS_FD_REDIRECT)
+
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+	$(MAKE) $(AM_MAKEFLAGS) $(check_PROGRAMS)
+	$(MAKE) $(AM_MAKEFLAGS) check-TESTS
+check: check-am
+all-am: Makefile
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+	-test -z "$(TEST_LOGS)" || rm -f $(TEST_LOGS)
+	-test -z "$(TEST_LOGS:.log=.trs)" || rm -f $(TEST_LOGS:.log=.trs)
+	-test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-checkPROGRAMS clean-generic clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+		-rm -f ./$(DEPDIR)/reverse_tree_math_test-reverse_tree_math-test.Po
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+		-rm -f ./$(DEPDIR)/reverse_tree_math_test-reverse_tree_math-test.Po
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: check-am install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-TESTS \
+	check-am clean clean-checkPROGRAMS clean-generic clean-libtool \
+	cscopelist-am ctags ctags-am distclean distclean-compile \
+	distclean-generic distclean-libtool distclean-tags distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	recheck tags tags-am uninstall uninstall-am
+
+.PRECIOUS: Makefile
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/testsuite/slurm_unit/slurmd/common/reverse_tree_math-test.c b/testsuite/slurm_unit/slurmd/common/reverse_tree_math-test.c
new file mode 100644
index 0000000000..a57dad0dc4
--- /dev/null
+++ b/testsuite/slurm_unit/slurmd/common/reverse_tree_math-test.c
@@ -0,0 +1,149 @@
+/*****************************************************************************\
+ *  Copyright (C) 2020 SchedMD LLC.
+ *  Written by Nathan Rini <nate@schedmd.com>
+ *
+ *  Copyright (C) 2006 The Regents of the University of California.
+ *  Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
+ *  Written by Christopher J. Morrone <morrone2@llnl.gov>
+ *  CODE-OCEC-09-009. All rights reserved.
+ *  Portions copyright (C) 2014 Institute of Semiconductor Physics
+ *                     Siberian Branch of Russian Academy of Science
+ *  Written by Artem Polyakov <artpol84@gmail.com>.
+ *  All rights reserved.
+ *  Portions copyright (C) 2017 Mellanox Technologies.
+ *  Written by Artem Polyakov <artpol84@gmail.com>.
+ *  All rights reserved.
+ *
+ *  This file is part of Slurm, a resource management program.
+ *  For details, see <https://slurm.schedmd.com/>.
+ *  Please also read the included file: DISCLAIMER.
+ *
+ *  Slurm is free software; you can redistribute it and/or modify it under
+ *  the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  In addition, as a special exception, the copyright holders give permission
+ *  to link the code of portions of this program with the OpenSSL library under
+ *  certain conditions as described in each individual source file, and
+ *  distribute linked combinations including the two. You must obey the GNU
+ *  General Public License in all respects for all of the code used other than
+ *  OpenSSL. If you modify file(s) with this exception, you may extend this
+ *  exception to your version of the file(s), but you are not obligated to do
+ *  so. If you do not wish to do so, delete this exception statement from your
+ *  version.  If you delete this exception statement from all source files in
+ *  the program, then also delete it here.
+ *
+ *  Slurm is distributed in the hope that it will be useful, but WITHOUT ANY
+ *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ *  details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with Slurm; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.
+\*****************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <check.h>
+
+#include "slurm/slurm_errno.h"
+#include "src/common/log.h"
+#include "src/common/xmalloc.h"
+#include "src/common/xstring.h"
+
+/* include code directly to allow access to static functions */
+#include "src/slurmd/common/reverse_tree_math.c"
+
+/* define the external variable */
+void *conf;
+
+/*
+ * Dumb brute force function
+ */
+static int _dumb_direct_children(int *children, int width, int id,
+				 int max_node_id)
+{
+	int child;
+	int count = 0;
+
+	for (child = id + 1; child < max_node_id; child++) {
+		int parent_id, child_num, depth, max_depth;
+
+		reverse_tree_info(child, max_node_id, width, &parent_id,
+				  &child_num, &depth, &max_depth);
+		if (parent_id == id)
+			children[count++] = child;
+	}
+
+	return count;
+}
+
+/* Bug 8196 makes the second case to fail on 20.02 */
+static const int nodes_loop[] = {8192/*,  8192*/};
+static const int width_loop[] = {   5/*, 65533*/};
+START_TEST(verify_children)
+{
+	int nodes = nodes_loop[_i];
+	int width = width_loop[_i];
+	int parent, children, depth, maxdepth;
+	int *children1 = xcalloc(sizeof(int), width);
+	int *children2 = xcalloc(sizeof(int), width);
+
+	for (int i = 0; i < nodes; i++) {
+		int cnt1, cnt2;
+
+		reverse_tree_info(i, nodes, width, &parent, &children, &depth,
+				  &maxdepth);
+
+		ck_assert_msg(children >= 0, "nchild: %d", children);
+
+/* 		debug("%s: %d : parent: %d nchild: %d depth: %d, maxdepth: %d", */
+/* 		      __func__, i, parent, children, depth, maxdepth); */
+		cnt1 = _dumb_direct_children(children1, width, i, nodes);
+		cnt2 = reverse_tree_direct_children(i, nodes, width, depth, children2);
+
+		ck_assert_msg(cnt1 == cnt2,
+			      "%s: Direct children sanity check error: cnt1 = %d, cnt2 = %d",
+			      __func__, cnt1, cnt2);
+
+		for (int j = 0; j < cnt1; j++) {
+			ck_assert_msg(children1[j] == children2[j],
+				      "Direct children: cnt1 = %d, cnt2 = %d: %d'th element: children1[%d] = %d, children2[%d] = %d",
+				      cnt1, cnt2, j, j, children1[j], j,
+				      children2[j]);
+		}
+	}
+
+	xfree(children1);
+	xfree(children2);
+}
+END_TEST
+
+Suite *suite_reverse_tree_math(void)
+{
+	Suite *s = suite_create("reverse_tree_math");
+	TCase *tc_core = tcase_create("reverse_tree_math");
+	tcase_set_timeout(tc_core, 60); /* Avoid timeouts with --coverage */
+	tcase_add_loop_test(tc_core, verify_children, 0, sizeof(nodes_loop) /
+			    sizeof(int));
+	suite_add_tcase(s, tc_core);
+	return s;
+}
+
+int main(void)
+{
+	log_options_t log_opts = LOG_OPTS_INITIALIZER;
+	log_opts.stderr_level = LOG_LEVEL_DEBUG5;
+	log_init("reverse_tree_math-test", log_opts, 0, NULL);
+
+	int number_failed;
+	SRunner *sr = srunner_create(suite_reverse_tree_math());
+	srunner_run_all(sr, CK_ENV);
+	number_failed = srunner_ntests_failed(sr);
+	srunner_free(sr);
+
+	return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
